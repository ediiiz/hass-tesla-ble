// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Destination {
    #[prost(oneof = "destination::SubDestination", tags = "1, 2")]
    pub sub_destination: ::core::option::Option<destination::SubDestination>,
}
/// Nested message and enum types in `Destination`.
pub mod destination {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubDestination {
        #[prost(enumeration = "super::Domain", tag = "1")]
        Domain(i32),
        #[prost(bytes, tag = "2")]
        RoutingAddress(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageStatus {
    #[prost(enumeration = "OperationStatusE", tag = "1")]
    pub operation_status: i32,
    #[prost(enumeration = "MessageFaultE", tag = "2")]
    pub signed_message_fault: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionInfoRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub challenge: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutableMessage {
    #[prost(message, optional, tag = "6")]
    pub to_destination: ::core::option::Option<Destination>,
    #[prost(message, optional, tag = "7")]
    pub from_destination: ::core::option::Option<Destination>,
    #[prost(message, optional, tag = "12")]
    pub signed_message_status: ::core::option::Option<MessageStatus>,
    #[prost(bytes = "vec", tag = "50")]
    pub request_uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "51")]
    pub uuid: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "52")]
    pub flags: u32,
    #[prost(oneof = "routable_message::Payload", tags = "10, 14, 15")]
    pub payload: ::core::option::Option<routable_message::Payload>,
    #[prost(oneof = "routable_message::SubSigData", tags = "13")]
    pub sub_sig_data: ::core::option::Option<routable_message::SubSigData>,
}
/// Nested message and enum types in `RoutableMessage`.
pub mod routable_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(bytes, tag = "10")]
        ProtobufMessageAsBytes(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "14")]
        SessionInfoRequest(super::SessionInfoRequest),
        #[prost(bytes, tag = "15")]
        SessionInfo(::prost::alloc::vec::Vec<u8>),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubSigData {
        #[prost(message, tag = "13")]
        SignatureData(super::super::signatures::SignatureData),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Domain {
    Broadcast = 0,
    VehicleSecurity = 2,
    Infotainment = 3,
}
impl Domain {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Domain::Broadcast => "DOMAIN_BROADCAST",
            Domain::VehicleSecurity => "DOMAIN_VEHICLE_SECURITY",
            Domain::Infotainment => "DOMAIN_INFOTAINMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOMAIN_BROADCAST" => Some(Self::Broadcast),
            "DOMAIN_VEHICLE_SECURITY" => Some(Self::VehicleSecurity),
            "DOMAIN_INFOTAINMENT" => Some(Self::Infotainment),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationStatusE {
    OperationstatusOk = 0,
    OperationstatusWait = 1,
    OperationstatusError = 2,
}
impl OperationStatusE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OperationStatusE::OperationstatusOk => "OPERATIONSTATUS_OK",
            OperationStatusE::OperationstatusWait => "OPERATIONSTATUS_WAIT",
            OperationStatusE::OperationstatusError => "OPERATIONSTATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATIONSTATUS_OK" => Some(Self::OperationstatusOk),
            "OPERATIONSTATUS_WAIT" => Some(Self::OperationstatusWait),
            "OPERATIONSTATUS_ERROR" => Some(Self::OperationstatusError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MessageFaultE {
    /// Request succeeded.
    MessagefaultErrorNone = 0,
    /// Required vehicle subsystem is busy. Try again.
    MessagefaultErrorBusy = 1,
    /// Vehicle subsystem did not respond. Try again.
    MessagefaultErrorTimeout = 2,
    /// Vehicle did not recognize the key used to authorize command. Make sure your key is paired with the vehicle.
    MessagefaultErrorUnknownKeyId = 3,
    /// Key used to authorize command has been disabled.
    MessagefaultErrorInactiveKey = 4,
    /// Command signature/MAC is incorrect. Use included session info to update session and try again.
    MessagefaultErrorInvalidSignature = 5,
    /// Command anti-replay counter has been used before. Use included session info to update session and try again.
    MessagefaultErrorInvalidTokenOrCounter = 6,
    /// User is not authorized to execute command. This can be because of the role or because of vehicle state.
    MessagefaultErrorInsufficientPrivileges = 7,
    /// Command was malformed or addressed to an unrecognized vehicle system. May indicate client error or older vehicle firmware.
    MessagefaultErrorInvalidDomains = 8,
    /// Unrecognized command. May indicate client error or unsupported vehicle firmware.
    MessagefaultErrorInvalidCommand = 9,
    /// Could not parse command. Indicates client error.
    MessagefaultErrorDecoding = 10,
    /// Internal vehicle error. Try again. Most commonly encountered when the vehicle has not finished booting.
    MessagefaultErrorInternal = 11,
    /// Command sent to wrong VIN.
    MessagefaultErrorWrongPersonalization = 12,
    /// Command was malformed or used a deprecated parameter.
    MessagefaultErrorBadParameter = 13,
    /// Vehicle's keychain is full. You must delete a key before you can add another.
    MessagefaultErrorKeychainIsFull = 14,
    /// Session ID mismatch. Use included session info to update session and try again.
    MessagefaultErrorIncorrectEpoch = 15,
    /// Initialization Value length is incorrect (AES-GCM must use 12-byte IVs). Indicates a client programming error.
    MessagefaultErrorIvIncorrectLength = 16,
    /// Command expired. Use included session info to determine if clocks have desynchronized and try again.
    MessagefaultErrorTimeExpired = 17,
    /// Vehicle has not been provisioned with a VIN and may require service.
    MessagefaultErrorNotProvisionedWithIdentity = 18,
    /// Internal vehicle error.
    MessagefaultErrorCouldNotHashMetadata = 19,
    /// Vehicle rejected command because its expiration time was too far in the future. This is a security precaution.
    MessagefaultErrorTimeToLiveTooLong = 20,
    /// The vehicle owner has disabled Mobile access.
    MessagefaultErrorRemoteAccessDisabled = 21,
    /// The command was authorized with a Service key, but the vehicle has not been configured to permit remote service commands.
    MessagefaultErrorRemoteServiceAccessDisabled = 22,
    /// The command requires proof of Tesla account credentials but was not sent over a channel that provides this proof. Resend the command using Fleet API.
    MessagefaultErrorCommandRequiresAccountCredentials = 23,
    /// Client sent a request with a field that exceeds MTU
    MessagefaultErrorRequestMtuExceeded = 24,
    /// Client's request was received, but response size exceeded MTU
    MessagefaultErrorResponseMtuExceeded = 25,
    MessagefaultErrorRepeatedCounter = 26,
    MessagefaultErrorInvalidKeyHandle = 27,
    MessagefaultErrorRequiresResponseEncryption = 28,
}
impl MessageFaultE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            MessageFaultE::MessagefaultErrorNone => "MESSAGEFAULT_ERROR_NONE",
            MessageFaultE::MessagefaultErrorBusy => "MESSAGEFAULT_ERROR_BUSY",
            MessageFaultE::MessagefaultErrorTimeout => "MESSAGEFAULT_ERROR_TIMEOUT",
            MessageFaultE::MessagefaultErrorUnknownKeyId => {
                "MESSAGEFAULT_ERROR_UNKNOWN_KEY_ID"
            }
            MessageFaultE::MessagefaultErrorInactiveKey => {
                "MESSAGEFAULT_ERROR_INACTIVE_KEY"
            }
            MessageFaultE::MessagefaultErrorInvalidSignature => {
                "MESSAGEFAULT_ERROR_INVALID_SIGNATURE"
            }
            MessageFaultE::MessagefaultErrorInvalidTokenOrCounter => {
                "MESSAGEFAULT_ERROR_INVALID_TOKEN_OR_COUNTER"
            }
            MessageFaultE::MessagefaultErrorInsufficientPrivileges => {
                "MESSAGEFAULT_ERROR_INSUFFICIENT_PRIVILEGES"
            }
            MessageFaultE::MessagefaultErrorInvalidDomains => {
                "MESSAGEFAULT_ERROR_INVALID_DOMAINS"
            }
            MessageFaultE::MessagefaultErrorInvalidCommand => {
                "MESSAGEFAULT_ERROR_INVALID_COMMAND"
            }
            MessageFaultE::MessagefaultErrorDecoding => "MESSAGEFAULT_ERROR_DECODING",
            MessageFaultE::MessagefaultErrorInternal => "MESSAGEFAULT_ERROR_INTERNAL",
            MessageFaultE::MessagefaultErrorWrongPersonalization => {
                "MESSAGEFAULT_ERROR_WRONG_PERSONALIZATION"
            }
            MessageFaultE::MessagefaultErrorBadParameter => {
                "MESSAGEFAULT_ERROR_BAD_PARAMETER"
            }
            MessageFaultE::MessagefaultErrorKeychainIsFull => {
                "MESSAGEFAULT_ERROR_KEYCHAIN_IS_FULL"
            }
            MessageFaultE::MessagefaultErrorIncorrectEpoch => {
                "MESSAGEFAULT_ERROR_INCORRECT_EPOCH"
            }
            MessageFaultE::MessagefaultErrorIvIncorrectLength => {
                "MESSAGEFAULT_ERROR_IV_INCORRECT_LENGTH"
            }
            MessageFaultE::MessagefaultErrorTimeExpired => {
                "MESSAGEFAULT_ERROR_TIME_EXPIRED"
            }
            MessageFaultE::MessagefaultErrorNotProvisionedWithIdentity => {
                "MESSAGEFAULT_ERROR_NOT_PROVISIONED_WITH_IDENTITY"
            }
            MessageFaultE::MessagefaultErrorCouldNotHashMetadata => {
                "MESSAGEFAULT_ERROR_COULD_NOT_HASH_METADATA"
            }
            MessageFaultE::MessagefaultErrorTimeToLiveTooLong => {
                "MESSAGEFAULT_ERROR_TIME_TO_LIVE_TOO_LONG"
            }
            MessageFaultE::MessagefaultErrorRemoteAccessDisabled => {
                "MESSAGEFAULT_ERROR_REMOTE_ACCESS_DISABLED"
            }
            MessageFaultE::MessagefaultErrorRemoteServiceAccessDisabled => {
                "MESSAGEFAULT_ERROR_REMOTE_SERVICE_ACCESS_DISABLED"
            }
            MessageFaultE::MessagefaultErrorCommandRequiresAccountCredentials => {
                "MESSAGEFAULT_ERROR_COMMAND_REQUIRES_ACCOUNT_CREDENTIALS"
            }
            MessageFaultE::MessagefaultErrorRequestMtuExceeded => {
                "MESSAGEFAULT_ERROR_REQUEST_MTU_EXCEEDED"
            }
            MessageFaultE::MessagefaultErrorResponseMtuExceeded => {
                "MESSAGEFAULT_ERROR_RESPONSE_MTU_EXCEEDED"
            }
            MessageFaultE::MessagefaultErrorRepeatedCounter => {
                "MESSAGEFAULT_ERROR_REPEATED_COUNTER"
            }
            MessageFaultE::MessagefaultErrorInvalidKeyHandle => {
                "MESSAGEFAULT_ERROR_INVALID_KEY_HANDLE"
            }
            MessageFaultE::MessagefaultErrorRequiresResponseEncryption => {
                "MESSAGEFAULT_ERROR_REQUIRES_RESPONSE_ENCRYPTION"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MESSAGEFAULT_ERROR_NONE" => Some(Self::MessagefaultErrorNone),
            "MESSAGEFAULT_ERROR_BUSY" => Some(Self::MessagefaultErrorBusy),
            "MESSAGEFAULT_ERROR_TIMEOUT" => Some(Self::MessagefaultErrorTimeout),
            "MESSAGEFAULT_ERROR_UNKNOWN_KEY_ID" => {
                Some(Self::MessagefaultErrorUnknownKeyId)
            }
            "MESSAGEFAULT_ERROR_INACTIVE_KEY" => Some(Self::MessagefaultErrorInactiveKey),
            "MESSAGEFAULT_ERROR_INVALID_SIGNATURE" => {
                Some(Self::MessagefaultErrorInvalidSignature)
            }
            "MESSAGEFAULT_ERROR_INVALID_TOKEN_OR_COUNTER" => {
                Some(Self::MessagefaultErrorInvalidTokenOrCounter)
            }
            "MESSAGEFAULT_ERROR_INSUFFICIENT_PRIVILEGES" => {
                Some(Self::MessagefaultErrorInsufficientPrivileges)
            }
            "MESSAGEFAULT_ERROR_INVALID_DOMAINS" => {
                Some(Self::MessagefaultErrorInvalidDomains)
            }
            "MESSAGEFAULT_ERROR_INVALID_COMMAND" => {
                Some(Self::MessagefaultErrorInvalidCommand)
            }
            "MESSAGEFAULT_ERROR_DECODING" => Some(Self::MessagefaultErrorDecoding),
            "MESSAGEFAULT_ERROR_INTERNAL" => Some(Self::MessagefaultErrorInternal),
            "MESSAGEFAULT_ERROR_WRONG_PERSONALIZATION" => {
                Some(Self::MessagefaultErrorWrongPersonalization)
            }
            "MESSAGEFAULT_ERROR_BAD_PARAMETER" => {
                Some(Self::MessagefaultErrorBadParameter)
            }
            "MESSAGEFAULT_ERROR_KEYCHAIN_IS_FULL" => {
                Some(Self::MessagefaultErrorKeychainIsFull)
            }
            "MESSAGEFAULT_ERROR_INCORRECT_EPOCH" => {
                Some(Self::MessagefaultErrorIncorrectEpoch)
            }
            "MESSAGEFAULT_ERROR_IV_INCORRECT_LENGTH" => {
                Some(Self::MessagefaultErrorIvIncorrectLength)
            }
            "MESSAGEFAULT_ERROR_TIME_EXPIRED" => Some(Self::MessagefaultErrorTimeExpired),
            "MESSAGEFAULT_ERROR_NOT_PROVISIONED_WITH_IDENTITY" => {
                Some(Self::MessagefaultErrorNotProvisionedWithIdentity)
            }
            "MESSAGEFAULT_ERROR_COULD_NOT_HASH_METADATA" => {
                Some(Self::MessagefaultErrorCouldNotHashMetadata)
            }
            "MESSAGEFAULT_ERROR_TIME_TO_LIVE_TOO_LONG" => {
                Some(Self::MessagefaultErrorTimeToLiveTooLong)
            }
            "MESSAGEFAULT_ERROR_REMOTE_ACCESS_DISABLED" => {
                Some(Self::MessagefaultErrorRemoteAccessDisabled)
            }
            "MESSAGEFAULT_ERROR_REMOTE_SERVICE_ACCESS_DISABLED" => {
                Some(Self::MessagefaultErrorRemoteServiceAccessDisabled)
            }
            "MESSAGEFAULT_ERROR_COMMAND_REQUIRES_ACCOUNT_CREDENTIALS" => {
                Some(Self::MessagefaultErrorCommandRequiresAccountCredentials)
            }
            "MESSAGEFAULT_ERROR_REQUEST_MTU_EXCEEDED" => {
                Some(Self::MessagefaultErrorRequestMtuExceeded)
            }
            "MESSAGEFAULT_ERROR_RESPONSE_MTU_EXCEEDED" => {
                Some(Self::MessagefaultErrorResponseMtuExceeded)
            }
            "MESSAGEFAULT_ERROR_REPEATED_COUNTER" => {
                Some(Self::MessagefaultErrorRepeatedCounter)
            }
            "MESSAGEFAULT_ERROR_INVALID_KEY_HANDLE" => {
                Some(Self::MessagefaultErrorInvalidKeyHandle)
            }
            "MESSAGEFAULT_ERROR_REQUIRES_RESPONSE_ENCRYPTION" => {
                Some(Self::MessagefaultErrorRequiresResponseEncryption)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Flags {
    FlagUserCommand = 0,
    FlagEncryptResponse = 1,
}
impl Flags {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Flags::FlagUserCommand => "FLAG_USER_COMMAND",
            Flags::FlagEncryptResponse => "FLAG_ENCRYPT_RESPONSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FLAG_USER_COMMAND" => Some(Self::FlagUserCommand),
            "FLAG_ENCRYPT_RESPONSE" => Some(Self::FlagEncryptResponse),
            _ => None,
        }
    }
}
