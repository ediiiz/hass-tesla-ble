// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyIdentity {
    #[prost(oneof = "key_identity::IdentityType", tags = "1, 3")]
    pub identity_type: ::core::option::Option<key_identity::IdentityType>,
}
/// Nested message and enum types in `KeyIdentity`.
pub mod key_identity {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum IdentityType {
        #[prost(bytes, tag = "1")]
        PublicKey(::prost::alloc::vec::Vec<u8>),
        #[prost(uint32, tag = "3")]
        Handle(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AesGcmPersonalizedSignatureData {
    #[prost(bytes = "vec", tag = "1")]
    pub epoch: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub counter: u32,
    #[prost(fixed32, tag = "4")]
    pub expires_at: u32,
    #[prost(bytes = "vec", tag = "5")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AesGcmResponseSignatureData {
    #[prost(bytes = "vec", tag = "1")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub counter: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HmacSignatureData {
    #[prost(bytes = "vec", tag = "1")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HmacPersonalizedSignatureData {
    #[prost(bytes = "vec", tag = "1")]
    pub epoch: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub counter: u32,
    #[prost(fixed32, tag = "3")]
    pub expires_at: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub tag: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignatureData {
    #[prost(message, optional, tag = "1")]
    pub signer_identity: ::core::option::Option<KeyIdentity>,
    #[prost(oneof = "signature_data::SigType", tags = "5, 6, 8, 9")]
    pub sig_type: ::core::option::Option<signature_data::SigType>,
}
/// Nested message and enum types in `SignatureData`.
pub mod signature_data {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SigType {
        #[prost(message, tag = "5")]
        AesGcmPersonalizedData(super::AesGcmPersonalizedSignatureData),
        #[prost(message, tag = "6")]
        SessionInfoTag(super::HmacSignatureData),
        #[prost(message, tag = "8")]
        HmacPersonalizedData(super::HmacPersonalizedSignatureData),
        #[prost(message, tag = "9")]
        AesGcmResponseData(super::AesGcmResponseSignatureData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSessionInfoRequest {
    #[prost(message, optional, tag = "1")]
    pub key_identity: ::core::option::Option<KeyIdentity>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionInfo {
    #[prost(uint32, tag = "1")]
    pub counter: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub epoch: ::prost::alloc::vec::Vec<u8>,
    #[prost(fixed32, tag = "4")]
    pub clock_time: u32,
    #[prost(enumeration = "SessionInfoStatus", tag = "5")]
    pub status: i32,
    #[prost(uint32, tag = "6")]
    pub handle: u32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Tag {
    SignatureType = 0,
    Domain = 1,
    Personalization = 2,
    Epoch = 3,
    ExpiresAt = 4,
    Counter = 5,
    Challenge = 6,
    Flags = 7,
    RequestHash = 8,
    Fault = 9,
    End = 255,
}
impl Tag {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Tag::SignatureType => "TAG_SIGNATURE_TYPE",
            Tag::Domain => "TAG_DOMAIN",
            Tag::Personalization => "TAG_PERSONALIZATION",
            Tag::Epoch => "TAG_EPOCH",
            Tag::ExpiresAt => "TAG_EXPIRES_AT",
            Tag::Counter => "TAG_COUNTER",
            Tag::Challenge => "TAG_CHALLENGE",
            Tag::Flags => "TAG_FLAGS",
            Tag::RequestHash => "TAG_REQUEST_HASH",
            Tag::Fault => "TAG_FAULT",
            Tag::End => "TAG_END",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TAG_SIGNATURE_TYPE" => Some(Self::SignatureType),
            "TAG_DOMAIN" => Some(Self::Domain),
            "TAG_PERSONALIZATION" => Some(Self::Personalization),
            "TAG_EPOCH" => Some(Self::Epoch),
            "TAG_EXPIRES_AT" => Some(Self::ExpiresAt),
            "TAG_COUNTER" => Some(Self::Counter),
            "TAG_CHALLENGE" => Some(Self::Challenge),
            "TAG_FLAGS" => Some(Self::Flags),
            "TAG_REQUEST_HASH" => Some(Self::RequestHash),
            "TAG_FAULT" => Some(Self::Fault),
            "TAG_END" => Some(Self::End),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureType {
    AesGcm = 0,
    AesGcmPersonalized = 5,
    Hmac = 6,
    HmacPersonalized = 8,
    AesGcmResponse = 9,
}
impl SignatureType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SignatureType::AesGcm => "SIGNATURE_TYPE_AES_GCM",
            SignatureType::AesGcmPersonalized => "SIGNATURE_TYPE_AES_GCM_PERSONALIZED",
            SignatureType::Hmac => "SIGNATURE_TYPE_HMAC",
            SignatureType::HmacPersonalized => "SIGNATURE_TYPE_HMAC_PERSONALIZED",
            SignatureType::AesGcmResponse => "SIGNATURE_TYPE_AES_GCM_RESPONSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_TYPE_AES_GCM" => Some(Self::AesGcm),
            "SIGNATURE_TYPE_AES_GCM_PERSONALIZED" => Some(Self::AesGcmPersonalized),
            "SIGNATURE_TYPE_HMAC" => Some(Self::Hmac),
            "SIGNATURE_TYPE_HMAC_PERSONALIZED" => Some(Self::HmacPersonalized),
            "SIGNATURE_TYPE_AES_GCM_RESPONSE" => Some(Self::AesGcmResponse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SessionInfoStatus {
    Ok = 0,
    KeyNotOnWhitelist = 1,
}
impl SessionInfoStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SessionInfoStatus::Ok => "SESSION_INFO_STATUS_OK",
            SessionInfoStatus::KeyNotOnWhitelist => {
                "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SESSION_INFO_STATUS_OK" => Some(Self::Ok),
            "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST" => Some(Self::KeyNotOnWhitelist),
            _ => None,
        }
    }
}
