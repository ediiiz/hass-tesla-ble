// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessage {
    #[prost(bytes = "vec", tag = "2")]
    pub protobuf_message_as_bytes: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "SignatureType", tag = "3")]
    pub signature_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToVcsecMessage {
    #[prost(message, optional, tag = "1")]
    pub signed_message: ::core::option::Option<SignedMessage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyIdentifier {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key_sha1: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyMetadata {
    #[prost(enumeration = "KeyFormFactor", tag = "1")]
    pub key_form_factor: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicKey {
    #[prost(bytes = "vec", tag = "1")]
    pub public_key_raw: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhitelistInfo {
    #[prost(uint32, tag = "1")]
    pub number_of_entries: u32,
    #[prost(message, repeated, tag = "2")]
    pub whitelist_entries: ::prost::alloc::vec::Vec<KeyIdentifier>,
    #[prost(uint32, tag = "3")]
    pub slot_mask: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhitelistEntryInfo {
    #[prost(message, optional, tag = "1")]
    pub key_id: ::core::option::Option<KeyIdentifier>,
    #[prost(message, optional, tag = "2")]
    pub public_key: ::core::option::Option<PublicKey>,
    #[prost(message, optional, tag = "4")]
    pub metadata_for_key: ::core::option::Option<KeyMetadata>,
    #[prost(uint32, tag = "6")]
    pub slot: u32,
    #[prost(enumeration = "super::keys::Role", tag = "7")]
    pub key_role: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InformationRequest {
    #[prost(enumeration = "InformationRequestType", tag = "1")]
    pub information_request_type: i32,
    #[prost(oneof = "information_request::Key", tags = "2, 3, 4")]
    pub key: ::core::option::Option<information_request::Key>,
}
/// Nested message and enum types in `InformationRequest`.
pub mod information_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        #[prost(message, tag = "2")]
        KeyId(super::KeyIdentifier),
        #[prost(bytes, tag = "3")]
        PublicKey(::prost::alloc::vec::Vec<u8>),
        #[prost(uint32, tag = "4")]
        Slot(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClosureMoveRequest {
    #[prost(enumeration = "ClosureMoveTypeE", tag = "1")]
    pub front_driver_door: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "2")]
    pub front_passenger_door: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "3")]
    pub rear_driver_door: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "4")]
    pub rear_passenger_door: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "5")]
    pub rear_trunk: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "6")]
    pub front_trunk: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "7")]
    pub charge_port: i32,
    #[prost(enumeration = "ClosureMoveTypeE", tag = "8")]
    pub tonneau: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PermissionChange {
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<PublicKey>,
    #[prost(uint32, tag = "3")]
    pub seconds_to_be_active: u32,
    #[prost(enumeration = "super::keys::Role", tag = "4")]
    pub key_role: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplaceKey {
    #[prost(message, optional, tag = "3")]
    pub key_to_add: ::core::option::Option<PublicKey>,
    #[prost(enumeration = "super::keys::Role", tag = "4")]
    pub key_role: i32,
    #[prost(bool, tag = "5")]
    pub impermanent: bool,
    #[prost(oneof = "replace_key::KeyToReplace", tags = "1, 2")]
    pub key_to_replace: ::core::option::Option<replace_key::KeyToReplace>,
}
/// Nested message and enum types in `ReplaceKey`.
pub mod replace_key {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum KeyToReplace {
        #[prost(message, tag = "1")]
        PublicKeyToReplace(super::PublicKey),
        #[prost(uint32, tag = "2")]
        SlotToReplace(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhitelistOperation {
    #[prost(message, optional, tag = "6")]
    pub metadata_for_key: ::core::option::Option<KeyMetadata>,
    #[prost(
        oneof = "whitelist_operation::SubMessage",
        tags = "1, 2, 3, 4, 5, 7, 8, 9, 16, 17"
    )]
    pub sub_message: ::core::option::Option<whitelist_operation::SubMessage>,
}
/// Nested message and enum types in `WhitelistOperation`.
pub mod whitelist_operation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubMessage {
        #[prost(message, tag = "1")]
        AddPublicKeyToWhitelist(super::PublicKey),
        #[prost(message, tag = "2")]
        RemovePublicKeyFromWhitelist(super::PublicKey),
        #[prost(message, tag = "3")]
        AddPermissionsToPublicKey(super::PermissionChange),
        #[prost(message, tag = "4")]
        RemovePermissionsFromPublicKey(super::PermissionChange),
        #[prost(message, tag = "5")]
        AddKeyToWhitelistAndAddPermissions(super::PermissionChange),
        #[prost(message, tag = "7")]
        UpdateKeyAndPermissions(super::PermissionChange),
        #[prost(message, tag = "8")]
        AddImpermanentKey(super::PermissionChange),
        #[prost(message, tag = "9")]
        AddImpermanentKeyAndRemoveExisting(super::PermissionChange),
        #[prost(bool, tag = "16")]
        RemoveAllImpermanentKeys(bool),
        #[prost(message, tag = "17")]
        ReplaceKey(super::ReplaceKey),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WhitelistOperationStatus {
    #[prost(enumeration = "WhitelistOperationInformationE", tag = "1")]
    pub whitelist_operation_information: i32,
    #[prost(message, optional, tag = "2")]
    pub signer_of_operation: ::core::option::Option<KeyIdentifier>,
    #[prost(enumeration = "OperationStatusE", tag = "3")]
    pub operation_status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedMessageStatus {
    #[prost(uint32, tag = "1")]
    pub counter: u32,
    #[prost(enumeration = "SignedMessageInformationE", tag = "2")]
    pub signed_message_information: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandStatus {
    #[prost(enumeration = "OperationStatusE", tag = "1")]
    pub operation_status: i32,
    #[prost(oneof = "command_status::SubMessage", tags = "2, 3")]
    pub sub_message: ::core::option::Option<command_status::SubMessage>,
}
/// Nested message and enum types in `CommandStatus`.
pub mod command_status {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubMessage {
        #[prost(message, tag = "2")]
        SignedMessageStatus(super::SignedMessageStatus),
        #[prost(message, tag = "3")]
        WhitelistOperationStatus(super::WhitelistOperationStatus),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsignedMessage {
    #[prost(oneof = "unsigned_message::SubMessage", tags = "1, 2, 4, 16")]
    pub sub_message: ::core::option::Option<unsigned_message::SubMessage>,
}
/// Nested message and enum types in `UnsignedMessage`.
pub mod unsigned_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubMessage {
        #[prost(message, tag = "1")]
        InformationRequest(super::InformationRequest),
        #[prost(enumeration = "super::RkeActionE", tag = "2")]
        RkeAction(i32),
        #[prost(message, tag = "4")]
        ClosureMoveRequest(super::ClosureMoveRequest),
        #[prost(message, tag = "16")]
        WhitelistOperation(super::WhitelistOperation),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClosureStatuses {
    #[prost(enumeration = "ClosureStateE", tag = "1")]
    pub front_driver_door: i32,
    #[prost(enumeration = "ClosureStateE", tag = "2")]
    pub front_passenger_door: i32,
    #[prost(enumeration = "ClosureStateE", tag = "3")]
    pub rear_driver_door: i32,
    #[prost(enumeration = "ClosureStateE", tag = "4")]
    pub rear_passenger_door: i32,
    #[prost(enumeration = "ClosureStateE", tag = "5")]
    pub rear_trunk: i32,
    #[prost(enumeration = "ClosureStateE", tag = "6")]
    pub front_trunk: i32,
    #[prost(enumeration = "ClosureStateE", tag = "7")]
    pub charge_port: i32,
    #[prost(enumeration = "ClosureStateE", tag = "8")]
    pub tonneau: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetailedClosureStatus {
    #[prost(uint32, tag = "1")]
    pub tonneau_percent_open: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VehicleStatus {
    #[prost(message, optional, tag = "1")]
    pub closure_statuses: ::core::option::Option<ClosureStatuses>,
    #[prost(enumeration = "VehicleLockStateE", tag = "2")]
    pub vehicle_lock_state: i32,
    #[prost(enumeration = "VehicleSleepStatusE", tag = "3")]
    pub vehicle_sleep_status: i32,
    #[prost(enumeration = "UserPresenceE", tag = "4")]
    pub user_presence: i32,
    #[prost(message, optional, tag = "5")]
    pub detailed_closure_status: ::core::option::Option<DetailedClosureStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FromVcsecMessage {
    #[prost(oneof = "from_vcsec_message::SubMessage", tags = "1, 4, 16, 17, 46")]
    pub sub_message: ::core::option::Option<from_vcsec_message::SubMessage>,
}
/// Nested message and enum types in `FromVCSECMessage`.
pub mod from_vcsec_message {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubMessage {
        #[prost(message, tag = "1")]
        VehicleStatus(super::VehicleStatus),
        #[prost(message, tag = "4")]
        CommandStatus(super::CommandStatus),
        #[prost(message, tag = "16")]
        WhitelistInfo(super::WhitelistInfo),
        #[prost(message, tag = "17")]
        WhitelistEntryInfo(super::WhitelistEntryInfo),
        #[prost(message, tag = "46")]
        NominalError(super::super::errors::NominalError),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignatureType {
    None = 0,
    PresentKey = 2,
}
impl SignatureType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SignatureType::None => "SIGNATURE_TYPE_NONE",
            SignatureType::PresentKey => "SIGNATURE_TYPE_PRESENT_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNATURE_TYPE_NONE" => Some(Self::None),
            "SIGNATURE_TYPE_PRESENT_KEY" => Some(Self::PresentKey),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyFormFactor {
    Unknown = 0,
    NfcCard = 1,
    IosDevice = 6,
    AndroidDevice = 7,
    CloudKey = 9,
}
impl KeyFormFactor {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            KeyFormFactor::Unknown => "KEY_FORM_FACTOR_UNKNOWN",
            KeyFormFactor::NfcCard => "KEY_FORM_FACTOR_NFC_CARD",
            KeyFormFactor::IosDevice => "KEY_FORM_FACTOR_IOS_DEVICE",
            KeyFormFactor::AndroidDevice => "KEY_FORM_FACTOR_ANDROID_DEVICE",
            KeyFormFactor::CloudKey => "KEY_FORM_FACTOR_CLOUD_KEY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_FORM_FACTOR_UNKNOWN" => Some(Self::Unknown),
            "KEY_FORM_FACTOR_NFC_CARD" => Some(Self::NfcCard),
            "KEY_FORM_FACTOR_IOS_DEVICE" => Some(Self::IosDevice),
            "KEY_FORM_FACTOR_ANDROID_DEVICE" => Some(Self::AndroidDevice),
            "KEY_FORM_FACTOR_CLOUD_KEY" => Some(Self::CloudKey),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InformationRequestType {
    GetStatus = 0,
    GetWhitelistInfo = 5,
    GetWhitelistEntryInfo = 6,
}
impl InformationRequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InformationRequestType::GetStatus => "INFORMATION_REQUEST_TYPE_GET_STATUS",
            InformationRequestType::GetWhitelistInfo => {
                "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO"
            }
            InformationRequestType::GetWhitelistEntryInfo => {
                "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFORMATION_REQUEST_TYPE_GET_STATUS" => Some(Self::GetStatus),
            "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO" => Some(Self::GetWhitelistInfo),
            "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO" => {
                Some(Self::GetWhitelistEntryInfo)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RkeActionE {
    RkeActionUnlock = 0,
    RkeActionLock = 1,
    RkeActionRemoteDrive = 20,
    RkeActionAutoSecureVehicle = 29,
    RkeActionWakeVehicle = 30,
}
impl RkeActionE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RkeActionE::RkeActionUnlock => "RKE_ACTION_UNLOCK",
            RkeActionE::RkeActionLock => "RKE_ACTION_LOCK",
            RkeActionE::RkeActionRemoteDrive => "RKE_ACTION_REMOTE_DRIVE",
            RkeActionE::RkeActionAutoSecureVehicle => "RKE_ACTION_AUTO_SECURE_VEHICLE",
            RkeActionE::RkeActionWakeVehicle => "RKE_ACTION_WAKE_VEHICLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RKE_ACTION_UNLOCK" => Some(Self::RkeActionUnlock),
            "RKE_ACTION_LOCK" => Some(Self::RkeActionLock),
            "RKE_ACTION_REMOTE_DRIVE" => Some(Self::RkeActionRemoteDrive),
            "RKE_ACTION_AUTO_SECURE_VEHICLE" => Some(Self::RkeActionAutoSecureVehicle),
            "RKE_ACTION_WAKE_VEHICLE" => Some(Self::RkeActionWakeVehicle),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClosureMoveTypeE {
    ClosureMoveTypeNone = 0,
    ClosureMoveTypeMove = 1,
    ClosureMoveTypeStop = 2,
    ClosureMoveTypeOpen = 3,
    ClosureMoveTypeClose = 4,
}
impl ClosureMoveTypeE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClosureMoveTypeE::ClosureMoveTypeNone => "CLOSURE_MOVE_TYPE_NONE",
            ClosureMoveTypeE::ClosureMoveTypeMove => "CLOSURE_MOVE_TYPE_MOVE",
            ClosureMoveTypeE::ClosureMoveTypeStop => "CLOSURE_MOVE_TYPE_STOP",
            ClosureMoveTypeE::ClosureMoveTypeOpen => "CLOSURE_MOVE_TYPE_OPEN",
            ClosureMoveTypeE::ClosureMoveTypeClose => "CLOSURE_MOVE_TYPE_CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOSURE_MOVE_TYPE_NONE" => Some(Self::ClosureMoveTypeNone),
            "CLOSURE_MOVE_TYPE_MOVE" => Some(Self::ClosureMoveTypeMove),
            "CLOSURE_MOVE_TYPE_STOP" => Some(Self::ClosureMoveTypeStop),
            "CLOSURE_MOVE_TYPE_OPEN" => Some(Self::ClosureMoveTypeOpen),
            "CLOSURE_MOVE_TYPE_CLOSE" => Some(Self::ClosureMoveTypeClose),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationStatusE {
    OperationstatusOk = 0,
    OperationstatusWait = 1,
    OperationstatusError = 2,
}
impl OperationStatusE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OperationStatusE::OperationstatusOk => "OPERATIONSTATUS_OK",
            OperationStatusE::OperationstatusWait => "OPERATIONSTATUS_WAIT",
            OperationStatusE::OperationstatusError => "OPERATIONSTATUS_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATIONSTATUS_OK" => Some(Self::OperationstatusOk),
            "OPERATIONSTATUS_WAIT" => Some(Self::OperationstatusWait),
            "OPERATIONSTATUS_ERROR" => Some(Self::OperationstatusError),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignedMessageInformationE {
    SignedmessageInformationNone = 0,
    SignedmessageInformationFaultUnknown = 1,
    SignedmessageInformationFaultNotOnWhitelist = 2,
    SignedmessageInformationFaultIvSmallerThanExpected = 3,
    SignedmessageInformationFaultInvalidToken = 4,
    SignedmessageInformationFaultTokenAndCounterInvalid = 5,
    SignedmessageInformationFaultAesDecryptAuth = 6,
    SignedmessageInformationFaultEcdsaInput = 7,
    SignedmessageInformationFaultEcdsaSignature = 8,
    SignedmessageInformationFaultLocalEntityStart = 9,
    SignedmessageInformationFaultLocalEntityResult = 10,
    SignedmessageInformationFaultCouldNotRetrieveKey = 11,
    SignedmessageInformationFaultCouldNotRetrieveToken = 12,
    SignedmessageInformationFaultSignatureTooShort = 13,
    SignedmessageInformationFaultTokenIsIncorrectLength = 14,
    SignedmessageInformationFaultIncorrectEpoch = 15,
    SignedmessageInformationFaultIvIncorrectLength = 16,
    SignedmessageInformationFaultTimeExpired = 17,
    SignedmessageInformationFaultNotProvisionedWithIdentity = 18,
    SignedmessageInformationFaultCouldNotHashMetadata = 19,
}
impl SignedMessageInformationE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            SignedMessageInformationE::SignedmessageInformationNone => {
                "SIGNEDMESSAGE_INFORMATION_NONE"
            }
            SignedMessageInformationE::SignedmessageInformationFaultUnknown => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN"
            }
            SignedMessageInformationE::SignedmessageInformationFaultNotOnWhitelist => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST"
            }
            SignedMessageInformationE::SignedmessageInformationFaultIvSmallerThanExpected => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED"
            }
            SignedMessageInformationE::SignedmessageInformationFaultInvalidToken => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN"
            }
            SignedMessageInformationE::SignedmessageInformationFaultTokenAndCounterInvalid => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID"
            }
            SignedMessageInformationE::SignedmessageInformationFaultAesDecryptAuth => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH"
            }
            SignedMessageInformationE::SignedmessageInformationFaultEcdsaInput => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT"
            }
            SignedMessageInformationE::SignedmessageInformationFaultEcdsaSignature => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE"
            }
            SignedMessageInformationE::SignedmessageInformationFaultLocalEntityStart => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START"
            }
            SignedMessageInformationE::SignedmessageInformationFaultLocalEntityResult => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT"
            }
            SignedMessageInformationE::SignedmessageInformationFaultCouldNotRetrieveKey => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY"
            }
            SignedMessageInformationE::SignedmessageInformationFaultCouldNotRetrieveToken => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN"
            }
            SignedMessageInformationE::SignedmessageInformationFaultSignatureTooShort => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT"
            }
            SignedMessageInformationE::SignedmessageInformationFaultTokenIsIncorrectLength => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH"
            }
            SignedMessageInformationE::SignedmessageInformationFaultIncorrectEpoch => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH"
            }
            SignedMessageInformationE::SignedmessageInformationFaultIvIncorrectLength => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH"
            }
            SignedMessageInformationE::SignedmessageInformationFaultTimeExpired => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED"
            }
            SignedMessageInformationE::SignedmessageInformationFaultNotProvisionedWithIdentity => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY"
            }
            SignedMessageInformationE::SignedmessageInformationFaultCouldNotHashMetadata => {
                "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNEDMESSAGE_INFORMATION_NONE" => Some(Self::SignedmessageInformationNone),
            "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN" => {
                Some(Self::SignedmessageInformationFaultUnknown)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST" => {
                Some(Self::SignedmessageInformationFaultNotOnWhitelist)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED" => {
                Some(Self::SignedmessageInformationFaultIvSmallerThanExpected)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN" => {
                Some(Self::SignedmessageInformationFaultInvalidToken)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID" => {
                Some(Self::SignedmessageInformationFaultTokenAndCounterInvalid)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH" => {
                Some(Self::SignedmessageInformationFaultAesDecryptAuth)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT" => {
                Some(Self::SignedmessageInformationFaultEcdsaInput)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE" => {
                Some(Self::SignedmessageInformationFaultEcdsaSignature)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START" => {
                Some(Self::SignedmessageInformationFaultLocalEntityStart)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT" => {
                Some(Self::SignedmessageInformationFaultLocalEntityResult)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY" => {
                Some(Self::SignedmessageInformationFaultCouldNotRetrieveKey)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN" => {
                Some(Self::SignedmessageInformationFaultCouldNotRetrieveToken)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT" => {
                Some(Self::SignedmessageInformationFaultSignatureTooShort)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH" => {
                Some(Self::SignedmessageInformationFaultTokenIsIncorrectLength)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH" => {
                Some(Self::SignedmessageInformationFaultIncorrectEpoch)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH" => {
                Some(Self::SignedmessageInformationFaultIvIncorrectLength)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED" => {
                Some(Self::SignedmessageInformationFaultTimeExpired)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY" => {
                Some(Self::SignedmessageInformationFaultNotProvisionedWithIdentity)
            }
            "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA" => {
                Some(Self::SignedmessageInformationFaultCouldNotHashMetadata)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WhitelistOperationInformationE {
    WhitelistoperationInformationNone = 0,
    WhitelistoperationInformationUndocumentedError = 1,
    WhitelistoperationInformationNoPermissionToRemoveOneself = 2,
    WhitelistoperationInformationKeyfobSlotsFull = 3,
    WhitelistoperationInformationWhitelistFull = 4,
    WhitelistoperationInformationNoPermissionToAdd = 5,
    WhitelistoperationInformationInvalidPublicKey = 6,
    WhitelistoperationInformationNoPermissionToRemove = 7,
    WhitelistoperationInformationNoPermissionToChangePermissions = 8,
    WhitelistoperationInformationAttemptingToElevateOtherAboveOneself = 9,
    WhitelistoperationInformationAttemptingToDemoteSuperiorToOneself = 10,
    WhitelistoperationInformationAttemptingToRemoveOwnPermissions = 11,
    WhitelistoperationInformationPublicKeyNotOnWhitelist = 12,
    WhitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist = 13,
    WhitelistoperationInformationNotAllowedToAddUnlessOnReader = 14,
    WhitelistoperationInformationFmModifyingOutsideOfFMode = 15,
    WhitelistoperationInformationFmAttemptingToAddPermanentKey = 16,
    WhitelistoperationInformationFmAttemptingToRemovePermanentKey = 17,
    WhitelistoperationInformationKeychainWhileFsFull = 18,
    WhitelistoperationInformationAttemptingToAddKeyWithoutRole = 19,
    WhitelistoperationInformationAttemptingToAddKeyWithServiceRole = 20,
    WhitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech = 21,
    WhitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode = 22,
    WhitelistoperationInformationCouldNotStartLocalEntityAuth = 23,
    WhitelistoperationInformationLocalEntityAuthFailedUiDenied = 24,
    WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap = 25,
    WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck = 26,
    WhitelistoperationInformationLocalEntityAuthFailedValetMode = 27,
    WhitelistoperationInformationLocalEntityAuthFailedCancelled = 28,
}
impl WhitelistOperationInformationE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WhitelistOperationInformationE::WhitelistoperationInformationNone => {
                "WHITELISTOPERATION_INFORMATION_NONE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationUndocumentedError => {
                "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNoPermissionToRemoveOneself => {
                "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationKeyfobSlotsFull => {
                "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationWhitelistFull => {
                "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNoPermissionToAdd => {
                "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationInvalidPublicKey => {
                "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNoPermissionToRemove => {
                "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNoPermissionToChangePermissions => {
                "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToElevateOtherAboveOneself => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToDemoteSuperiorToOneself => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToRemoveOwnPermissions => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationPublicKeyNotOnWhitelist => {
                "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNotAllowedToAddUnlessOnReader => {
                "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationFmModifyingOutsideOfFMode => {
                "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationFmAttemptingToAddPermanentKey => {
                "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationFmAttemptingToRemovePermanentKey => {
                "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationKeychainWhileFsFull => {
                "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToAddKeyWithoutRole => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationAttemptingToAddKeyWithServiceRole => {
                "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech => {
                "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode => {
                "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationCouldNotStartLocalEntityAuth => {
                "WHITELISTOPERATION_INFORMATION_COULD_NOT_START_LOCAL_ENTITY_AUTH"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationLocalEntityAuthFailedUiDenied => {
                "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_UI_DENIED"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap => {
                "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_TAP"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck => {
                "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_UI_ACK"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationLocalEntityAuthFailedValetMode => {
                "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_VALET_MODE"
            }
            WhitelistOperationInformationE::WhitelistoperationInformationLocalEntityAuthFailedCancelled => {
                "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_CANCELLED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WHITELISTOPERATION_INFORMATION_NONE" => {
                Some(Self::WhitelistoperationInformationNone)
            }
            "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR" => {
                Some(Self::WhitelistoperationInformationUndocumentedError)
            }
            "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF" => {
                Some(Self::WhitelistoperationInformationNoPermissionToRemoveOneself)
            }
            "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL" => {
                Some(Self::WhitelistoperationInformationKeyfobSlotsFull)
            }
            "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL" => {
                Some(Self::WhitelistoperationInformationWhitelistFull)
            }
            "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD" => {
                Some(Self::WhitelistoperationInformationNoPermissionToAdd)
            }
            "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY" => {
                Some(Self::WhitelistoperationInformationInvalidPublicKey)
            }
            "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE" => {
                Some(Self::WhitelistoperationInformationNoPermissionToRemove)
            }
            "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS" => {
                Some(Self::WhitelistoperationInformationNoPermissionToChangePermissions)
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF" => {
                Some(
                    Self::WhitelistoperationInformationAttemptingToElevateOtherAboveOneself,
                )
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF" => {
                Some(
                    Self::WhitelistoperationInformationAttemptingToDemoteSuperiorToOneself,
                )
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS" => {
                Some(Self::WhitelistoperationInformationAttemptingToRemoveOwnPermissions)
            }
            "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST" => {
                Some(Self::WhitelistoperationInformationPublicKeyNotOnWhitelist)
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST" => {
                Some(
                    Self::WhitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist,
                )
            }
            "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER" => {
                Some(Self::WhitelistoperationInformationNotAllowedToAddUnlessOnReader)
            }
            "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE" => {
                Some(Self::WhitelistoperationInformationFmModifyingOutsideOfFMode)
            }
            "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY" => {
                Some(Self::WhitelistoperationInformationFmAttemptingToAddPermanentKey)
            }
            "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY" => {
                Some(Self::WhitelistoperationInformationFmAttemptingToRemovePermanentKey)
            }
            "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL" => {
                Some(Self::WhitelistoperationInformationKeychainWhileFsFull)
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE" => {
                Some(Self::WhitelistoperationInformationAttemptingToAddKeyWithoutRole)
            }
            "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE" => {
                Some(
                    Self::WhitelistoperationInformationAttemptingToAddKeyWithServiceRole,
                )
            }
            "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH" => {
                Some(
                    Self::WhitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech,
                )
            }
            "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE" => {
                Some(
                    Self::WhitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode,
                )
            }
            "WHITELISTOPERATION_INFORMATION_COULD_NOT_START_LOCAL_ENTITY_AUTH" => {
                Some(Self::WhitelistoperationInformationCouldNotStartLocalEntityAuth)
            }
            "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_UI_DENIED" => {
                Some(Self::WhitelistoperationInformationLocalEntityAuthFailedUiDenied)
            }
            "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_TAP" => {
                Some(
                    Self::WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap,
                )
            }
            "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_UI_ACK" => {
                Some(
                    Self::WhitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck,
                )
            }
            "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_VALET_MODE" => {
                Some(Self::WhitelistoperationInformationLocalEntityAuthFailedValetMode)
            }
            "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_CANCELLED" => {
                Some(Self::WhitelistoperationInformationLocalEntityAuthFailedCancelled)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClosureStateE {
    ClosurestateClosed = 0,
    ClosurestateOpen = 1,
    ClosurestateAjar = 2,
    ClosurestateUnknown = 3,
    ClosurestateFailedUnlatch = 4,
    ClosurestateOpening = 5,
    ClosurestateClosing = 6,
}
impl ClosureStateE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ClosureStateE::ClosurestateClosed => "CLOSURESTATE_CLOSED",
            ClosureStateE::ClosurestateOpen => "CLOSURESTATE_OPEN",
            ClosureStateE::ClosurestateAjar => "CLOSURESTATE_AJAR",
            ClosureStateE::ClosurestateUnknown => "CLOSURESTATE_UNKNOWN",
            ClosureStateE::ClosurestateFailedUnlatch => "CLOSURESTATE_FAILED_UNLATCH",
            ClosureStateE::ClosurestateOpening => "CLOSURESTATE_OPENING",
            ClosureStateE::ClosurestateClosing => "CLOSURESTATE_CLOSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOSURESTATE_CLOSED" => Some(Self::ClosurestateClosed),
            "CLOSURESTATE_OPEN" => Some(Self::ClosurestateOpen),
            "CLOSURESTATE_AJAR" => Some(Self::ClosurestateAjar),
            "CLOSURESTATE_UNKNOWN" => Some(Self::ClosurestateUnknown),
            "CLOSURESTATE_FAILED_UNLATCH" => Some(Self::ClosurestateFailedUnlatch),
            "CLOSURESTATE_OPENING" => Some(Self::ClosurestateOpening),
            "CLOSURESTATE_CLOSING" => Some(Self::ClosurestateClosing),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VehicleLockStateE {
    VehiclelockstateUnlocked = 0,
    VehiclelockstateLocked = 1,
    VehiclelockstateInternalLocked = 2,
    VehiclelockstateSelectiveUnlocked = 3,
}
impl VehicleLockStateE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VehicleLockStateE::VehiclelockstateUnlocked => "VEHICLELOCKSTATE_UNLOCKED",
            VehicleLockStateE::VehiclelockstateLocked => "VEHICLELOCKSTATE_LOCKED",
            VehicleLockStateE::VehiclelockstateInternalLocked => {
                "VEHICLELOCKSTATE_INTERNAL_LOCKED"
            }
            VehicleLockStateE::VehiclelockstateSelectiveUnlocked => {
                "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VEHICLELOCKSTATE_UNLOCKED" => Some(Self::VehiclelockstateUnlocked),
            "VEHICLELOCKSTATE_LOCKED" => Some(Self::VehiclelockstateLocked),
            "VEHICLELOCKSTATE_INTERNAL_LOCKED" => {
                Some(Self::VehiclelockstateInternalLocked)
            }
            "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED" => {
                Some(Self::VehiclelockstateSelectiveUnlocked)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VehicleSleepStatusE {
    VehicleSleepStatusUnknown = 0,
    VehicleSleepStatusAwake = 1,
    VehicleSleepStatusAsleep = 2,
}
impl VehicleSleepStatusE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VehicleSleepStatusE::VehicleSleepStatusUnknown => {
                "VEHICLE_SLEEP_STATUS_UNKNOWN"
            }
            VehicleSleepStatusE::VehicleSleepStatusAwake => "VEHICLE_SLEEP_STATUS_AWAKE",
            VehicleSleepStatusE::VehicleSleepStatusAsleep => {
                "VEHICLE_SLEEP_STATUS_ASLEEP"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VEHICLE_SLEEP_STATUS_UNKNOWN" => Some(Self::VehicleSleepStatusUnknown),
            "VEHICLE_SLEEP_STATUS_AWAKE" => Some(Self::VehicleSleepStatusAwake),
            "VEHICLE_SLEEP_STATUS_ASLEEP" => Some(Self::VehicleSleepStatusAsleep),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserPresenceE {
    VehicleUserPresenceUnknown = 0,
    VehicleUserPresenceNotPresent = 1,
    VehicleUserPresencePresent = 2,
}
impl UserPresenceE {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UserPresenceE::VehicleUserPresenceUnknown => "VEHICLE_USER_PRESENCE_UNKNOWN",
            UserPresenceE::VehicleUserPresenceNotPresent => {
                "VEHICLE_USER_PRESENCE_NOT_PRESENT"
            }
            UserPresenceE::VehicleUserPresencePresent => "VEHICLE_USER_PRESENCE_PRESENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VEHICLE_USER_PRESENCE_UNKNOWN" => Some(Self::VehicleUserPresenceUnknown),
            "VEHICLE_USER_PRESENCE_NOT_PRESENT" => {
                Some(Self::VehicleUserPresenceNotPresent)
            }
            "VEHICLE_USER_PRESENCE_PRESENT" => Some(Self::VehicleUserPresencePresent),
            _ => None,
        }
    }
}
