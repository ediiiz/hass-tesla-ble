Directory structure:
└── yoziru-esphome-tesla-ble/
    ├── README.md
    ├── Dockerfile
    ├── LICENSE
    ├── Makefile
    ├── Makefile.common
    ├── requirements.txt
    ├── secrets.yaml.example
    ├── tesla-ble-esp32-generic.dashboard.yml
    ├── tesla-ble-esp32-generic.yml
    ├── tesla-ble-m5stack-atoms3.dashboard.yml
    ├── tesla-ble-m5stack-atoms3.yml
    ├── tesla-ble-m5stack-nanoc6.dashboard.yml
    ├── tesla-ble-m5stack-nanoc6.yml
    ├── tesla-ble.example.yml
    ├── .dockerignore
    ├── boards/
    │   ├── esp32-generic.yml
    │   ├── m5stack-atoms3.yml
    │   └── m5stack-nanoc6.yml
    ├── components/
    │   ├── tesla_ble_listener/
    │   │   ├── __init__.py
    │   │   ├── tesla_ble_listener.cpp
    │   │   └── tesla_ble_listener.h
    │   └── tesla_ble_vehicle/
    │       ├── __init__.py
    │       ├── ble_manager.cpp
    │       ├── ble_manager.h
    │       ├── command_builder.h
    │       ├── command_manager.cpp
    │       ├── command_manager.h
    │       ├── common.h
    │       ├── log.cpp
    │       ├── log.h
    │       ├── message_handler.cpp
    │       ├── message_handler.h
    │       ├── polling_manager.cpp
    │       ├── polling_manager.h
    │       ├── session_manager.cpp
    │       ├── session_manager.h
    │       ├── tesla_ble_vehicle.cpp
    │       ├── tesla_ble_vehicle.h
    │       ├── vehicle_state_manager.cpp
    │       └── vehicle_state_manager.h
    ├── packages/
    │   ├── base.yml
    │   ├── board.yml
    │   ├── client.yml
    │   ├── common.yml
    │   ├── external_components.dashboard.yml
    │   ├── external_components.yml
    │   ├── listener.yml
    │   └── project.yml
    ├── static/
    │   ├── _config.yml
    │   └── index.md
    └── .github/
        ├── dependabot.yml
        ├── FUNDING.yml
        └── workflows/
            └── ci.yml

================================================
FILE: README.md
================================================
# ESPHome Tesla BLE

This project lets you use an ESP32 device to manage charging a Tesla vehicle over BLE, using the [yoziru/tesla-ble](http://github.com/yoziru/tesla-ble) library.
Tested with M5Stack NanoC6 and Tesla firmwares 2024.26.3.1.

| Controls | Sensors | Diagnostic |
| - | - | - |
| <img src="./docs/ha-controls.png"> | <img src="./docs/ha-sensors.png"> | <img src="./docs/ha-diagnostic.png"> |


## Features
- [x] Pair BLE key with vehicle
- [x] Wake up vehicle
  - [ ] Use [Charging Manager](https://github.com/teslamotors/vehicle-command/blob/main/pkg/protocol/protocol.md#roles) role (wake command [not yet supported](https://github.com/teslamotors/vehicle-command/issues/232#issuecomment-2181503570) as of 2024.26.3.1)
- [x] Set charging amps
- [x] Set charging limit (percent)
- [x] Turn on/off charging
- [x] BLE information sensors
  - [x] Asleep / awake
  - [x] Doors locked / unlocked
  - [x] User present / not present
  - [x] Charging flap open / closed (only when vehicle is awake)
  - [x] BLE signal strength
  - [x] IEC 61851 state (A/B/C/D/E/F)

## Configuration

### Polling Intervals

The component supports configurable polling intervals to balance responsiveness and battery life:

```yaml
tesla_ble_vehicle:
  # ... other configuration ...
  
  # Polling intervals (in seconds)
  vcsec_poll_interval: 10                      # Vehicle status polling (default: 10s, range: 5-300s)
  infotainment_poll_interval_awake: 30         # Data polling when awake (default: 30s, range: 10-600s)
  infotainment_poll_interval_active: 10        # Data polling when active (default: 10s, range: 5-120s)
  infotainment_sleep_timeout: 660              # Wake window duration (default: 11min, range: 1-60min)
```

**Polling Types:**
- **VCSEC**: Basic vehicle status (sleep/awake, locked/unlocked, user presence) - safe to poll when asleep
- **Infotainment Awake**: Detailed data (battery, charging state) when awake but not active
- **Infotainment Active**: Frequent updates when charging, unlocked, or user present


**IEC 61851 text sensor**

The component exposes a text sensor that maps Tesla infotainment charge states to IEC 61851 states:

- A: Standby (EVSE ready, vehicle not connected) — `Disconnected`
- B: Vehicle detected (connected, not charging) — `Complete`, `Stopped`
- C: Charging (energy flowing / charging sequence) — `Starting`, `Charging`, `Calibrating`
- D: Ventilation required — not exposed via infotainment; treated as C when charging
- E: No power (connected but no power available) — `NoPower`
- F: Error / Unknown — `Unknown` or fallback

This sensor appears as `IEC 61851` in Home Assistant and updates alongside the Tesla charging state.


**Smart Wake Management:**
The system respects Tesla's sleep behavior by polling infotainment data only during an 11-minute wake window, then allowing the vehicle to sleep. Active states (charging/unlocked/user present) override this timeout for continuous monitoring.

## Usage

> For ESPHome dashboard, see [`tesla-ble-example.yml`](./tesla-ble.example.yml)

### Pre-requisites
- Python 3.10+
- GNU Make

### Finding the BLE MAC address of your vehicle

1. Copy and rename `secrets.yaml.example` to `secrets.yaml` and update it with your WiFi credentials (`wifi_ssid` and `wifi_password`) and vehicle VIN (`tesla_vin`).
1. Enable the `tesla_ble_listener` package in `packages/base.yml` by uncommenting the `listener: !include listener.yml` line.
1. Build and flash the firmware to your ESP32 device. See the 'Building and flashing ESP32 firmware' section below.
1. Open the ESPHome logs in Home Assistant and wake it up. Watch for the "Found Tesla vehicle" message, which will contain the BLE MAC address of your vehicle.
    > Note: The vehicle must be in range and awake for the BLE MAC address to be discovered. If the vehicle is not awake, open the Tesla app and run any command
    ```log
    [00:00:00][D][tesla_ble_listener:044]: Parsing device: [CC:BB:D1:E2:34:F0]: BLE Device name 1
    [00:00:00][D][tesla_ble_listener:044]: Parsing device: [19:8A:BB:C3:D2:1F]: 
    [00:00:00][D][tesla_ble_listener:044]: Parsing device: [19:8A:BB:C3:D2:1F]:
    [00:00:00][D][tesla_ble_listener:044]: Parsing device: [F5:4E:3D:C2:1B:A0]: BLE Device name 2
    [00:00:00][D][tesla_ble_listener:044]: Parsing device: [A0:B1:C2:D3:E4:F5]: S1a87a5a75f3df858C
    [00:00:00][I][tesla_ble_listener:054]: Found Tesla vehicle | Name: S1a87a5a75f3df858C | MAC: A0:B1:C2:D3:E4:F5
    ```
1. Clean up your environment before the next step by disabling the `tesla_ble_listener` package in `packages/base.yml` and running
    ```sh
    make clean
    ```

### Building firmware using ESPHome dashboard

If you are already running an instance of ESPHome, you can also include this repository directly by including it as a package. The main benefit here is having centralized management of all your ESPhome devices. To do this, you can use the following config for your device:
```
substitutions:
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  wifi_hotspot_password: !secret wifi_hotspot_password
  ota_password: !secret ota_password
  api_encryption_key: !secret api_encryption_key
  ble_mac_address: !secret ble_mac_address
  tesla_vin: !secret tesla_vin

packages:
  remote_package_shorthand: github://yoziru/esphome-tesla-ble/tesla-ble-m5stack-nanoc6.dashboard.yml@main
```

Be sure to use the correct `.dashboard.yml` file for your board. Also make sure you have the secrets defined otherwise it will not work and use defaults from this repository.

### Building and flashing ESP32 firmware
1. Connect your ESP32 device to your computer via USB
1. Copy and rename `secrets.yaml.example` to `secrets.yaml` and update it with your WiFi credentials (`wifi_ssid` and `wifi_password`) and vehicle details (`ble_mac_address` and `tesla_vin`)
1. Build the image with [ESPHome](https://esphome.io/guides/getting_started_command_line.html). Alternate boards are listed in the `boards/` directory.

    ```sh
    make compile BOARD=m5stack-nanoc6
    ```

1. Upload/flash the firmware to the board.

    ```sh
    make upload BOARD=m5stack-nanoc6
    ```

1. After flashing, you can use the log command to monitor the logs from the device. The host suffix is the last part of the device name in the ESPHome dashboard (e.g. `5b2ac7`).
    ```sh
    make logs HOST_SUFFIX=-5b2ac7
    ```

1. For updating your device, you can OTA update over local WiFi using the same host suffix:
    ```sh
    make upload HOST_SUFFIX=-5b2ac7
    ```

> Note: the make commands are just a wrapper around the `esphome` command. You can also use the `esphome` commands directly if you prefer (e.g. `esphome compile tesla-ble-m5stack-nanoc6.yml`)

### Adding the device to Home Assistant

1. In Home Assistant, go to Settings > Devices & Services. If your device is discovered automatically, you can add it by clicking the "Configure" button by the discovered device. If not, click the "+ Add integration" button and select "ESPHome" as the integration and enter the IP address of your device.
2. Enter the API encryption key from the `secrets.yaml` file when prompted.
3. That's it! You should now see the device in Home Assistant and be able to control it.


### Pairing the BLE key with your vehicle
1. Make sure your ESP32 device is close to the car (check the "BLE Signal" sensor) and the BLE MAC address and VIN in `secrets.yaml` is correct.
1. Get into your vehicle
1. In Home Assistant, go to Settings > Devices & Services > ESPHome, choose your Tesla BLE device and click "Pair BLE key"
1. Tap your NFC card to your car's center console
1. A prompt will appear on the screen of your car asking if you want to pair the key
    > Note: if the popup does not appear, you may need to press "Pair BLE key" and tap your card again

    <img src="./docs/vehicle-pair-request.png" width="500">
1. Hit confirm on the screen
1. To verify the key was added, tap Controls > Locks, and you should see a new key named "Unknown device" in the list
1. [optional] Rename your key to "ESPHome BLE" to make it easier to identify
    <img src="./docs/vehicle-locks.png" width="500">



================================================
FILE: Dockerfile
================================================
FROM esphome/esphome

COPY . /app
# Compile
RUN esphome compile



================================================
FILE: LICENSE
================================================
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.


================================================
FILE: Makefile
================================================
# Project-specific configuration
PROJECT := tesla-ble
# Default board
BOARD := m5stack-nanoc6

include Makefile.common



================================================
FILE: Makefile.common
================================================
.DEFAULT_GOAL := help

# Makefile.common - Common ESPHome Makefile for single and multi-board projects
# Usage: In your project's Makefile, set PROJECT and optionally BOARD, then include this file.

PROJECT ?= default-project
BOARD ?=
TARGET ?= $(if $(BOARD),$(PROJECT)-$(BOARD).yml,$(PROJECT).yml)
BOARD_FILES ?= $(if $(BOARD),boards/$(BOARD).yml)
ESPHOME_VERSION ?= $(shell grep '^esphome==' requirements.txt | cut -d'=' -f3)

UV_CHECK = @command -v uv >/dev/null 2>&1 || { \
  echo "[ERROR] 'uv' is not installed. Please install it with:"; \
  echo "See https://docs.astral.sh/uv/getting-started/installation/ for help."; \
  exit 1; \
}

# Check if 'uv' is installed
check-uv:
	$(UV_CHECK)

# Compile the binary only if YAML sources or dependencies change
compile: .esphome/build/$(PROJECT)/.pioenvs/$(PROJECT)/firmware.bin  ## Read the configuration and compile the binary.

validate-config: check-uv ## Validate the configuration without building the binary
	uvx --with pip esphome==$(ESPHOME_VERSION) config $(TARGET)

# Build firmware.bin if YAML sources or dependencies change
.esphome/build/$(PROJECT)/.pioenvs/$(PROJECT)/firmware.bin: $(TARGET) packages/*.yml $(BOARD_FILES) components/**/*.* requirements.txt $(shell command -v uv 2>/dev/null)
	$(UV_CHECK)
	uvx --with pip esphome==$(ESPHOME_VERSION) compile $(TARGET)

upload: .esphome/build/$(PROJECT)/.pioenvs/$(PROJECT)/firmware.bin check-uv ## Validate the configuration, create a binary, upload it, and start logs.
	@suffix="$(HOST_SUFFIX)"; \
	if [ -z "$$suffix" ] && [ -f .selected_suffix ]; then \
		suffix=$$(cat .selected_suffix); \
	fi; \
	if [ -z "$$suffix" ]; then \
		uvx --with pip esphome==$(ESPHOME_VERSION) run $(TARGET); \
	else \
		uvx --with pip esphome==$(ESPHOME_VERSION) run $(TARGET) --device $(PROJECT)$$suffix; \
	fi

logs: check-uv ## Start logs.
	@suffix="$(HOST_SUFFIX)"; \
	if [ -z "$$suffix" ] && [ -f .selected_suffix ]; then \
		suffix=$$(cat .selected_suffix); \
	fi; \
	if [ -z "$$suffix" ]; then \
		uvx --with pip esphome==$(ESPHOME_VERSION) logs $(TARGET); \
	else \
		uvx --with pip esphome==$(ESPHOME_VERSION) logs $(TARGET) --device $(PROJECT)$$suffix; \
	fi

discover: ## Discover ESPHome devices on the network
	@PROJECT=$(PROJECT) bash -c ' \
	echo "Scanning network for ESPHome devices..."; \
	devices=($$(timeout 2 dns-sd -B _esphomelib._tcp local 2>/dev/null | grep "Add" | grep "$$PROJECT" | awk "{print \$$NF}" | sed "s/$$PROJECT-//" | sed "s/\.local//")); \
	if [ $${#devices[@]} -eq 0 ]; then \
		echo "No devices found (or dns-sd timed out)"; \
	else \
		selected=$${devices[0]}; \
		echo "Using device: $$PROJECT-$$selected"; \
		echo "-$$selected" > .selected_suffix; \
		if [ $${#devices[@]} -gt 1 ]; then \
			echo "Other devices found:"; \
			for i in $${!devices[@]}; do \
				if [ $$i -gt 0 ]; then \
					echo "  $$PROJECT-$${devices[i]}"; \
				fi; \
			done; \
		fi; \
	fi'

.PHONY: clean
clean: ## Remove the esphome build directory
	rm -rf .esphome .selected_suffix

.PHONY: help
help: ## Show help messages for make targets
	@grep -E '^[a-zA-Z0-9_./-]+:.*?## .*$$' $(MAKEFILE_LIST) \
		| sed 's/[^:]*://' \
		| sort \
		| awk 'BEGIN {FS = ":.*?## "}; {printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}'

compile_docker: $(TARGET) packages/*.yml $(BOARD_FILES) ## Compile the binary using docker
	docker run --rm -v $(PWD):/config ghcr.io/esphome/esphome:$(ESPHOME_VERSION) compile /config/$(TARGET)



================================================
FILE: requirements.txt
================================================
esphome==2025.12.2



================================================
FILE: secrets.yaml.example
================================================
wifi_ssid: "your-wifi-ssid"
wifi_password: "your-wifi-password"
wifi_hotspot_password: "12345678"
ota_password: ""
api_encryption_key: "Cg/+mx6ZdH2QBdrmrKtg/zmG0TK/IDHBBr3DUJDXKpo=" # random key from https://esphome.io/components/api.html#configuration-variables
ble_mac_address: "A0:B1:C2:D3:E4:F5"
tesla_vin: "5YJ30123456789ABC" # mock VIN example from PROTOCOL.md



================================================
FILE: tesla-ble-esp32-generic.dashboard.yml
================================================
<<: !include tesla-ble-esp32-generic.yml

# override external_components to use the dashboard version
external_components: !include packages/external_components.dashboard.yml



================================================
FILE: tesla-ble-esp32-generic.yml
================================================
external_components: !include packages/external_components.yml

packages:
  base: !include packages/base.yml
  device_base: !include boards/esp32-generic.yml
  client: !include packages/client.yml

dashboard_import:
  package_import_url: github://yoziru/esphome-tesla-ble/tesla-ble-esp32-generic.dashboard.yml



================================================
FILE: tesla-ble-m5stack-atoms3.dashboard.yml
================================================
<<: !include tesla-ble-m5stack-atoms3.yml

# override external_components to use the dashboard version
external_components: !include packages/external_components.dashboard.yml



================================================
FILE: tesla-ble-m5stack-atoms3.yml
================================================
external_components: !include packages/external_components.yml

packages:
  base: !include packages/base.yml
  device_base: !include boards/m5stack-atoms3.yml
  client: !include packages/client.yml
  # for ESPHome Dashboard, use this instead of external_components

dashboard_import:
  package_import_url: github://yoziru/esphome-tesla-ble/tesla-ble-m5stack-atoms3.dashboard.yml



================================================
FILE: tesla-ble-m5stack-nanoc6.dashboard.yml
================================================
<<: !include tesla-ble-m5stack-nanoc6.yml

# override external_components to use the dashboard version
external_components: !include packages/external_components.dashboard.yml



================================================
FILE: tesla-ble-m5stack-nanoc6.yml
================================================
external_components: !include packages/external_components.yml

packages:
  base: !include packages/base.yml
  device_base: !include boards/m5stack-nanoc6.yml
  client: !include packages/client.yml

dashboard_import:
  package_import_url: github://yoziru/esphome-tesla-ble/tesla-ble-m5stack-nanoc6.dashboard.yml



================================================
FILE: tesla-ble.example.yml
================================================
substitutions:
  # all substitutions for this project
  espidf_version: 5.3.0
  platformio_version: 6.8.1
  friendly_name: Tesla BLE
  device_name: tesla-ble
  device_description: Tesla BLE
  board: esp32dev
  variant: esp32
  flash_size: 4MB
  ble_mac_address: "A0:B1:C2:D3:E4:F5" # vehicle BLE MAC address
  tesla_vin: "5YJ30123456789ABC" # vehicle VIN
  charging_amps_max: "32"
  
  # Polling intervals (in seconds) - customize based on your needs
  # Lower values = more responsive but higher battery drain
  # Higher values = less battery drain but slower updates
  vcsec_poll_interval: "10"                    # Vehicle status (range: 5-300s, default: 10s)
  infotainment_poll_interval_awake: "30"       # Data when awake (range: 10-600s, default: 30s) 
  infotainment_poll_interval_active: "10"      # Data when active (range: 5-120s, default: 10s)
  infotainment_sleep_timeout: "660"            # Sleep timeout (range: 60-3600s, default: 11min)

external_components: !include packages/external_components.dashboard.yml

packages:
  base: !include packages/base.yml
  client: !include packages/client.yml
  common: !include packages/common.yml
  # for ESPHome Dashboard, use this instead of external_components

dashboard_import:
  package_import_url: github://yoziru/esphome-tesla-ble/tesla-ble.example.yml



================================================
FILE: .dockerignore
================================================
.git
.venv
.vscode
.esphome



================================================
FILE: boards/esp32-generic.yml
================================================
substitutions:
  board: esp32dev
  variant: esp32
  flash_size: 4MB



================================================
FILE: boards/m5stack-atoms3.yml
================================================
substitutions:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 8MB

# Board specific entities
# Output that blinks the LED
output:
  - platform: template
    id: status_output
    type: binary
    write_action:
      - if:
          condition:
            lambda: return (state);
          then:
            - light.turn_on:
                id: led
                brightness: 70%
                red: 100%
                green: 0%
                blue: 0%
          else:
            - light.turn_off: led

light:
  # Enable status LED
  - platform: status_led
    output: status_output
    name: "Status Led"
    entity_category: diagnostic

  #G35=RGB WS2812C-2020
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: 35
    num_leds: 4
    chipset: ws2812
    id: led
    name: "Led"
    entity_category: diagnostic

#G41=Button
binary_sensor:
  - platform: gpio
    name: Button
    entity_category: diagnostic
    pin:
      number: GPIO41
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_off: 10ms



================================================
FILE: boards/m5stack-nanoc6.yml
================================================
substitutions:
  board: esp32-c6-devkitm-1
  variant: esp32c6
  flash_size: 4MB

esp32:
  framework:
    sdkconfig_options:
      CONFIG_OPENTHREAD_ENABLED: n
      CONFIG_ENABLE_WIFI_STATION: y
      CONFIG_USE_MINIMAL_MDNS: y
      CONFIG_ESPTOOLPY_FLASHSIZE_4MB: y

# Board specific entities
light:
  - platform: status_led
    name: "Status LED"
    entity_category: diagnostic
    pin: GPIO7

  #G20=RGB WS2812
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO20
    num_leds: 4
    chipset: ws2812
    name: "RGB LED"
    entity_category: diagnostic
    power_supply: rgbpwr

power_supply:
  - id: "rgbpwr"
    enable_on_boot: true
    pin: GPIO19
    enable_time: 10ms
    keep_on_time: 10ms

#G9=Button
binary_sensor:
  - platform: gpio
    name: Button
    entity_category: diagnostic
    pin:
      number: GPIO9
      inverted: true
      mode:
        input: true
        pullup: true
    filters:
      - delayed_off: 10ms



================================================
FILE: components/tesla_ble_listener/__init__.py
================================================
import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.components import esp32_ble_tracker
from esphome.const import CONF_ID

CODEOWNERS = ["@yoziru"]
DEPENDENCIES = ["esp32_ble_tracker"]
CONF_VIN = "vin"

tesla_ble_listener_ns = cg.esphome_ns.namespace("tesla_ble_listener")
TeslaBLEListener = tesla_ble_listener_ns.class_(
    "TeslaBLEListener", esp32_ble_tracker.ESPBTDeviceListener
)

CONFIG_SCHEMA = cv.Schema(
    {
        cv.GenerateID(): cv.declare_id(TeslaBLEListener),
        cv.Required(CONF_VIN): cv.string,
    }
).extend(esp32_ble_tracker.ESP_BLE_DEVICE_SCHEMA)


def to_code(config):
    var = cg.new_Pvariable(config[CONF_ID])
    yield esp32_ble_tracker.register_ble_device(var, config)

    cg.add(var.set_vin(config[CONF_VIN]))



================================================
FILE: components/tesla_ble_listener/tesla_ble_listener.cpp
================================================
#include "tesla_ble_listener.h"
#include "esphome/core/log.h"
#include "mbedtls/sha1.h"
#include <string>
#include <cinttypes>

namespace esphome
{
  namespace tesla_ble_listener
  {
    static const char *const TAG = "tesla_ble_listener";

    std::string get_vin_advertisement_name(const char *vin)
    {
      // * BLE advertisement local name: `S + <ID> + C`, where `<ID>` is the
      //  lower-case hex-encoding of the first eight bytes of the SHA1 digest of the
      //  Vehicle Identification Number (VIN). For example, If the VIN is
      //  `5YJS0000000000000`, then the BLE advertisement Local Name is
      //  `S1a87a5a75f3df858C`.

      unsigned char vin_sha1[20];
      size_t vin_length = 17; // Assuming standard VIN length
      int return_code = mbedtls_sha1((const unsigned char *)vin, vin_length, vin_sha1);
      if (return_code != 0)
      {
        ESP_LOGE(TAG, "Failed to calculate SHA1 of VIN");
        return "";
      }

      char result[19]; // 'S' + 16 hex chars + 'C' + null terminator
      result[0] = 'S';
      for (int i = 0; i < 8; i++)
      {
        snprintf(&result[1 + i * 2], 3, "%02x", vin_sha1[i]);
      }
      result[17] = 'C';
      result[18] = '\0'; // Null terminator for safe printing

      std::string result_str(result);
      ESP_LOGD(TAG, "VIN advertisement name: %s", result_str.c_str());
      return result_str;
    }

    bool TeslaBLEListener::parse_device(const esp32_ble_tracker::ESPBTDevice &device)
    {
      ESP_LOGD(TAG, "Parsing device: [%s]: %s", device.address_str().c_str(), device.get_name().c_str());

      if (device.get_name() == this->vin_ad_name_)
      {
        ESP_LOGI(TAG, "Found Tesla vehicle | Name: %s | MAC: %s", device.get_name().c_str(), device.address_str().c_str());
        return true;
      }

      return false;
    }
  } // namespace tesla_ble_listener
} // namespace esphome



================================================
FILE: components/tesla_ble_listener/tesla_ble_listener.h
================================================
#pragma once

#include "esphome/core/component.h"
#include "esphome/components/esp32_ble_tracker/esp32_ble_tracker.h"

namespace esphome
{
  namespace tesla_ble_listener
  {

    std::string get_vin_advertisement_name(const char *vin);

    class TeslaBLEListener : public esp32_ble_tracker::ESPBTDeviceListener
    {
    public:
      std::string vin_ad_name_;

      bool parse_device(const esp32_ble_tracker::ESPBTDevice &device) override;
      void set_vin(const char *vin) { vin_ad_name_ = get_vin_advertisement_name(vin); }
    };

  } // namespace tesla_ble_listener
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/__init__.py
================================================
import esphome.codegen as cg
import esphome.config_validation as cv
from esphome.components import ble_client, binary_sensor, button, switch, number, sensor, text_sensor
from esphome.const import (
    CONF_DEVICE_CLASS,
    CONF_DISABLED_BY_DEFAULT,
    CONF_ENTITY_CATEGORY,
    CONF_FORCE_UPDATE,
    CONF_ICON,
    CONF_ID,
    CONF_MODE,
    CONF_NAME,
    CONF_RESTORE_MODE,
    CONF_UNIT_OF_MEASUREMENT,
)
from esphome import automation


CODEOWNERS = ["@yoziru"]
DEPENDENCIES = ["ble_client"]
AUTO_LOAD = ["binary_sensor", "button", "switch", "number", "sensor", "text_sensor"]

tesla_ble_vehicle_ns = cg.esphome_ns.namespace("tesla_ble_vehicle")
TeslaBLEVehicle = tesla_ble_vehicle_ns.class_(
    "TeslaBLEVehicle", cg.PollingComponent, ble_client.BLEClientNode
)

# Custom button classes
TeslaWakeButton = tesla_ble_vehicle_ns.class_("TeslaWakeButton", button.Button)
TeslaPairButton = tesla_ble_vehicle_ns.class_("TeslaPairButton", button.Button)
TeslaRegenerateKeyButton = tesla_ble_vehicle_ns.class_("TeslaRegenerateKeyButton", button.Button)
TeslaForceUpdateButton = tesla_ble_vehicle_ns.class_("TeslaForceUpdateButton", button.Button)
TeslaUnlockChargePortButton = tesla_ble_vehicle_ns.class_("TeslaUnlockChargePortButton", button.Button)

# Custom switch classes
TeslaChargingSwitch = tesla_ble_vehicle_ns.class_("TeslaChargingSwitch", switch.Switch)

# Custom number classes
TeslaChargingAmpsNumber = tesla_ble_vehicle_ns.class_("TeslaChargingAmpsNumber", number.Number)
TeslaChargingLimitNumber = tesla_ble_vehicle_ns.class_("TeslaChargingLimitNumber", number.Number)

# Actions
WakeAction = tesla_ble_vehicle_ns.class_("WakeAction", automation.Action)
PairAction = tesla_ble_vehicle_ns.class_("PairAction", automation.Action)
RegenerateKeyAction = tesla_ble_vehicle_ns.class_("RegenerateKeyAction", automation.Action)
ForceUpdateAction = tesla_ble_vehicle_ns.class_("ForceUpdateAction", automation.Action)
SetChargingAction = tesla_ble_vehicle_ns.class_("SetChargingAction", automation.Action)
SetChargingAmpsAction = tesla_ble_vehicle_ns.class_("SetChargingAmpsAction", automation.Action)
SetChargingLimitAction = tesla_ble_vehicle_ns.class_("SetChargingLimitAction", automation.Action)

# Configuration constants
CONF_VIN = "vin"
CONF_CHARGING_AMPS_MAX = "charging_amps_max"
CONF_ROLE = "role"

# Polling configuration constants
CONF_VCSEC_POLL_INTERVAL = "vcsec_poll_interval"
CONF_INFOTAINMENT_POLL_INTERVAL_AWAKE = "infotainment_poll_interval_awake" 
CONF_INFOTAINMENT_POLL_INTERVAL_ACTIVE = "infotainment_poll_interval_active"
CONF_INFOTAINMENT_SLEEP_TIMEOUT = "infotainment_sleep_timeout"

# Configuration constants - no need for custom classes since we use standard ESPHome components
CONF_SLEEP = "sleep"

# Tesla key roles
TESLA_ROLES = {
    "DRIVER": "Keys_Role_ROLE_DRIVER",
    "CHARGING_MANAGER": "Keys_Role_ROLE_CHARGING_MANAGER",
}

CONFIG_SCHEMA = (
    cv.Schema(
        {
            cv.GenerateID(CONF_ID): cv.declare_id(TeslaBLEVehicle),
            cv.Required(CONF_VIN): cv.string,
            cv.Optional(CONF_CHARGING_AMPS_MAX, default=32): cv.int_range(min=1, max=48),
            cv.Optional(CONF_ROLE, default="DRIVER"): cv.enum(TESLA_ROLES, upper=True),
            # Polling intervals (in seconds)
            cv.Optional(CONF_VCSEC_POLL_INTERVAL, default=10): cv.int_range(min=5, max=300),
            cv.Optional(CONF_INFOTAINMENT_POLL_INTERVAL_AWAKE, default=30): cv.int_range(min=10, max=600), 
            cv.Optional(CONF_INFOTAINMENT_POLL_INTERVAL_ACTIVE, default=10): cv.int_range(min=5, max=120),
            cv.Optional(CONF_INFOTAINMENT_SLEEP_TIMEOUT, default=660): cv.int_range(min=60, max=3600),  # 11 minutes default
        },
    )
    .extend(cv.polling_component_schema("10s"))  # Default matches VCSEC polling interval
    .extend(ble_client.BLE_CLIENT_SCHEMA)
)

async def to_code(config):
    var = cg.new_Pvariable(config[CONF_ID])
    await cg.register_component(var, config)
    await ble_client.register_ble_node(var, config)

    cg.add(var.set_vin(config[CONF_VIN]))
    
    role = config[CONF_ROLE]
    charging_amps_max = config[CONF_CHARGING_AMPS_MAX]
    vcsec_interval_seconds = config[CONF_VCSEC_POLL_INTERVAL]
    
    # Set the ESPHome update interval to match VCSEC polling interval
    cg.add(var.set_update_interval(vcsec_interval_seconds * 1000))  # Convert to milliseconds
    
    # Set role and charging configuration
    cg.add(var.set_role(TESLA_ROLES[role]))
    cg.add(var.set_charging_amps_max(charging_amps_max))
    
    # Set polling intervals (convert from seconds to milliseconds)
    vcsec_interval_ms = vcsec_interval_seconds * 1000
    infotainment_awake_ms = config[CONF_INFOTAINMENT_POLL_INTERVAL_AWAKE] * 1000
    infotainment_active_ms = config[CONF_INFOTAINMENT_POLL_INTERVAL_ACTIVE] * 1000
    infotainment_sleep_timeout_ms = config[CONF_INFOTAINMENT_SLEEP_TIMEOUT] * 1000
    
    cg.add(var.set_vcsec_poll_interval(vcsec_interval_ms))
    cg.add(var.set_infotainment_poll_interval_awake(infotainment_awake_ms))
    cg.add(var.set_infotainment_poll_interval_active(infotainment_active_ms))
    cg.add(var.set_infotainment_sleep_timeout(infotainment_sleep_timeout_ms))
    
    # Create built-in entities
    ## Binary sensors
    asleep_sensor = await binary_sensor.new_binary_sensor({
        CONF_ID: cv.declare_id(binary_sensor.BinarySensor)("tesla_asleep_sensor"),
        CONF_NAME: "Asleep",
        CONF_ICON: "mdi:sleep",
        CONF_DISABLED_BY_DEFAULT: False,
    })
    cg.add(var.set_binary_sensor_is_asleep(asleep_sensor))

    doors_sensor = await binary_sensor.new_binary_sensor({
        CONF_ID: cv.declare_id(binary_sensor.BinarySensor)("tesla_doors_sensor"),
        CONF_NAME: "Doors",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_DEVICE_CLASS: binary_sensor.DEVICE_CLASS_LOCK,
    })
    cg.add(var.set_binary_sensor_is_unlocked(doors_sensor))

    user_present_sensor = await binary_sensor.new_binary_sensor({
        CONF_ID: cv.declare_id(binary_sensor.BinarySensor)("tesla_user_present_sensor"),
        CONF_NAME: "User Present",
        CONF_ICON: "mdi:account-check",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_DEVICE_CLASS: binary_sensor.DEVICE_CLASS_OCCUPANCY,
    })
    cg.add(var.set_binary_sensor_is_user_present(user_present_sensor))

    charge_flap_sensor = await binary_sensor.new_binary_sensor({
        CONF_ID: cv.declare_id(binary_sensor.BinarySensor)("tesla_charge_flap_sensor"),
        CONF_NAME: "Charge Flap",
        CONF_ICON: "mdi:ev-plug-tesla",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_DEVICE_CLASS: binary_sensor.DEVICE_CLASS_DOOR,
    })
    cg.add(var.set_binary_sensor_is_charge_flap_open(charge_flap_sensor))

    charger_sensor = await binary_sensor.new_binary_sensor({
        CONF_ID: cv.declare_id(binary_sensor.BinarySensor)("tesla_charger_sensor"),
        CONF_NAME: "Charger",
        CONF_ICON: "mdi:power-plug",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_DEVICE_CLASS: binary_sensor.DEVICE_CLASS_PLUG,
    })
    cg.add(var.set_binary_sensor_is_charger_connected(charger_sensor))

    ## Sensors
    battery_level_sensor = await sensor.new_sensor({
        CONF_ID: cv.declare_id(sensor.Sensor)("tesla_battery_level_sensor"),
        CONF_NAME: "Battery",
        CONF_ICON: "mdi:battery",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
        CONF_UNIT_OF_MEASUREMENT: "%",
    })
    cg.add(var.set_battery_level_sensor(battery_level_sensor))

    charger_power_sensor = await sensor.new_sensor({
        CONF_ID: cv.declare_id(sensor.Sensor)("tesla_charger_power_sensor"),
        CONF_NAME: "Charger Power",
        CONF_ICON: "mdi:flash",
        CONF_DEVICE_CLASS: sensor.DEVICE_CLASS_POWER,
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
        CONF_UNIT_OF_MEASUREMENT: "W",
    })
    cg.add(var.set_charger_power_sensor(charger_power_sensor))

    charger_voltage_sensor = await sensor.new_sensor({
        CONF_ID: cv.declare_id(sensor.Sensor)("tesla_charger_voltage_sensor"),
        CONF_NAME: "Charger Voltage",
        CONF_ICON: "mdi:lightning-bolt",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
        CONF_UNIT_OF_MEASUREMENT: "V",
        CONF_DEVICE_CLASS: sensor.DEVICE_CLASS_VOLTAGE,
    })
    cg.add(var.set_charger_voltage_sensor(charger_voltage_sensor))

    charger_current_sensor = await sensor.new_sensor({
        CONF_ID: cv.declare_id(sensor.Sensor)("tesla_charger_current_sensor"),
        CONF_NAME: "Charger Current",
        CONF_ICON: "mdi:current-ac",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
        CONF_UNIT_OF_MEASUREMENT: "A",
        CONF_DEVICE_CLASS: sensor.DEVICE_CLASS_CURRENT,
    })
    cg.add(var.set_charger_current_sensor(charger_current_sensor))

    charging_rate_sensor = await sensor.new_sensor({
        CONF_ID: cv.declare_id(sensor.Sensor)("tesla_charging_rate_sensor"),
        CONF_NAME: "Charging Rate",
        CONF_ICON: "mdi:speedometer",
        CONF_DEVICE_CLASS: sensor.DEVICE_CLASS_SPEED,
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
        CONF_UNIT_OF_MEASUREMENT: "mph",
    })
    cg.add(var.set_charging_rate_sensor(charging_rate_sensor))

    ## Text sensors  
    charging_state_sensor = await text_sensor.new_text_sensor({
        CONF_ID: cv.declare_id(text_sensor.TextSensor)("tesla_charging_state_sensor"),
        CONF_NAME: "Charging",
        CONF_ICON: "mdi:ev-station",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
    })
    cg.add(var.set_charging_state_sensor(charging_state_sensor))

    iec61851_state_sensor = await text_sensor.new_text_sensor({
        CONF_ID: cv.declare_id(text_sensor.TextSensor)("tesla_iec61851_state_sensor"),
        CONF_NAME: "IEC 61851",
        CONF_ICON: "mdi:ev-plug-type2",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_FORCE_UPDATE: False,
    })
    cg.add(var.set_iec61851_state_sensor(iec61851_state_sensor))

    ## Buttons
    wake_button = await button.new_button({
        CONF_ID: cv.declare_id(TeslaWakeButton)("tesla_wake_button"),
        CONF_NAME: "Wake up",
        CONF_ICON: "mdi:sleep-off",
        CONF_DISABLED_BY_DEFAULT: False,
    })
    cg.add(wake_button.set_parent(var))
    cg.add(var.set_wake_button(wake_button))

    pair_button = await button.new_button({
        CONF_ID: cv.declare_id(TeslaPairButton)("tesla_pair_button"),
        CONF_NAME: "Pair BLE Key",
        CONF_ICON: "mdi:key-wireless",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_ENTITY_CATEGORY: cg.EntityCategory.ENTITY_CATEGORY_DIAGNOSTIC,
    })
    cg.add(pair_button.set_parent(var))
    cg.add(var.set_pair_button(pair_button))

    regenerate_key_button = await button.new_button({
        CONF_ID: cv.declare_id(TeslaRegenerateKeyButton)("tesla_regenerate_key_button"),
        CONF_NAME: "Regenerate key",
        CONF_ICON: "mdi:key-change",
        CONF_DISABLED_BY_DEFAULT: True,
        CONF_ENTITY_CATEGORY: cg.EntityCategory.ENTITY_CATEGORY_DIAGNOSTIC,
    })
    cg.add(regenerate_key_button.set_parent(var))
    cg.add(var.set_regenerate_key_button(regenerate_key_button))

    force_update_button = await button.new_button({
        CONF_ID: cv.declare_id(TeslaForceUpdateButton)("tesla_force_update_button"),
        CONF_NAME: "Force data update",
        CONF_ICON: "mdi:database-sync",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_ENTITY_CATEGORY: cg.EntityCategory.ENTITY_CATEGORY_DIAGNOSTIC,
    })
    cg.add(force_update_button.set_parent(var))
    cg.add(var.set_force_update_button(force_update_button))

    unlock_charge_port_button = await button.new_button({
        CONF_ID: cv.declare_id(TeslaUnlockChargePortButton)("tesla_unlock_charge_port_button"),
        CONF_NAME: "Unlock Charge Port",
        CONF_ICON: "mdi:ev-plug-tesla",
        CONF_DISABLED_BY_DEFAULT: False,
    })
    cg.add(unlock_charge_port_button.set_parent(var))
    # No dedicated setter needed; parent method is called by button press

    ## Switches
    charger_switch = await switch.new_switch({
        CONF_ID: cv.declare_id(TeslaChargingSwitch)("tesla_charger_switch"),
        CONF_NAME: "Charging",
        CONF_ICON: "mdi:ev-station",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_RESTORE_MODE: switch.RESTORE_MODES['RESTORE_DEFAULT_OFF'],
        # CONF_OPTIMISTIC: False,
        # CONF_RESTORE_VALUE: False,
    })
    cg.add(charger_switch.set_parent(var))
    cg.add(var.set_charging_switch(charger_switch))

    ## Numbers
    charging_amps_number = await number.new_number({
        CONF_ID: cv.declare_id(TeslaChargingAmpsNumber)("tesla_charging_amps_number"),
        CONF_NAME: "Charging Amps",
        CONF_ICON: "mdi:current-ac",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_MODE: number.NUMBER_MODES['AUTO'],
        # CONF_OPTIMISTIC: False,
        # CONF_RESTORE_VALUE: False,
        CONF_UNIT_OF_MEASUREMENT: "A",
    }, min_value=0, max_value=charging_amps_max, step=1)
    cg.add(charging_amps_number.set_parent(var))
    cg.add(var.set_charging_amps_number(charging_amps_number))

    charging_limit_number = await number.new_number({
        CONF_ID: cv.declare_id(TeslaChargingLimitNumber)("tesla_charging_limit_number"),
        CONF_NAME: "Charging Limit",
        CONF_ICON: "mdi:battery-charging-100",
        CONF_DISABLED_BY_DEFAULT: False,
        CONF_MODE: number.NUMBER_MODES['AUTO'],
        # CONF_OPTIMISTIC: False,
        # CONF_RESTORE_VALUE: False,
        CONF_UNIT_OF_MEASUREMENT: "%",
    }, min_value=50, max_value=100, step=1)
    cg.add(charging_limit_number.set_parent(var))
    cg.add(var.set_charging_limit_number(charging_limit_number))

# Action schemas
TESLA_WAKE_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
})

TESLA_PAIR_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
})

TESLA_REGENERATE_KEY_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
})

TESLA_FORCE_UPDATE_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
})

TESLA_SET_CHARGING_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
    cv.Required("state"): cv.templatable(cv.boolean),
})

TESLA_SET_CHARGING_AMPS_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
    cv.Required("amps"): cv.templatable(cv.int_range(min=0, max=80)),
})

TESLA_SET_CHARGING_LIMIT_ACTION_SCHEMA = cv.Schema({
    cv.Required(CONF_ID): cv.use_id(TeslaBLEVehicle),
    cv.Required("limit"): cv.templatable(cv.int_range(min=50, max=100)),
})


# Register actions
@automation.register_action(
    "tesla_ble_vehicle.wake", WakeAction, TESLA_WAKE_ACTION_SCHEMA
)
async def tesla_wake_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    return cg.new_Pvariable(action_id, template_arg, paren)


@automation.register_action(
    "tesla_ble_vehicle.pair", PairAction, TESLA_PAIR_ACTION_SCHEMA
)
async def tesla_pair_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    return cg.new_Pvariable(action_id, template_arg, paren)


@automation.register_action(
    "tesla_ble_vehicle.regenerate_key", RegenerateKeyAction, TESLA_REGENERATE_KEY_ACTION_SCHEMA
)
async def tesla_regenerate_key_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    return cg.new_Pvariable(action_id, template_arg, paren)


@automation.register_action(
    "tesla_ble_vehicle.force_update", ForceUpdateAction, TESLA_FORCE_UPDATE_ACTION_SCHEMA
)
async def tesla_force_update_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    return cg.new_Pvariable(action_id, template_arg, paren)


@automation.register_action(
    "tesla_ble_vehicle.set_charging", SetChargingAction, TESLA_SET_CHARGING_ACTION_SCHEMA
)
async def tesla_set_charging_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    var = cg.new_Pvariable(action_id, template_arg, paren)
    template_ = await cg.templatable(config["state"], args, bool)
    cg.add(var.set_state(template_))
    return var


@automation.register_action(
    "tesla_ble_vehicle.set_charging_amps", SetChargingAmpsAction, TESLA_SET_CHARGING_AMPS_ACTION_SCHEMA
)
async def tesla_set_charging_amps_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    var = cg.new_Pvariable(action_id, template_arg, paren)
    template_ = await cg.templatable(config["amps"], args, int)
    cg.add(var.set_amps(template_))
    return var


@automation.register_action(
    "tesla_ble_vehicle.set_charging_limit", SetChargingLimitAction, TESLA_SET_CHARGING_LIMIT_ACTION_SCHEMA
)
async def tesla_set_charging_limit_to_code(config, action_id, template_arg, args):
    paren = await cg.get_variable(config[CONF_ID])
    var = cg.new_Pvariable(action_id, template_arg, paren)
    template_ = await cg.templatable(config["limit"], args, int)
    cg.add(var.set_limit(template_))
    return var





================================================
FILE: components/tesla_ble_vehicle/ble_manager.cpp
================================================
#include "ble_manager.h"
#include "tesla_ble_vehicle.h"
#include "common.h"
#include <client.h>
#include "log.h"
#include <esphome/core/helpers.h>
#include <algorithm>

namespace esphome {
namespace tesla_ble_vehicle {

BLETXChunk::BLETXChunk(std::vector<unsigned char> d, esp_gatt_write_type_t wt, esp_gatt_auth_req_t ar)
    : data(std::move(d)), write_type(wt), auth_req(ar), sent_at(millis()), retry_count(0) {}

BLERXChunk::BLERXChunk(std::vector<unsigned char> b)
    : buffer(std::move(b)), received_at(millis()) {}

BLEManager::BLEManager(TeslaBLEVehicle* parent)
    : parent_(parent) {
    read_buffer_.reserve(MAX_BLE_MESSAGE_SIZE);
}

int BLEManager::write_message(const unsigned char* message_buffer, size_t message_length,
                             esp_gatt_write_type_t write_type, esp_gatt_auth_req_t auth_req) {
    if (message_buffer == nullptr || message_length == 0) {
        ESP_LOGE(BLE_MANAGER_TAG, "Invalid message parameters");
        return -1;
    }

    if (message_length > MAX_BLE_MESSAGE_SIZE) {
        ESP_LOGE(BLE_MANAGER_TAG, "Message too large: %zu bytes (max: %zu)", message_length, MAX_BLE_MESSAGE_SIZE);
        return -1;
    }

    ESP_LOGD(BLE_MANAGER_TAG, "BLE TX: %s", 
             format_hex(message_buffer, message_length).c_str());

    fragment_message(message_buffer, message_length, write_type, auth_req);
    
    ESP_LOGD(BLE_MANAGER_TAG, "Message fragmented into %zu chunks", write_queue_.size());
    return 0;
}

void BLEManager::fragment_message(const unsigned char* message, size_t length,
                                 esp_gatt_write_type_t write_type, esp_gatt_auth_req_t auth_req) {
    // Split message into BLE-sized chunks
    ESP_LOGD(BLE_MANAGER_TAG, "Fragmenting %zu byte message into %zu-byte chunks", 
             length, static_cast<size_t>(BLOCK_LENGTH));
    
    for (size_t i = 0; i < length; i += BLOCK_LENGTH) {
        size_t chunk_length = std::min(static_cast<size_t>(BLOCK_LENGTH), length - i);
        std::vector<unsigned char> chunk(message + i, message + i + chunk_length);
        
        ESP_LOGV(BLE_MANAGER_TAG, "BLE TX chunk %zu/%zu (%zu bytes): %s", 
                 (i / BLOCK_LENGTH) + 1, 
                 (length + BLOCK_LENGTH - 1) / BLOCK_LENGTH,
                 chunk_length,
                 format_hex(chunk.data(), chunk.size()).c_str());
        
        write_queue_.emplace(std::move(chunk), write_type, auth_req);
    }
}

void BLEManager::process_write_queue() {
    if (write_queue_.empty()) {
        return;
    }

    if (!parent_->is_connected()) {
        ESP_LOGW(BLE_MANAGER_TAG, "Cannot send data - BLE not connected");
        return;
    }

    BLETXChunk& chunk = write_queue_.front();
    
    int gattc_if = parent_->parent()->get_gattc_if();
    uint16_t conn_id = parent_->parent()->get_conn_id();
    uint16_t write_handle = parent_->get_write_handle();
    
    esp_err_t err = esp_ble_gattc_write_char(
        gattc_if, conn_id, write_handle, 
        chunk.data.size(), chunk.data.data(), 
        chunk.write_type, chunk.auth_req
    );
    
    if (err != ESP_OK) {
        ESP_LOGW(BLE_MANAGER_TAG, "Failed to send BLE write: %s", esp_err_to_name(err));
        handle_write_error("BLE write failed");
    } else {
        ESP_LOGV(BLE_MANAGER_TAG, "BLE TX chunk: %s", 
                 format_hex(chunk.data.data(), chunk.data.size()).c_str());
        write_queue_.pop();
    }
}

void BLEManager::add_received_data(const std::vector<unsigned char>& data) {
    if (data.empty()) {
        ESP_LOGW(BLE_MANAGER_TAG, "Received empty data chunk");
        return;
    }

    ESP_LOGV(BLE_MANAGER_TAG, "BLE RX chunk: %s", 
             format_hex(data.data(), data.size()).c_str());

    read_queue_.emplace(data);
}

void BLEManager::process_read_queue() {
    if (read_queue_.empty()) {
        return;
    }

    ESP_LOGV(BLE_MANAGER_TAG, "Processing BLE read queue (size: %zu)", read_queue_.size());
    
    BLERXChunk chunk = read_queue_.front();
    read_queue_.pop();

    // Check for buffer overflow before appending
    size_t new_size = read_buffer_.size() + chunk.buffer.size();
    if (new_size > MAX_BLE_MESSAGE_SIZE) {
        ESP_LOGE(BLE_MANAGER_TAG, "Message size would exceed maximum (%zu > %zu bytes), discarding message", 
                 new_size, MAX_BLE_MESSAGE_SIZE);
        clear_read_buffer();  // Immediately clear buffer to prevent corruption
        return;
    }

    // Append new data to buffer
    read_buffer_.insert(read_buffer_.end(), chunk.buffer.begin(), chunk.buffer.end());
    
    ESP_LOGV(BLE_MANAGER_TAG, "Read buffer now contains %zu bytes", read_buffer_.size());

    // Check if we have a complete message
    if (is_message_complete()) {
        process_complete_message();
    } else {
        // Show buffering progress if we have at least the length header
        if (read_buffer_.size() >= 2) {
            int expected_length = get_expected_message_length();
            ESP_LOGD(BLE_MANAGER_TAG, "BLE RX: Buffered chunk, waiting for more data.. (%zu/%d)", 
                     read_buffer_.size(), expected_length + 2);
        }
    }
}

bool BLEManager::is_message_complete() {
    if (read_buffer_.size() < 2) {
        ESP_LOGD(BLE_MANAGER_TAG, "BLE RX: Not enough data to determine message length");
        return false;
    }

    int expected_length = get_expected_message_length();
    if (expected_length < 0) {
        ESP_LOGW(BLE_MANAGER_TAG, "Invalid message length indicator");
        handle_read_error("Invalid message length");
        return false;
    }

    bool complete = read_buffer_.size() >= static_cast<size_t>(expected_length + 2);
    ESP_LOGV(BLE_MANAGER_TAG, "Message completeness check: %zu >= %d = %s", 
             read_buffer_.size(), expected_length + 2, complete ? "complete" : "incomplete");
    
    return complete;
}

int BLEManager::get_expected_message_length() {
    if (read_buffer_.size() < 2) {
        return -1;
    }
    
    // First two bytes contain the message length in big-endian format
    int length = (read_buffer_[0] << 8) | read_buffer_[1];
    
    // Validate that the length is reasonable (not too large)
    if (length > MAX_BLE_MESSAGE_SIZE - 2) {
        ESP_LOGW(BLE_MANAGER_TAG, "Invalid message length: %d (must be 0-%zu)", 
                 length, MAX_BLE_MESSAGE_SIZE - 2);
        return -1;
    }
    
    return length;
}

void BLEManager::process_complete_message() {
    ESP_LOGD(BLE_MANAGER_TAG, "BLE RX: %s", format_hex(read_buffer_.data(), read_buffer_.size()).c_str());
    ESP_LOGD(BLE_MANAGER_TAG, "Processing complete received message (%zu bytes)", read_buffer_.size());
    
    // Pass the complete message to the message handler
    if (parent_->get_message_handler()) {
        // Parse the message using the Tesla BLE client
        UniversalMessage_RoutableMessage message = UniversalMessage_RoutableMessage_init_default;
        
        auto* tesla_client = parent_->get_session_manager()->get_client();
        if (tesla_client) {
            int result = tesla_client->parseUniversalMessageBLE(
                read_buffer_.data(), read_buffer_.size(), &message);
            
            if (result == 0) {
                ESP_LOGD(BLE_MANAGER_TAG, "Successfully parsed universal message");
                parent_->get_message_handler()->add_response(message);
            } else {
                ESP_LOGE(BLE_MANAGER_TAG, "Failed to parse universal message (error: %d)", result);
                handle_read_error("Message parsing failed");
            }
        } else {
            ESP_LOGE(BLE_MANAGER_TAG, "Tesla client not available for message parsing");
            handle_read_error("Tesla client unavailable");
        }
    }

    // Clear the buffer for the next message
    clear_read_buffer();
}

void BLEManager::clear_read_buffer() {
    read_buffer_.clear();
    // Only shrink if buffer is significantly over-allocated to reduce memory churn
    if (read_buffer_.capacity() > MAX_BLE_MESSAGE_SIZE * 2) {
        read_buffer_.shrink_to_fit();
        ESP_LOGD(BLE_MANAGER_TAG, "Shrunk read buffer capacity to reduce memory usage");
    }
}

void BLEManager::clear_queues() {
    // Clear write queue
    std::queue<BLETXChunk> empty_write;
    write_queue_.swap(empty_write);
    
    // Clear read queue
    std::queue<BLERXChunk> empty_read;
    read_queue_.swap(empty_read);
    
    // Clear read buffer
    clear_read_buffer();
    
    ESP_LOGD(BLE_MANAGER_TAG, "All queues and buffers cleared");
}

void BLEManager::handle_read_error(const std::string& error_msg) {
    ESP_LOGW(BLE_MANAGER_TAG, "Read error: %s", error_msg.c_str());
    clear_read_buffer();
    
    // Optionally clear the read queue on errors to prevent cascading issues
    std::queue<BLERXChunk> empty_queue;
    read_queue_.swap(empty_queue);
}

void BLEManager::handle_write_error(const std::string& error_msg) {
    ESP_LOGW(BLE_MANAGER_TAG, "Write error: %s", error_msg.c_str());
    
    // For write errors, we might want to retry or clear the queue depending on the error
    // For now, just log the error - the queue will be processed again on the next loop
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/ble_manager.h
================================================
#pragma once

#include <queue>
#include <vector>
#include <esp_gattc_api.h>
#include <esphome/core/log.h>

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const BLE_MANAGER_TAG = "tesla_ble_manager";

// Forward declarations
class TeslaBLEVehicle;

struct BLETXChunk {
    std::vector<unsigned char> data;
    esp_gatt_write_type_t write_type;
    esp_gatt_auth_req_t auth_req;
    uint32_t sent_at;
    uint8_t retry_count;

    BLETXChunk(std::vector<unsigned char> d, esp_gatt_write_type_t wt, esp_gatt_auth_req_t ar);
};

struct BLERXChunk {
    std::vector<unsigned char> buffer;
    uint32_t received_at;

    explicit BLERXChunk(std::vector<unsigned char> b);
};

/**
 * @brief BLE communication manager for Tesla vehicles
 * 
 * This class handles low-level BLE communication, including message fragmentation,
 * reassembly, and queue management.
 */
class BLEManager {
public:
    static constexpr int BLOCK_LENGTH = 20;           // BLE chunk size
    static constexpr int RX_TIMEOUT = 1000;           // 1s timeout between chunks
    
    explicit BLEManager(TeslaBLEVehicle* parent);
    
    // Message transmission
    int write_message(const unsigned char* message_buffer, size_t message_length,
                     esp_gatt_write_type_t write_type = ESP_GATT_WRITE_TYPE_NO_RSP,
                     esp_gatt_auth_req_t auth_req = ESP_GATT_AUTH_REQ_NONE);
    
    // Queue processing
    void process_write_queue();
    void process_read_queue();
    
    // Data reception
    void add_received_data(const std::vector<unsigned char>& data);
    
    // Queue management
    void clear_queues();
    size_t get_write_queue_size() const { return write_queue_.size(); }
    size_t get_read_queue_size() const { return read_queue_.size(); }
    
    // Buffer management
    void clear_read_buffer();
    size_t get_read_buffer_size() const { return read_buffer_.size(); }
    
private:
    TeslaBLEVehicle* parent_;
    std::queue<BLETXChunk> write_queue_;
    std::queue<BLERXChunk> read_queue_;
    std::vector<unsigned char> read_buffer_;
    
    // Helper methods
    bool is_message_complete();
    int get_expected_message_length();
    void process_complete_message();
    void fragment_message(const unsigned char* message, size_t length,
                         esp_gatt_write_type_t write_type, esp_gatt_auth_req_t auth_req);
    
    // Error handling
    void handle_read_error(const std::string& error_msg);
    void handle_write_error(const std::string& error_msg);
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/command_builder.h
================================================
#pragma once

#include <functional>
#include <memory>
#include <string>
#include <unordered_map>
#include <any>
#include <vector>
#include <esphome/core/helpers.h>
#include <universal_message.pb.h>

namespace esphome {
namespace tesla_ble_vehicle {

// Forward declarations
class TeslaBLEVehicle;
class SessionManager;
class BLEManager;
class CommandManager;

namespace TeslaBLE {
    class Client;
}

/**
 * @brief Result type for command operations
 */
enum class CommandResult {
    SUCCESS = 0,
    ERROR_NO_SESSION_MANAGER = -1,
    ERROR_NO_BLE_MANAGER = -2,
    ERROR_NO_CLIENT = -3,
    ERROR_NO_PEER = -4,
    ERROR_BUILD_MESSAGE = -5,
    ERROR_SEND_MESSAGE = -6,
    ERROR_INVALID_DOMAIN = -7,
    ERROR_AUTH_REQUIRED = -8,
    ERROR_NO_COMMAND_MANAGER = -9,
    ERROR_NO_VEHICLE = -10
};

/**
 * @brief Domain-specific command strategy interface
 */
class DomainCommandStrategy {
public:
    virtual ~DomainCommandStrategy() = default;

    /**
     * @brief Check if domain requires authentication
     */
    virtual bool requires_authentication() const = 0;

    /**
     * @brief Get the domain this strategy handles
     */
    virtual UniversalMessage_Domain get_domain() const = 0;

    /**
     * @brief Check if domain is currently authenticated
     */
    virtual bool is_authenticated(SessionManager* session_manager) const = 0;

    /**
     * @brief Handle counter increment for this domain
     */
    virtual CommandResult increment_counter(SessionManager* session_manager) const = 0;

    /**
     * @brief Get domain-specific name for logging
     */
    virtual const char* get_name() const = 0;
};

/**
 * @brief VCSEC domain command strategy
 */
class VCSECDomainStrategy : public DomainCommandStrategy {
public:
    UniversalMessage_Domain get_domain() const override {
        return UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY;
    }

    bool requires_authentication() const override { return true; }

    bool is_authenticated(SessionManager* session_manager) const override;

    CommandResult increment_counter(SessionManager* session_manager) const override;

    const char* get_name() const override { return "VCSEC"; }
};

/**
 * @brief Infotainment domain command strategy
 */
class InfotainmentDomainStrategy : public DomainCommandStrategy {
public:
    UniversalMessage_Domain get_domain() const override {
        return UniversalMessage_Domain_DOMAIN_INFOTAINMENT;
    }

    bool requires_authentication() const override { return true; }

    bool is_authenticated(SessionManager* session_manager) const override;

    CommandResult increment_counter(SessionManager* session_manager) const override;

    const char* get_name() const override { return "Infotainment"; }
};

/**
 * @brief Broadcast domain command strategy (no auth required)
 */
class BroadcastDomainStrategy : public DomainCommandStrategy {
public:
    UniversalMessage_Domain get_domain() const override {
        return UniversalMessage_Domain_DOMAIN_BROADCAST;
    }

    bool requires_authentication() const override { return false; }

    bool is_authenticated(SessionManager* session_manager) const override { return true; }

    CommandResult increment_counter(SessionManager* session_manager) const override { return CommandResult::SUCCESS; }

    const char* get_name() const override { return "Broadcast"; }
};

/**
 * @brief Fluent API for building BLE commands with proper domain handling
 */
class BLECommandBuilder {
public:
    /**
     * @brief Create a command builder for a specific domain
     */
    static BLECommandBuilder for_domain(UniversalMessage_Domain domain);

    /**
     * @brief Create a command builder with a custom strategy
     */
    static BLECommandBuilder with_strategy(std::shared_ptr<DomainCommandStrategy> strategy);

    /**
     * @brief Set the vehicle instance (provides access to managers)
     */
    BLECommandBuilder& with_vehicle(TeslaBLEVehicle* vehicle);

    /**
     * @brief Set explicit managers (alternative to vehicle)
     */
    BLECommandBuilder& with_managers(SessionManager* session_manager, BLEManager* ble_manager);

    /**
     * @brief Set the message builder function
     */
    template<typename BuilderFunc>
    BLECommandBuilder& with_builder(BuilderFunc builder) {
        builder_func_ = builder;
        return *this;
    }

    /**
     * @brief Set command name for logging
     */
    BLECommandBuilder& with_name(const std::string& name);

    /**
     * @brief Force counter increment (override strategy default)
     */
    BLECommandBuilder& force_counter_increment(bool increment = true);

    /**
     * @brief Build the command function
     */
    std::function<int()> build();

    /**
     * @brief Build and enqueue the command
     */
    CommandResult enqueue(CommandManager* command_manager);

private:
    BLECommandBuilder(std::shared_ptr<DomainCommandStrategy> strategy);

    std::shared_ptr<DomainCommandStrategy> strategy_;
    TeslaBLEVehicle* vehicle_;
    SessionManager* session_manager_;
    BLEManager* ble_manager_;
    std::function<int(TeslaBLE::Client*, unsigned char*, size_t*)> builder_func_;
    std::string command_name_;
    bool force_counter_increment_;
};

/**
 * @brief Registry for domain strategies
 */
class DomainStrategyRegistry {
public:
    static DomainStrategyRegistry& get_instance();

    void register_strategy(UniversalMessage_Domain domain, std::shared_ptr<DomainCommandStrategy> strategy);
    std::shared_ptr<DomainCommandStrategy> get_strategy(UniversalMessage_Domain domain) const;

private:
    DomainStrategyRegistry();
    std::unordered_map<UniversalMessage_Domain, std::shared_ptr<DomainCommandStrategy>> strategies_;
};

/**
 * @brief Command type enumeration for common Tesla operations
 * 
 * To add a new command:
 * 1. Add the enum value here
 * 2. Register it in TeslaCommandRegistry::TeslaCommandRegistry() constructor
 * 3. That's it! Everything else is handled automatically.
 */
enum class TeslaCommandType {
    // VCSEC Commands
    VCSEC_STATUS_POLL,
    WAKE_VEHICLE,
    
    // Infotainment Commands
    INFOTAINMENT_DATA_POLL,
    SET_CHARGING_AMPS,
    SET_CHARGING_LIMIT,
    SET_CHARGING_STATE,
    
    // Custom command (for future extensibility)
    CUSTOM
};

/**
 * @brief Command definition structure - encapsulates everything about a command
 */
struct TeslaCommandDefinition {
    TeslaCommandType type;
    UniversalMessage_Domain domain;
    std::string name;
    std::function<int(TeslaBLE::Client*, unsigned char*, size_t*, const std::vector<std::any>&)> builder_func;
};

/**
 * @brief Command registry - single source of truth for all commands
 */
class TeslaCommandRegistry {
public:
    static TeslaCommandRegistry& get_instance();
    
    const TeslaCommandDefinition* get_definition(TeslaCommandType type) const;
    std::vector<TeslaCommandType> get_all_types() const;

private:
    TeslaCommandRegistry();
    
    std::unordered_map<TeslaCommandType, TeslaCommandDefinition> definitions_;
    
    void register_command(TeslaCommandType type, UniversalMessage_Domain domain, 
                         const std::string& name,
                         std::function<int(TeslaBLE::Client*, unsigned char*, size_t*, const std::vector<std::any>&)> builder);
};

/**
 * @brief High-level command factory for common operations
 */
class TeslaCommandFactory {
public:
    explicit TeslaCommandFactory(TeslaBLEVehicle* vehicle);

    /**
     * @brief Create a command using a predefined type and parameters
     */
    BLECommandBuilder create(TeslaCommandType type, const std::vector<std::any>& params = {});
    
    /**
     * @brief Create a custom command with full control
     */
    BLECommandBuilder create_custom(UniversalMessage_Domain domain, 
                                   const std::string& name,
                                   std::function<int(TeslaBLE::Client*, unsigned char*, size_t*)> builder);

private:
    TeslaBLEVehicle* vehicle_;
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/command_manager.cpp
================================================
#include "command_manager.h"
#include "tesla_ble_vehicle.h"
#include <client.h>
#include "log.h"
#include "common.h"

namespace esphome {
namespace tesla_ble_vehicle {

// Helper function to create simple commands
template<typename BuilderFunc>
std::function<int()> create_command(TeslaBLEVehicle* vehicle, BuilderFunc builder) {
    return [vehicle, builder]() {
        auto* session_manager = vehicle->get_session_manager();
        auto* ble_manager = vehicle->get_ble_manager();
        
        if (!session_manager || !ble_manager) {
            return -1;
        }
        
        auto* client = session_manager->get_client();
        if (!client) {
            return -1;
        }
        
        unsigned char message_buffer[MAX_BLE_MESSAGE_SIZE];
        size_t message_length = MAX_BLE_MESSAGE_SIZE;
        
        int result = builder(client, message_buffer, &message_length);
        if (result != 0) {
            return result;
        }
        
        return ble_manager->write_message(message_buffer, message_length);
    };
}

BLECommand::BLECommand(UniversalMessage_Domain d, std::function<int()> e, const std::string& n)
    : domain(d), execute(std::move(e)), execute_name(std::move(n)), 
      state(BLECommandState::IDLE), started_at(millis()), last_tx_at(0), retry_count(0) {}

CommandManager::CommandManager(TeslaBLEVehicle* parent)
    : parent_(parent) {}

void CommandManager::enqueue_command(UniversalMessage_Domain domain, 
                                    std::function<int()> execute, 
                                    const std::string& name) {
    // Prevent unbounded queue growth
    if (command_queue_.size() >= MAX_QUEUE_SIZE) {
        ESP_LOGE(COMMAND_MANAGER_TAG, "Command queue full (%zu/%zu), rejecting command: %s", 
                 command_queue_.size(), MAX_QUEUE_SIZE, name.c_str());
        return;
    }
    
    ESP_LOGD(COMMAND_MANAGER_TAG, "Enqueueing command: %s (domain: %s)", 
             name.c_str(), domain_to_string(domain));
    
    command_queue_.emplace(domain, std::move(execute), name);
}

void CommandManager::process_command_queue() {
    if (command_queue_.empty()) {
        return;
    }

    BLECommand& current_command = command_queue_.front();
    uint32_t now = millis();

    // Check for overall command timeout (rollover-safe)
    uint32_t time_since_start = Utils::time_since(now, current_command.started_at);
    if (time_since_start > COMMAND_TIMEOUT) {
        LogHelper::log_command_timeout(COMMAND_MANAGER_TAG, current_command.execute_name.c_str(), COMMAND_TIMEOUT);
        mark_command_failed("Overall timeout");
        return;
    }

    // Process command based on current state
    switch (current_command.state) {
        case BLECommandState::IDLE:
            process_idle_command(current_command);
            break;
            
        case BLECommandState::WAITING_FOR_VCSEC_AUTH:
        case BLECommandState::WAITING_FOR_VCSEC_AUTH_RESPONSE:
        case BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH:
        case BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH_RESPONSE:
        case BLECommandState::WAITING_FOR_WAKE:
        case BLECommandState::WAITING_FOR_WAKE_RESPONSE:
            process_auth_waiting_command(current_command);
            break;
            
        case BLECommandState::READY:
            process_ready_command(current_command);
            break;
            
        case BLECommandState::WAITING_FOR_RESPONSE:
            // Check for response timeout (rollover-safe)
            uint32_t time_since_tx = Utils::time_since(now, current_command.last_tx_at);
            if (time_since_tx > MAX_LATENCY) {
                LogHelper::log_command_retry(COMMAND_MANAGER_TAG, current_command.execute_name.c_str(), 
                                           current_command.retry_count + 1, MAX_RETRIES + 1, "Response timeout");
                current_command.state = BLECommandState::READY;
            }
            // Check for overall command timeout even in WAITING_FOR_RESPONSE (rollover-safe)
            if (time_since_start > COMMAND_TIMEOUT) {
                LogHelper::log_command_timeout(COMMAND_MANAGER_TAG, current_command.execute_name.c_str(), 
                                              COMMAND_TIMEOUT, "in WAITING_FOR_RESPONSE");
                mark_command_failed("Response timeout");
                return;
            }
            break;
    }
}

void CommandManager::process_idle_command(BLECommand& command) {
    ESP_LOGV(COMMAND_MANAGER_TAG, "[%s] Preparing command", command.execute_name.c_str());
    
    command.started_at = millis();
    
    switch (command.domain) {
        case UniversalMessage_Domain_DOMAIN_BROADCAST:
            ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] No auth required, executing command", 
                     command.execute_name.c_str());
            command.state = BLECommandState::READY;
            break;
            
        case UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY:
            ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] VCSEC auth required", 
                     command.execute_name.c_str());
            initiate_vcsec_auth(command);
            break;
            
        case UniversalMessage_Domain_DOMAIN_INFOTAINMENT:
            ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] Infotainment auth required", 
                     command.execute_name.c_str());
            initiate_infotainment_auth(command);
            break;
            
        default:
            ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Unknown domain: %d", 
                     command.execute_name.c_str(), command.domain);
            mark_command_failed("Unknown domain");
            break;
    }
}

void CommandManager::process_auth_waiting_command(BLECommand& command) {
    uint32_t now = millis();
    
    // Check for auth timeout (rollover-safe)
    uint32_t time_since_tx = Utils::time_since(now, command.last_tx_at);
    if (time_since_tx > MAX_LATENCY) {
        switch (command.state) {
            case BLECommandState::WAITING_FOR_VCSEC_AUTH:
                initiate_vcsec_auth(command);
                break;
                
            case BLECommandState::WAITING_FOR_VCSEC_AUTH_RESPONSE:
                ESP_LOGW(COMMAND_MANAGER_TAG, "[%s] VCSEC auth response timeout, retrying",
                         command.execute_name.c_str());
                command.state = BLECommandState::WAITING_FOR_VCSEC_AUTH;
                break;
                
            case BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH:
                initiate_infotainment_auth(command);
                break;
                
            case BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH_RESPONSE:
                ESP_LOGW(COMMAND_MANAGER_TAG, "[%s] Infotainment auth response timeout, retrying",
                         command.execute_name.c_str());
                command.state = BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH;
                break;
                
            case BLECommandState::WAITING_FOR_WAKE:
                initiate_wake_sequence(command);
                break;
                
            case BLECommandState::WAITING_FOR_WAKE_RESPONSE:
                // Check if vehicle is now awake
                if (!parent_->get_state_manager()->is_asleep()) {
                    ESP_LOGI(COMMAND_MANAGER_TAG, "[%s] Vehicle is now awake", 
                             command.execute_name.c_str());
                    // Determine next state based on command requirements
                    if (command.domain == UniversalMessage_Domain_DOMAIN_INFOTAINMENT) {
                        command.state = BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH;
                    } else if (command.domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY) {
                        // VCSEC commands that went through wake should be ready now
                        command.state = BLECommandState::READY;
                    } else {
                        // Broadcast commands should be ready
                        command.state = BLECommandState::READY;
                    }
                } else {
                    retry_command(command);
                }
                break;
                
            default:
                break;
        }
    }
}

void CommandManager::process_ready_command(BLECommand& command) {
    uint32_t now = millis();
    
    // Check if enough time has passed since last transmission (rollover-safe)
    uint32_t time_since_tx = Utils::time_since(now, command.last_tx_at);
    if (time_since_tx > MAX_LATENCY) {
        if (command.retry_count >= MAX_RETRIES) {
            ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Max retries exceeded", 
                     command.execute_name.c_str());
            mark_command_failed("Max retries exceeded");
            return;
        }
        
        LogHelper::log_command_retry(COMMAND_MANAGER_TAG, command.execute_name.c_str(), 
                                   command.retry_count + 1, MAX_RETRIES + 1);
        
        int result = command.execute();
        command.last_tx_at = now;
        command.retry_count++;
        
        if (result == 0) {
            command.state = BLECommandState::WAITING_FOR_RESPONSE;
        } else {
            ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Command execution failed (error: %d)", 
                     command.execute_name.c_str(), result);
            retry_command(command);
        }
    }
}

void CommandManager::initiate_vcsec_auth(BLECommand& command) {
    if (is_domain_authenticated(UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY)) {
        // Already authenticated, proceed based on target domain
        if (command.domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY) {
            command.state = BLECommandState::READY;
        } else {
            // Need infotainment auth, proceed to next step
            command.state = BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH;
        }
    } else {
        // Request VCSEC session info
        auto* session_manager = parent_->get_session_manager();
        if (session_manager && session_manager->request_session_info(UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY)) {
            command.state = BLECommandState::WAITING_FOR_VCSEC_AUTH_RESPONSE;
            command.last_tx_at = millis();
        } else {
            ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Failed to request VCSEC session info", 
                     command.execute_name.c_str());
            mark_command_failed("VCSEC auth request failed");
        }
    }
}

void CommandManager::initiate_infotainment_auth(BLECommand& command) {
    // Check if vehicle is asleep - if so, transition to wake state
    if (parent_->get_state_manager()->is_asleep()) {
        ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] Vehicle is asleep, transitioning to wake state", 
                 command.execute_name.c_str());
        command.state = BLECommandState::WAITING_FOR_WAKE;
        command.last_tx_at = 0;  // Trigger immediate wake sequence
        return;
    }
    
    // Check if VCSEC auth is required first
    if (!is_domain_authenticated(UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY)) {
        ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] VCSEC auth required before infotainment auth", 
                 command.execute_name.c_str());
        command.state = BLECommandState::WAITING_FOR_VCSEC_AUTH;
        return;
    }
    
    if (is_domain_authenticated(UniversalMessage_Domain_DOMAIN_INFOTAINMENT)) {
        command.state = BLECommandState::READY;
    } else {
        // Request infotainment session info
        auto* session_manager = parent_->get_session_manager();
        if (session_manager && session_manager->request_session_info(UniversalMessage_Domain_DOMAIN_INFOTAINMENT)) {
            command.state = BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH_RESPONSE;
            command.last_tx_at = millis();
        } else {
            ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Failed to request infotainment session info", 
                     command.execute_name.c_str());
            mark_command_failed("Infotainment auth request failed");
        }
    }
}

void CommandManager::initiate_wake_sequence(BLECommand& command) {
    ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] Sending wake command", command.execute_name.c_str());
    
    // Execute wake command directly to avoid recursive queue operations
    auto wake_command = create_command(parent_, [](auto* client, auto* buffer, auto* length) {
        return client->buildVCSECActionMessage(
            VCSEC_RKEAction_E_RKE_ACTION_WAKE_VEHICLE,
            buffer, length);
    });
    
    int result = wake_command();
    if (result == 0) {
        command.state = BLECommandState::WAITING_FOR_WAKE_RESPONSE;
        command.last_tx_at = millis();
    } else {
        ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Failed to send wake command: %d", 
                 command.execute_name.c_str(), result);
        mark_command_failed("Wake command failed");
    }
}

void CommandManager::retry_command(BLECommand& command) {
    if (command.retry_count >= MAX_RETRIES) {
        mark_command_failed("Max retries exceeded");
    } else {
        ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] Retrying command (attempt %d/%d)", 
                 command.execute_name.c_str(), command.retry_count + 1, MAX_RETRIES + 1);
        
        // Reset to appropriate state based on current state
        switch (command.state) {
            case BLECommandState::WAITING_FOR_WAKE_RESPONSE:
                // Retry wake sequence
                command.state = BLECommandState::WAITING_FOR_WAKE;
                break;
                
            case BLECommandState::WAITING_FOR_RESPONSE:
                // Retry command execution
                command.state = BLECommandState::READY;
                break;
                
            default:
                // For auth states and others, restart from IDLE
                command.state = BLECommandState::IDLE;
                break;
        }
        
        command.retry_count++;
        // Add a small delay before retry to prevent tight loops
        command.last_tx_at = millis() - (MAX_LATENCY - 100);  // Will be ready in 100ms
    }
}

bool CommandManager::is_domain_authenticated(UniversalMessage_Domain domain) {
    auto* session_manager = parent_->get_session_manager();
    return session_manager ? session_manager->is_domain_authenticated(domain) : false;
}

void CommandManager::handle_authentication_response(UniversalMessage_Domain domain, bool success) {
    if (command_queue_.empty()) {
        return;
    }
    
    BLECommand& current_command = command_queue_.front();
    
    if (success) {
        ESP_LOGD(COMMAND_MANAGER_TAG, "[%s] Authentication successful for %s", 
                 current_command.execute_name.c_str(), domain_to_string(domain));
        
        // Move to next state based on command requirements
        if (domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY) {
            if (current_command.domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY) {
                current_command.state = BLECommandState::READY;
            } else if (current_command.domain == UniversalMessage_Domain_DOMAIN_INFOTAINMENT) {
                // Continue with infotainment auth
                current_command.state = BLECommandState::WAITING_FOR_INFOTAINMENT_AUTH;
            } else {
                current_command.state = BLECommandState::READY;
            }
        } else if (domain == UniversalMessage_Domain_DOMAIN_INFOTAINMENT) {
            current_command.state = BLECommandState::READY;
        }
        
        // Reset timing for next state
        current_command.last_tx_at = 0;
    } else {
        ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Authentication failed for %s", 
                 current_command.execute_name.c_str(), domain_to_string(domain));
        mark_command_failed("Authentication failed");
    }
}

BLECommand* CommandManager::get_current_command() {
    if (command_queue_.empty()) {
        return nullptr;
    }
    return &command_queue_.front();
}

void CommandManager::mark_command_completed() {
    if (!command_queue_.empty()) {
        BLECommand& command = command_queue_.front();
        uint32_t duration = millis() - command.started_at;
        ESP_LOGI(COMMAND_MANAGER_TAG, "[%s] Command completed successfully in %u ms", 
                 command.execute_name.c_str(), duration);

        // If this was the initial VCSEC poll after connection, trigger deferred infotainment poll
        if (command.domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY && parent_ && parent_->get_polling_manager()) {
            parent_->get_polling_manager()->handle_initial_vcsec_poll_complete();
        }

        command_queue_.pop();
    }
}

void CommandManager::mark_command_failed(const std::string& reason) {
    if (!command_queue_.empty()) {
        BLECommand& command = command_queue_.front();
        uint32_t duration = millis() - command.started_at;
        ESP_LOGE(COMMAND_MANAGER_TAG, "[%s] Command failed after %u ms: %s", 
                 command.execute_name.c_str(), duration, reason.c_str());
        command_queue_.pop();
    }
}

void CommandManager::clear_queue() {
    std::queue<BLECommand> empty_queue;
    command_queue_.swap(empty_queue);
    ESP_LOGD(COMMAND_MANAGER_TAG, "Command queue cleared");
}

void CommandManager::update_command_state(BLECommandState new_state) {
    if (!command_queue_.empty()) {
        command_queue_.front().state = new_state;
        ESP_LOGV(COMMAND_MANAGER_TAG, "Command state updated to %d", static_cast<int>(new_state));
    } else {
        ESP_LOGW(COMMAND_MANAGER_TAG, "Attempted to update command state but queue is empty");
    }
}

// Simple command creation helpers
void CommandManager::enqueue_wake_vehicle() {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY,
        create_command(parent_, [](auto* client, auto* buffer, auto* length) {
            return client->buildVCSECActionMessage(
                VCSEC_RKEAction_E_RKE_ACTION_WAKE_VEHICLE,
                buffer, length);
        }),
        "wake vehicle"
    );
}

void CommandManager::enqueue_vcsec_poll() {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY,
        create_command(parent_, [](auto* client, auto* buffer, auto* length) {
            return client->buildVCSECInformationRequestMessage(
                VCSEC_InformationRequestType_INFORMATION_REQUEST_TYPE_GET_STATUS,
                buffer, length);
        }),
        "VCSEC status poll"
    );
}

void CommandManager::enqueue_infotainment_poll() {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_INFOTAINMENT,
        create_command(parent_, [](auto* client, auto* buffer, auto* length) {
            return client->buildCarServerGetVehicleDataMessage(
                buffer, length, CarServer_GetVehicleData_getChargeState_tag);
        }),
        "infotainment data poll"
    );
}

void CommandManager::enqueue_set_charging_state(bool enable) {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_INFOTAINMENT,
        create_command(parent_, [enable](auto* client, auto* buffer, auto* length) {
            // Use Tesla's standard charging start/stop action with proper enum values
            int32_t action = enable ? 1 : 0;  // 1 = start, 0 = stop
            return client->buildCarServerVehicleActionMessage(
                buffer, length,
                CarServer_VehicleAction_chargingStartStopAction_tag,
                &action);
        }),
        enable ? "start charging" : "stop charging"
    );
}

void CommandManager::enqueue_set_charging_amps(int amps) {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_INFOTAINMENT,
        create_command(parent_, [amps](auto* client, auto* buffer, auto* length) {
            int32_t amps_param = static_cast<int32_t>(amps);
            return client->buildCarServerVehicleActionMessage(
                buffer, length,
                CarServer_VehicleAction_setChargingAmpsAction_tag,
                &amps_param);
        }),
        "set charging amps"
    );
}

void CommandManager::enqueue_set_charging_limit(int limit) {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_INFOTAINMENT,
        create_command(parent_, [limit](auto* client, auto* buffer, auto* length) {
            int32_t limit_param = static_cast<int32_t>(limit);
            return client->buildCarServerVehicleActionMessage(
                buffer, length,
                CarServer_VehicleAction_chargingSetLimitAction_tag,
                &limit_param);
        }),
        "set charging limit"
    );
}

void CommandManager::enqueue_unlock_charge_port() {
    enqueue_command(
        UniversalMessage_Domain_DOMAIN_INFOTAINMENT,
        create_command(parent_, [](auto* client, auto* buffer, auto* length) {
            // Open/unlock the charge port door via infotainment vehicle action
            // Assumes client provides builder for charge port door open action
            return client->buildCarServerVehicleActionMessage(
                buffer, length,
                CarServer_VehicleAction_chargePortDoorOpen_tag,
                nullptr);
        }),
        "unlock charge port"
    );
}
} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/command_manager.h
================================================
#pragma once

#include <functional>
#include <queue>
#include <string>
#include <esphome/core/log.h>
#include <universal_message.pb.h>

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const COMMAND_MANAGER_TAG = "tesla_command_manager";

// Forward declarations
class TeslaBLEVehicle;

enum class BLECommandState {
    IDLE,
    WAITING_FOR_VCSEC_AUTH,
    WAITING_FOR_VCSEC_AUTH_RESPONSE,
    WAITING_FOR_INFOTAINMENT_AUTH,
    WAITING_FOR_INFOTAINMENT_AUTH_RESPONSE,
    WAITING_FOR_WAKE,
    WAITING_FOR_WAKE_RESPONSE,
    READY,
    WAITING_FOR_RESPONSE,
};

struct BLECommand {
    UniversalMessage_Domain domain;
    std::function<int()> execute;
    std::string execute_name;
    BLECommandState state;
    uint32_t started_at;
    uint32_t last_tx_at;
    uint8_t retry_count;

    BLECommand(UniversalMessage_Domain d, std::function<int()> e, const std::string& n = "");
};

/**
 * @brief Command manager for Tesla BLE operations
 * 
 * This class manages the command queue, handles authentication states,
 * and ensures proper sequencing of BLE operations.
 */
class CommandManager {
public:
    static constexpr uint32_t COMMAND_TIMEOUT = 30 * 1000; // 30s
    static constexpr uint32_t MAX_LATENCY = 4 * 1000;      // 4s
    static constexpr uint8_t MAX_RETRIES = 5;
    static constexpr size_t MAX_QUEUE_SIZE = 20;           // Prevent unbounded queue growth
    
    explicit CommandManager(TeslaBLEVehicle* parent);
    
    // Command queue management
    void enqueue_command(UniversalMessage_Domain domain, std::function<int()> execute, const std::string& name);
    void process_command_queue();
    void clear_queue();
    
    // Command state management
    void update_command_state(BLECommandState new_state);
    void mark_command_completed();
    void mark_command_failed(const std::string& reason);
    
    // Authentication helpers
    bool is_domain_authenticated(UniversalMessage_Domain domain);
    void handle_authentication_response(UniversalMessage_Domain domain, bool success);
    
    // Queue inspection
    bool has_pending_commands() const { return !command_queue_.empty(); }
    size_t get_queue_size() const { return command_queue_.size(); }
    BLECommand* get_current_command();
    
    // Simple command creation helpers
    void enqueue_wake_vehicle();
    void enqueue_vcsec_poll();
    void enqueue_infotainment_poll();
    void enqueue_set_charging_state(bool enable);
    void enqueue_set_charging_amps(int amps);
    void enqueue_set_charging_limit(int limit);
    void enqueue_unlock_charge_port();
    
private:
    TeslaBLEVehicle* parent_;
    std::queue<BLECommand> command_queue_;
    
    // Command processing helpers
    void process_idle_command(BLECommand& command);
    void process_auth_waiting_command(BLECommand& command);
    void process_ready_command(BLECommand& command);
    void handle_command_timeout(BLECommand& command);
    void retry_command(BLECommand& command);
    
    // Authentication state helpers
    void initiate_vcsec_auth(BLECommand& command);
    void initiate_infotainment_auth(BLECommand& command);
    void initiate_wake_sequence(BLECommand& command);
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/common.h
================================================
#pragma once

#include <functional>
#include <esphome/core/helpers.h>
#include <esphome/core/hal.h>
#include <universal_message.pb.h>

namespace esphome {
namespace tesla_ble_vehicle {

// Common constants - shared across all components
static constexpr size_t MAX_BLE_MESSAGE_SIZE = 1024;

// Validation constants
static constexpr int MIN_CHARGING_AMPS = 0;
static constexpr int MAX_CHARGING_AMPS = 80;  // Theoretical max, actual max comes from vehicle
static constexpr int MIN_CHARGING_LIMIT = 50;
static constexpr int MAX_CHARGING_LIMIT = 100;

// Forward declarations
class TeslaBLEVehicle;
class SessionManager;
class BLEManager;

/**
 * @brief Utility functions for common operations
 */
class Utils {
public:
    /**
     * @brief Calculate time difference in milliseconds, handling millis() rollover
     * @param now Current time from millis()
     * @param timestamp Past timestamp to compare against
     * @return Time difference in milliseconds
     */
    static uint32_t time_since(uint32_t now, uint32_t timestamp) {
        return (now >= timestamp) ? (now - timestamp) : (UINT32_MAX - timestamp + now + 1);
    }
    
    /**
     * @brief Check if enough time has elapsed since a timestamp, handling rollover
     * @param timestamp Past timestamp to check against
     * @param interval Required interval in milliseconds
     * @return true if interval has elapsed
     */
    static bool has_elapsed(uint32_t timestamp, uint32_t interval) {
        return time_since(millis(), timestamp) >= interval;
    }
};

/**
 * @brief Logging helpers to reduce code duplication
 */
class LogHelper {
public:
    /**
     * @brief Log command timeout with standardized format
     */
    static void log_command_timeout(const char* tag, const std::string& command_name, 
                                   uint32_t timeout_ms, const char* context = "") {
        if (strlen(context) > 0) {
            ESP_LOGE(tag, "[%s] Command timed out %s after %" PRIu32 " ms", 
                    command_name.c_str(), context, timeout_ms);
        } else {
            ESP_LOGE(tag, "[%s] Command timed out after %" PRIu32 " ms", 
                    command_name.c_str(), timeout_ms);
        }
    }
    
    /**
     * @brief Log command retry with standardized format
     */
    static void log_command_retry(const char* tag, const std::string& command_name, 
                                 int attempt, int max_attempts, const char* reason = "") {
        if (strlen(reason) > 0) {
            ESP_LOGW(tag, "[%s] %s, retrying (attempt %d/%d)", 
                    command_name.c_str(), reason, attempt, max_attempts);
        } else {
            ESP_LOGI(tag, "[%s] Executing command (attempt %d/%d)", 
                    command_name.c_str(), attempt, max_attempts);
        }
    }
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/log.cpp
================================================
#include <inttypes.h>
#include <string.h>

#include <esphome/core/helpers.h>
#include <esphome/core/log.h>

#include <car_server.pb.h>
#include <signatures.pb.h>
#include <universal_message.pb.h>
#include <vcsec.pb.h>

using namespace esphome;

// Helper function to convert UniversalMessage_OperationStatus_E enum to string
const char *operation_status_to_string(UniversalMessage_OperationStatus_E status)
{
    switch (status)
    {
    case UniversalMessage_OperationStatus_E_OPERATIONSTATUS_OK:
        return "OK";
    case UniversalMessage_OperationStatus_E_OPERATIONSTATUS_WAIT:
        return "WAIT";
    case UniversalMessage_OperationStatus_E_OPERATIONSTATUS_ERROR:
        return "ERROR";
    default:
        return "UNKNOWN_STATUS";
    }
}

const char *vcsec_operation_status_to_string(VCSEC_OperationStatus_E status)
{
    switch (status)
    {
    case VCSEC_OperationStatus_E_OPERATIONSTATUS_OK:
        return "OK";
    case VCSEC_OperationStatus_E_OPERATIONSTATUS_WAIT:
        return "WAIT";
    case VCSEC_OperationStatus_E_OPERATIONSTATUS_ERROR:
        return "ERROR";
    default:
        return "UNKNOWN_STATUS";
    }
}

const char *information_request_type_to_string(VCSEC_InformationRequestType request_type)
{
    switch (request_type)
    {
    case VCSEC_InformationRequestType_INFORMATION_REQUEST_TYPE_GET_STATUS:
        return "GET_STATUS";
    case VCSEC_InformationRequestType_INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO:
        return "GET_WHITELIST_INFO";
    case VCSEC_InformationRequestType_INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO:
        return "GET_WHITELIST_ENTRY_INFO";
    default:
        return "UNKNOWN_REQUEST_TYPE";
    }
}

// Helper function to convert UniversalMessage_MessageFault_E enum to string
const char *message_fault_to_string(UniversalMessage_MessageFault_E fault)
{
    switch (fault)
    {
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_NONE:
        return "ERROR_NONE";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_BUSY:
        return "ERROR_BUSY";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_TIMEOUT:
        return "ERROR_TIMEOUT";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_UNKNOWN_KEY_ID:
        return "ERROR_UNKNOWN_KEY_ID";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INACTIVE_KEY:
        return "ERROR_INACTIVE_KEY";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INVALID_SIGNATURE:
        return "ERROR_INVALID_SIGNATURE";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INVALID_TOKEN_OR_COUNTER:
        return "ERROR_INVALID_TOKEN_OR_COUNTER";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INSUFFICIENT_PRIVILEGES:
        return "ERROR_INSUFFICIENT_PRIVILEGES";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INVALID_DOMAINS:
        return "ERROR_INVALID_DOMAINS";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INVALID_COMMAND:
        return "ERROR_INVALID_COMMAND";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_DECODING:
        return "ERROR_DECODING";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INTERNAL:
        return "ERROR_INTERNAL";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_WRONG_PERSONALIZATION:
        return "ERROR_WRONG_PERSONALIZATION";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_BAD_PARAMETER:
        return "ERROR_BAD_PARAMETER";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_KEYCHAIN_IS_FULL:
        return "ERROR_KEYCHAIN_IS_FULL";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INCORRECT_EPOCH:
        return "ERROR_INCORRECT_EPOCH";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_IV_INCORRECT_LENGTH:
        return "ERROR_IV_INCORRECT_LENGTH";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_TIME_EXPIRED:
        return "ERROR_TIME_EXPIRED";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_NOT_PROVISIONED_WITH_IDENTITY:
        return "ERROR_NOT_PROVISIONED_WITH_IDENTITY";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_COULD_NOT_HASH_METADATA:
        return "ERROR_COULD_NOT_HASH_METADATA";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_TIME_TO_LIVE_TOO_LONG:
        return "ERROR_TIME_TO_LIVE_TOO_LONG";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_REMOTE_ACCESS_DISABLED:
        return "ERROR_REMOTE_ACCESS_DISABLED";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_REMOTE_SERVICE_ACCESS_DISABLED:
        return "ERROR_REMOTE_SERVICE_ACCESS_DISABLED";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_COMMAND_REQUIRES_ACCOUNT_CREDENTIALS:
        return "ERROR_COMMAND_REQUIRES_ACCOUNT_CREDENTIALS";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_REQUEST_MTU_EXCEEDED:
        return "ERROR_REQUEST_MTU_EXCEEDED";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_RESPONSE_MTU_EXCEEDED:
        return "ERROR_RESPONSE_MTU_EXCEEDED";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_REPEATED_COUNTER:
        return "ERROR_REPEATED_COUNTER";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_INVALID_KEY_HANDLE:
        return "ERROR_INVALID_KEY_HANDLE";
    case UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_REQUIRES_RESPONSE_ENCRYPTION:
        return "ERROR_REQUIRES_RESPONSE_ENCRYPTION";
    default:
        return "UNKNOWN_FAULT";
    }
}

// Function to log UniversalMessage_MessageStatus
void log_message_status(const char *tag, const UniversalMessage_MessageStatus *status)
{
    ESP_LOGE(tag, "  MessageStatus:");
    ESP_LOGE(tag, "    operation_status: %s", operation_status_to_string(status->operation_status));
    ESP_LOGE(tag, "    signed_message_fault: %s", message_fault_to_string(status->signed_message_fault));
}

const char *vssec_signed_message_information_to_string(VCSEC_SignedMessage_information_E information)
{
    switch (information)
    {
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_NONE:
        return "NONE";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN:
        return "UNKNOWN";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST:
        return "NOT_ON_WHITELIST";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED:
        return "IV_SMALLER_THAN_EXPECTED";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN:
        return "INVALID_TOKEN";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID:
        return "TOKEN_AND_COUNTER_INVALID";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH:
        return "AES_DECRYPT_AUTH";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT:
        return "ECDSA_INPUT";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE:
        return "ECDSA_SIGNATURE";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START:
        return "LOCAL_ENTITY_START";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT:
        return "LOCAL_ENTITY_RESULT";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY:
        return "COULD_NOT_RETRIEVE_KEY";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN:
        return "COULD_NOT_RETRIEVE_TOKEN";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT:
        return "SIGNATURE_TOO_SHORT";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH:
        return "TOKEN_IS_INCORRECT_LENGTH";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH:
        return "INCORRECT_EPOCH";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH:
        return "IV_INCORRECT_LENGTH";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED:
        return "TIME_EXPIRED";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY:
        return "NOT_PROVISIONED_WITH_IDENTITY";
    case VCSEC_SignedMessage_information_E_SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA:
        return "COULD_NOT_HASH_METADATA";
    default:
        return "UNKNOWN_INFORMATION";
    }
}

const char *vssec_whitelist_operation_information_to_string(VCSEC_WhitelistOperation_information_E request_type)
{
    switch (request_type)
    {
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NONE:
        return "NONE";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR:
        return "UNDOCUMENTED_ERROR";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF:
        return "NO_PERMISSION_TO_REMOVE_ONESELF";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL:
        return "KEYFOB_SLOTS_FULL";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_WHITELIST_FULL:
        return "WHITELIST_FULL";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD:
        return "NO_PERMISSION_TO_ADD";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY:
        return "INVALID_PUBLIC_KEY";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE:
        return "NO_PERMISSION_TO_REMOVE";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS:
        return "NO_PERMISSION_TO_CHANGE_PERMISSIONS";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF:
        return "ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF:
        return "ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS:
        return "ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST:
        return "PUBLIC_KEY_NOT_ON_WHITELIST";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST:
        return "ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER:
        return "NOT_ALLOWED_TO_ADD_UNLESS_ON_READER";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE:
        return "FM_MODIFYING_OUTSIDE_OF_F_MODE";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY:
        return "FM_ATTEMPTING_TO_ADD_PERMANENT_KEY";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY:
        return "FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL:
        return "KEYCHAIN_WHILE_FS_FULL";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE:
        return "ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE:
        return "ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH:
        return "NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH";
    case VCSEC_WhitelistOperation_information_E_WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE:
        return "SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE";
    default:
        return "UNKNOWN_REQUEST_TYPE";
    }
}

// Function to convert UniversalMessage_Domain enum to string
const char *domain_to_string(UniversalMessage_Domain domain)
{
    switch (domain)
    {
    case UniversalMessage_Domain_DOMAIN_BROADCAST:
        return "DOMAIN_BROADCAST";
    case UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY:
        return "DOMAIN_VEHICLE_SECURITY";
    case UniversalMessage_Domain_DOMAIN_INFOTAINMENT:
        return "DOMAIN_INFOTAINMENT";
    default:
        return "UNKNOWN_DOMAIN";
    }
}

const char *generic_error_to_string(Errors_GenericError_E error)
{
    switch (error)
    {
    case Errors_GenericError_E_GENERICERROR_NONE:
        return "NONE";
    case Errors_GenericError_E_GENERICERROR_UNKNOWN:
        return "UNKNOWN";
    case Errors_GenericError_E_GENERICERROR_CLOSURES_OPEN:
        return "CLOSURES_OPEN";
    case Errors_GenericError_E_GENERICERROR_ALREADY_ON:
        return "ALREADY_ON";
    case Errors_GenericError_E_GENERICERROR_DISABLED_FOR_USER_COMMAND:
        return "DISABLED_FOR_USER_COMMAND";
    case Errors_GenericError_E_GENERICERROR_VEHICLE_NOT_IN_PARK:
        return "VEHICLE_NOT_IN_PARK";
    case Errors_GenericError_E_GENERICERROR_UNAUTHORIZED:
        return "UNAUTHORIZED";
    case Errors_GenericError_E_GENERICERROR_NOT_ALLOWED_OVER_TRANSPORT:
        return "NOT_ALLOWED_OVER_TRANSPORT";
    default:
        return "UNKNOWN_ERROR";
    }
}

void log_destination(const char *tag,
                     const char *direction,
                     const UniversalMessage_Destination *dest)
{
    ESP_LOGD(tag, "Destination: %s", direction);
    ESP_LOGD(tag, "  which_sub_destination: %d", dest->which_sub_destination);
    switch (dest->which_sub_destination)
    {
    case UniversalMessage_Destination_domain_tag:
        ESP_LOGD(tag, "  domain: %s", domain_to_string(dest->sub_destination.domain));
        break;
    case UniversalMessage_Destination_routing_address_tag:
        ESP_LOGD(tag, "  routing_address: %s", format_hex(dest->sub_destination.routing_address.bytes, dest->sub_destination.routing_address.size).c_str());
        break;
    default:
        ESP_LOGD(tag, "  unknown sub_destination");
    }
}

void log_session_info_request(const char *tag, const UniversalMessage_SessionInfoRequest *req)
{
    ESP_LOGD(tag, "  SessionInfoRequest:");
    ESP_LOGD(tag, "    public_key: %s", req->public_key.bytes);
    ESP_LOGD(tag, "    challenge: %s", req->challenge.bytes);
}

void log_session_info(const char *tag, const Signatures_SessionInfo *req)
{
    ESP_LOGD(tag, "SessionInfo:");
    ESP_LOGD(tag, "  counter: %" PRIu32, req->counter);
    ESP_LOGD(tag, "  publicKey: %s", format_hex(req->publicKey.bytes, req->publicKey.size).c_str());
    ESP_LOGD(tag, "  epoch: %s", format_hex(req->epoch, 16).c_str());
    ESP_LOGD(tag, "  clock_time: %" PRIu32, req->clock_time);
    ESP_LOGD(tag, "  status: %s", req->status == Signatures_Session_Info_Status_SESSION_INFO_STATUS_OK ? "OK" : "KEY_NOT_ON_WHITELIST");
}

void log_aes_gcm_personalized_signature_data(const char *tag, const Signatures_AES_GCM_Personalized_Signature_Data *data)
{
    ESP_LOGD(tag, "    AES_GCM_Personalized_Signature_Data:");
    ESP_LOGD(tag, "      epoch: %s", format_hex(data->epoch, 16).c_str());
    ESP_LOGD(tag, "      nonce: %s", format_hex(data->nonce, 12).c_str());
    ESP_LOGD(tag, "      counter: %" PRIu32, data->counter);
    ESP_LOGD(tag, "      expires_at: %" PRIu32, data->expires_at);
    ESP_LOGD(tag, "      tag: %s", format_hex(data->tag, 16).c_str());
}

void log_signature_data(const char *tag, const Signatures_SignatureData *sig)
{
    ESP_LOGD(tag, "  SignatureData:");
    ESP_LOGD(tag, "    has_signer_identity: %s", sig->has_signer_identity ? "true" : "false");
    if (sig->has_signer_identity)
    {
        ESP_LOGD(tag, "    signer_identity: ");
        ESP_LOGD(tag, "      public_key: %s", format_hex(sig->signer_identity.identity_type.public_key.bytes, sig->signer_identity.identity_type.public_key.size).c_str());
    }
    ESP_LOGD(tag, "    which_sig_type: %d", sig->which_sig_type);
    switch (sig->which_sig_type)
    {
    case Signatures_SignatureData_AES_GCM_Personalized_data_tag:
        log_aes_gcm_personalized_signature_data(tag, &sig->sig_type.AES_GCM_Personalized_data);
        break;
    case Signatures_SignatureData_session_info_tag_tag:
        ESP_LOGD(tag, "    session_info_tag: %s", format_hex(sig->sig_type.session_info_tag.tag.bytes, sig->sig_type.session_info_tag.tag.size).c_str());
        break;
    case Signatures_SignatureData_HMAC_Personalized_data_tag:
        ESP_LOGD(tag, "    HMAC_Personalized_data: ");
        ESP_LOGD(tag, "      epoch: %s", format_hex(sig->sig_type.HMAC_Personalized_data.epoch, 16).c_str());
        ESP_LOGD(tag, "      counter: %" PRIu32, sig->sig_type.HMAC_Personalized_data.counter);
        ESP_LOGD(tag, "      expires_at: %" PRIu32, sig->sig_type.HMAC_Personalized_data.expires_at);
        ESP_LOGD(tag, "      tag: %s", format_hex(sig->sig_type.HMAC_Personalized_data.tag, 16).c_str());
        break;
    case Signatures_SignatureData_AES_GCM_Response_data_tag:
        ESP_LOGD(tag, "    AES_GCM_Response_data: ");
        ESP_LOGD(tag, "      nonce: %s", format_hex(sig->sig_type.AES_GCM_Response_data.nonce, 12).c_str());
        ESP_LOGD(tag, "      counter: %" PRIu32, sig->sig_type.AES_GCM_Response_data.counter);
        ESP_LOGD(tag, "      tag: %s", format_hex(sig->sig_type.AES_GCM_Response_data.tag, 16).c_str());
        break;
    default:
        ESP_LOGD(tag, "    unknown sig_type");
    }
}

void log_information_request(const char *tag, const VCSEC_InformationRequest *msg)
{
    ESP_LOGD(tag, "VCSEC_InformationRequest:");
    ESP_LOGD(tag, "  which_request: %d", msg->which_key);

    ESP_LOGD(tag, "  informationRequestType: %s", information_request_type_to_string(msg->informationRequestType));
    ESP_LOGD(tag, "  publicKeySHA1: %s", format_hex(msg->key.keyId.publicKeySHA1.bytes, msg->key.keyId.publicKeySHA1.size).c_str());
    ESP_LOGD(tag, "  publicKey: %s", format_hex(msg->key.publicKey.bytes, msg->key.publicKey.size).c_str());
    ESP_LOGD(tag, "  publicKeySHA1: %" PRIu32, msg->key.slot);
}

void log_routable_message(const char *tag, const UniversalMessage_RoutableMessage *msg)
{
    ESP_LOGD(tag, "UniversalMessage_RoutableMessage:");
    ESP_LOGD(tag, "  has_to_destination: %s", msg->has_to_destination ? "true" : "false");
    if (msg->has_to_destination)
    {
        log_destination(tag, "to_destination", &msg->to_destination);
    }

    ESP_LOGD(tag, "  has_from_destination: %s", msg->has_from_destination ? "true" : "false");
    if (msg->has_from_destination)
    {
        log_destination(tag, "from_destination", &msg->from_destination);
    }

    ESP_LOGD(tag, "  which_payload: %d", msg->which_payload);
    switch (msg->which_payload)
    {
    case UniversalMessage_RoutableMessage_protobuf_message_as_bytes_tag:
        ESP_LOGD(tag, "  payload: protobuf_message_as_bytes (callback)");
        // log byte array as string
        ESP_LOGD(tag, "    payload: %s", format_hex(msg->payload.protobuf_message_as_bytes.bytes, msg->payload.protobuf_message_as_bytes.size).c_str());
        break;
    case UniversalMessage_RoutableMessage_session_info_request_tag:
        ESP_LOGD(tag, "  payload: session_info_request");
        log_session_info_request(tag, &msg->payload.session_info_request);
        break;
    case UniversalMessage_RoutableMessage_session_info_tag:
        ESP_LOGD(tag, "  payload: session_info (callback)");
        // log byte array as string
        ESP_LOGD(tag, "    payload: %s", format_hex(msg->payload.session_info.bytes, msg->payload.session_info.size).c_str());
        break;
    default:
        ESP_LOGD(tag, "  payload: unknown");
        break;
    }

    ESP_LOGD(tag, "  has_signedMessageStatus: %s", msg->has_signedMessageStatus ? "true" : "false");
    if (msg->has_signedMessageStatus)
    {
        log_message_status(tag, &msg->signedMessageStatus);
    }

    ESP_LOGD(tag, "  which_sub_sigData: %d", msg->which_sub_sigData);
    switch(msg->which_sub_sigData)
    {
        case UniversalMessage_RoutableMessage_signature_data_tag:
            log_signature_data(tag, &msg->sub_sigData.signature_data);
            break;
        default:
            ESP_LOGD(tag, "  sub_sigData: unknown");
            break;
    }

    switch (msg->flags)
    {
        case UniversalMessage_Flags_FLAG_USER_COMMAND:
            ESP_LOGD(tag, "  flags: FLAG_USER_COMMAND");
            break;
        case UniversalMessage_Flags_FLAG_ENCRYPT_RESPONSE:
            ESP_LOGD(tag, "  flags: FLAG_ENCRYPT_RESPONSE");
            break;
        default:
            ESP_LOGD(tag, "  flags: %" PRIu32, msg->flags);
            break;
    }

    if (msg->request_uuid.size > 0)
    {
        ESP_LOGD(tag, "  request_uuid: %s", format_hex(msg->request_uuid.bytes, msg->request_uuid.size).c_str());
    }
    if (msg->uuid.size > 0)
    {
        ESP_LOGD(tag, "  uuid: %s", format_hex(msg->uuid.bytes, msg->uuid.size).c_str());
    }
    ESP_LOGD(tag, "[Done logging routable message]");
}

const char *closure_state_to_string(VCSEC_ClosureState_E state)
{
    switch (state)
    {
    case VCSEC_ClosureState_E_CLOSURESTATE_CLOSED:
        return "CLOSED";
    case VCSEC_ClosureState_E_CLOSURESTATE_OPEN:
        return "OPEN";
    case VCSEC_ClosureState_E_CLOSURESTATE_AJAR:
        return "AJAR";
    case VCSEC_ClosureState_E_CLOSURESTATE_UNKNOWN:
        return "UNKNOWN";
    case VCSEC_ClosureState_E_CLOSURESTATE_FAILED_UNLATCH:
        return "FAILED_UNLATCH";
    case VCSEC_ClosureState_E_CLOSURESTATE_OPENING:
        return "OPENING";
    case VCSEC_ClosureState_E_CLOSURESTATE_CLOSING:
        return "CLOSING";
    default:
        return "UNKNOWN_STATE";
    }
}

const char *vehicle_lock_state_to_string(VCSEC_VehicleLockState_E state)
{
    switch (state)
    {
    case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_UNLOCKED:
        return "UNLOCKED";
    case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_LOCKED:
        return "LOCKED";
    case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_INTERNAL_LOCKED:
        return "INTERNAL_LOCKED";
    case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_SELECTIVE_UNLOCKED:
        return "SELECTIVE_UNLOCKED";
    default:
        return "UNKNOWN_STATE";
    }
}

const char *vehicle_sleep_status_to_string(VCSEC_VehicleSleepStatus_E state)
{
    switch (state)
    {
    case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_UNKNOWN:
        return "UNKNOWN";
    case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_AWAKE:
        return "AWAKE";
    case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_ASLEEP:
        return "ASLEEP";
    default:
        return "UNKNOWN_STATE";
    }
}

const char *user_presence_to_string(VCSEC_UserPresence_E state)
{
    switch (state)
    {
    case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_UNKNOWN:
        return "UNKNOWN";
    case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_NOT_PRESENT:
        return "NOT_PRESENT";
    case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_PRESENT:
        return "PRESENT";
    default:
        return "UNKNOWN_STATE";
    }
}

void log_vehicle_status(const char *tag, const VCSEC_VehicleStatus *msg)
{
    ESP_LOGD(tag, "VCSEC_VehicleStatus:");
    ESP_LOGD(tag, "  has_closureStatuses: %s", msg->has_closureStatuses ? "true" : "false");
    if (msg->has_closureStatuses)
    {
        ESP_LOGD(tag, "  closureStatuses:");
        ESP_LOGD(tag, "    frontDriverDoor: %s", closure_state_to_string(msg->closureStatuses.frontDriverDoor));
        ESP_LOGD(tag, "    frontPassengerDoor: %s", closure_state_to_string(msg->closureStatuses.frontPassengerDoor));
        ESP_LOGD(tag, "    rearDriverDoor: %s", closure_state_to_string(msg->closureStatuses.rearDriverDoor));
        ESP_LOGD(tag, "    rearPassengerDoor: %s", closure_state_to_string(msg->closureStatuses.rearPassengerDoor));
        ESP_LOGD(tag, "    rearTrunk: %s", closure_state_to_string(msg->closureStatuses.rearTrunk));
        ESP_LOGD(tag, "    frontTrunk: %s", closure_state_to_string(msg->closureStatuses.frontTrunk));
        ESP_LOGD(tag, "    chargePort: %s", closure_state_to_string(msg->closureStatuses.chargePort));
    }
    ESP_LOGD(tag, "  vehicleLockState: %s", vehicle_lock_state_to_string(msg->vehicleLockState));
    ESP_LOGD(tag, "  vehicleSleepStatus: %s", vehicle_sleep_status_to_string(msg->vehicleSleepStatus));
    ESP_LOGD(tag, "  userPresence: %s", user_presence_to_string(msg->userPresence));
}

void log_vssec_signed_message_status(const char *tag, const VCSEC_SignedMessage_status *status)
{
    ESP_LOGI(tag, "  SignedMessage status:");
    ESP_LOGI(tag, "    counter: %" PRIu32, status->counter);
    ESP_LOGI(tag, "    signed_message_information: %s", vssec_signed_message_information_to_string(status->signedMessageInformation));
}

void log_vssec_whitelist_operation_status(const char *tag, const VCSEC_WhitelistOperation_status *status)
{
    ESP_LOGI(tag, "  WhitelistOperation status:");
    // has_signerOfOperation;
    if (status->has_signerOfOperation)
    {
        ESP_LOGD(tag, "    signerOfOperation:");
        ESP_LOGD(tag, "      public_key: %s", format_hex(status->signerOfOperation.publicKeySHA1.bytes, status->signerOfOperation.publicKeySHA1.size).c_str());
    }
    ESP_LOGI(tag, "    operation_status: %s", vcsec_operation_status_to_string(status->operationStatus));
    ESP_LOGI(tag, "    information: %s", vssec_whitelist_operation_information_to_string(status->whitelistOperationInformation));
}

void log_vcsec_command_status(const char *tag, const VCSEC_CommandStatus *msg)
{
    ESP_LOGI(tag, "VCSEC_CommandStatus:");
    ESP_LOGI(tag, "  commandStatus: %s", vcsec_operation_status_to_string(msg->operationStatus));

    ESP_LOGI(tag, "  which_sub_message: %d", msg->which_sub_message);
    switch (msg->which_sub_message)
    {
    case VCSEC_CommandStatus_signedMessageStatus_tag:
        log_vssec_signed_message_status(tag, &msg->sub_message.signedMessageStatus);
        break;
    case VCSEC_CommandStatus_whitelistOperationStatus_tag:
        log_vssec_whitelist_operation_status(tag, &msg->sub_message.whitelistOperationStatus);
        break;
    default:
        ESP_LOGD(tag, "  unknown sub_message");
    }
}

void carserver_result_reason_to_string(const char *tag, const CarServer_ResultReason *reason)
{
    ESP_LOGI(tag, "  ResultReason:");
    ESP_LOGI(tag, "    which_reason: %d", reason->which_reason);
    switch (reason->which_reason)
    {
    case CarServer_ResultReason_plain_text_tag:
        ESP_LOGI(tag, "    plain_text: %s", reason->reason.plain_text);
        break;
    default:
        ESP_LOGD(tag, "    unknown reason");
    }
}

const char *carserver_operation_status_to_string(CarServer_OperationStatus_E status)
{
    switch (status)
    {
    case CarServer_OperationStatus_E_OPERATIONSTATUS_OK:
        return "OK";
    case CarServer_OperationStatus_E_OPERATIONSTATUS_ERROR:
        return "ERROR";
    default:
        return "UNKNOWN_STATUS";
    }
}

void logChargingState(const char *tag, const CarServer_ChargeState_ChargingState& state) {
    const char* stateStr = "Unknown";
    switch (state.which_type) {
        case CarServer_ChargeState_ChargingState_Unknown_tag:
            stateStr = "Unknown";
            break;
        case CarServer_ChargeState_ChargingState_Disconnected_tag:
            stateStr = "Disconnected";
            break;
        case CarServer_ChargeState_ChargingState_NoPower_tag:
            stateStr = "NoPower";
            break;
        case CarServer_ChargeState_ChargingState_Starting_tag:
            stateStr = "Starting";
            break;
        case CarServer_ChargeState_ChargingState_Charging_tag:
            stateStr = "Charging";
            break;
        case CarServer_ChargeState_ChargingState_Complete_tag:
            stateStr = "Complete";
            break;
        case CarServer_ChargeState_ChargingState_Stopped_tag:
            stateStr = "Stopped";
            break;
        case CarServer_ChargeState_ChargingState_Calibrating_tag:
            stateStr = "Calibrating";
            break;
    }
    ESP_LOGD(tag, "Charging State: %s", stateStr);
}

void logChargeState(const char *tag, const CarServer_ChargeState& charge_state) {
    ESP_LOGD(tag, "=== Charge State ===");
    
    if (charge_state.has_charging_state) {
        logChargingState(tag, charge_state.charging_state);
    }
    
    if (charge_state.which_optional_battery_level) {
        ESP_LOGD(tag, "Battery Level: %ld%%", charge_state.optional_battery_level.battery_level);
    }
    
    if (charge_state.which_optional_battery_range) {
        ESP_LOGD(tag, "Battery Range: %.1f", charge_state.optional_battery_range.battery_range);
    }
    
    if (charge_state.which_optional_charger_power) {
        ESP_LOGD(tag, "Charger Power: %ld", charge_state.optional_charger_power.charger_power);
    }
    
    if (charge_state.which_optional_charge_rate_mph) {
        ESP_LOGD(tag, "Charge Rate: %ld mph", charge_state.optional_charge_rate_mph.charge_rate_mph);
    }
    
    if (charge_state.which_optional_minutes_to_full_charge) {
        ESP_LOGD(tag, "Minutes to Full: %ld", charge_state.optional_minutes_to_full_charge.minutes_to_full_charge);
    }
}

void log_carserver_response(const char *tag, const CarServer_Response *msg)
{
    if (!msg) {
        ESP_LOGD(tag, "CarServerResponse: NULL");
        return;
    }

    ESP_LOGD(tag, "CarServerResponse:");
    ESP_LOGD(tag, "  has_actionStatus: %d", msg->has_actionStatus);
    ESP_LOGD(tag, "  which_response_msg: %d", msg->which_response_msg);

    if (msg->has_actionStatus)
    {
        ESP_LOGD(tag, "  ActionStatus:");
        ESP_LOGD(tag, "    result: %s", carserver_operation_status_to_string(msg->actionStatus.result));
        if (msg->actionStatus.has_result_reason)
        {
            switch (msg->actionStatus.result_reason.which_reason)
            {
            case CarServer_ResultReason_plain_text_tag:
                ESP_LOGD(tag, "    reason: %s", msg->actionStatus.result_reason.reason.plain_text);
                break;
            default:
                ESP_LOGD(tag, "    unknown reason");
                break;
            }
        }
    }

    switch (msg->which_response_msg)
    {
    case CarServer_Response_vehicleData_tag:
        ESP_LOGD(tag, "  vehicleData:");
        
        // Add this before all your has_X checks
        ESP_LOGD(tag, "    VehicleData size: %zu", sizeof(msg->response_msg.vehicleData));

        if (msg->response_msg.vehicleData.has_charge_state) {
            ESP_LOGD(tag, "Has Charge State: true");
            // logChargeState(tag, msg->response_msg.vehicleData.charge_state);
        }
        
        if (msg->response_msg.vehicleData.has_climate_state) {
            ESP_LOGD(tag, "Has Climate State: true");
            // Add climate state logging if needed
        }
        
        if (msg->response_msg.vehicleData.has_drive_state) {
            ESP_LOGD(tag, "Has Drive State: true");
            // Add drive state logging if needed
        }
        
        if (msg->response_msg.vehicleData.has_location_state) {
            ESP_LOGD(tag, "Has Location State: true");
            // Add location state logging if needed
        }

        if (msg->response_msg.vehicleData.has_closures_state) {
            ESP_LOGD(tag, "Has Closures State: true");
            // Add closures state logging if needed
        }

        if (msg->response_msg.vehicleData.has_charge_schedule_state) {
            ESP_LOGD(tag, "Has Charge Schedule State: true");
            // Add charge schedule state logging if needed
        }

        if (msg->response_msg.vehicleData.has_preconditioning_schedule_state) {
            ESP_LOGD(tag, "Has Preconditioning Schedule State: true");
            // Add preconditioning schedule state logging if needed
        }

        if (msg->response_msg.vehicleData.has_tire_pressure_state) {
            ESP_LOGD(tag, "Has Tire Pressure State: true");
            // Add tire pressure state logging if needed
        }

        if (msg->response_msg.vehicleData.has_media_state) {
            ESP_LOGD(tag, "Has Media State: true");
            // Add media state logging if needed
        }

        if (msg->response_msg.vehicleData.has_media_detail_state) {
            ESP_LOGD(tag, "Has Media Detail State: true");
            // Add media detail state logging if needed
        }

        if (msg->response_msg.vehicleData.has_software_update_state) {
            ESP_LOGD(tag, "Has Software Update State: true");
            // Add software update state logging if needed
        }

        if (msg->response_msg.vehicleData.has_parental_controls_state) {
            ESP_LOGD(tag, "Has Parental Controls State: true");
            // Add parental controls state logging if needed
        }

        break;
    case CarServer_Response_getSessionInfoResponse_tag:
        ESP_LOGD(tag, "  getSessionInfoResponse:");
        log_session_info(tag, &msg->response_msg.getSessionInfoResponse);
        break;
    case CarServer_Response_getNearbyChargingSites_tag:
        ESP_LOGD(tag, "  getNearbyChargingSites:");
        break;
    case CarServer_Response_ping_tag:
        ESP_LOGD(tag, "  ping:");
        ESP_LOGD(tag, "    ping: %ld", msg->response_msg.ping.ping_id);
        break;
    default:
        // do nothing
        break;
    }
}



================================================
FILE: components/tesla_ble_vehicle/log.h
================================================
#pragma once

#include <car_server.pb.h>
#include <signatures.pb.h>
#include <universal_message.pb.h>
#include <vcsec.pb.h>

// Main logging function for UniversalMessage_RoutableMessage
// Helper functions for nested structures
const char *domain_to_string(UniversalMessage_Domain domain);
const char *information_request_type_to_string(VCSEC_InformationRequestType request_type);
const char *message_fault_to_string(UniversalMessage_MessageFault_E fault);
const char *operation_status_to_string(UniversalMessage_OperationStatus_E status);
const char *vcsec_operation_status_to_string(VCSEC_OperationStatus_E status);
const char *vssec_signed_message_information_to_string(VCSEC_SignedMessage_information_E information);
const char *closure_state_to_string(VCSEC_ClosureState_E state);
const char *vehicle_lock_state_to_string(VCSEC_VehicleLockState_E state);
const char *vehicle_sleep_status_to_string(VCSEC_VehicleSleepStatus_E state);
const char *user_presence_to_string(VCSEC_UserPresence_E state);
const char *generic_error_to_string(Errors_GenericError_E error);
const char *carserver_operation_status_to_string(CarServer_OperationStatus_E status);
void log_aes_gcm_personalized_signature_data(const char *tag, const Signatures_AES_GCM_Personalized_Signature_Data *data);
void log_destination(const char *tag, const char *prefix, const UniversalMessage_Destination *dest);
void log_information_request(const char *tag, const VCSEC_InformationRequest *msg);
void log_message_status(const char *tag, const UniversalMessage_MessageStatus *status);
void log_routable_message(const char *tag, const UniversalMessage_RoutableMessage *msg);
void log_session_info_request(const char *tag, const UniversalMessage_SessionInfoRequest *req);
void log_session_info(const char *tag, const Signatures_SessionInfo *req);
void log_signature_data(const char *tag, const Signatures_SignatureData *sig);
void log_vehicle_status(const char *tag, const VCSEC_VehicleStatus *msg);
void log_vssec_signed_message_status(const char *tag, const VCSEC_SignedMessage_status *status);
void log_vssec_whitelist_operation_status(const char *tag, const VCSEC_WhitelistOperation_status *status);
void log_vcsec_command_status(const char *tag, const VCSEC_CommandStatus *msg);
void log_carserver_response(const char *tag, const CarServer_Response *msg);



================================================
FILE: components/tesla_ble_vehicle/message_handler.cpp
================================================
#include "message_handler.h"
#include "tesla_ble_vehicle.h"
#include <client.h>
#include "log.h"
#include <esphome/core/helpers.h>

namespace esphome {
namespace tesla_ble_vehicle {

MessageHandler::MessageHandler(TeslaBLEVehicle* parent)
    : parent_(parent) {}

void MessageHandler::add_response(const UniversalMessage_RoutableMessage& message) {
    response_queue_.push(message);
    ESP_LOGV(MESSAGE_HANDLER_TAG, "Added message to response queue (queue size: %zu)", response_queue_.size());
}

void MessageHandler::process_response_queue() {
    if (response_queue_.empty()) {
        return;
    }

    ESP_LOGV(MESSAGE_HANDLER_TAG, "Processing response queue (size: %zu)", response_queue_.size());
    
    UniversalMessage_RoutableMessage message = response_queue_.front();
    response_queue_.pop();

    handle_universal_message(message);
}

void MessageHandler::handle_universal_message(const UniversalMessage_RoutableMessage& message) {
    if (!validate_message(message)) {
        // ESP_LOGV(MESSAGE_HANDLER_TAG, "Dropping invalid message");
        return;
    }

    log_message_details(message);

    // Handle session info updates first
    if (message.which_payload == UniversalMessage_RoutableMessage_session_info_tag) {
        UniversalMessage_Domain domain = message.from_destination.sub_destination.domain;
        handle_session_info(message, domain);
        return;
    }

    // Handle signed message status
    if (message.has_signedMessageStatus) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Received signed message status");
        log_message_status(MESSAGE_HANDLER_TAG, &message.signedMessageStatus);
        
        if (message.signedMessageStatus.operation_status == UniversalMessage_OperationStatus_E_OPERATIONSTATUS_ERROR) {
            // Reset authentication for domain
            UniversalMessage_Domain domain = message.from_destination.sub_destination.domain;
            auto* session_manager = parent_->get_session_manager();
            if (session_manager) {
                session_manager->invalidate_session(domain);
            }
            
            // Update command state
            update_command_state_on_response(message);
            return;
        }
    }

    // Route message based on source domain
    switch (message.from_destination.which_sub_destination) {
        case UniversalMessage_Destination_domain_tag:
            switch (message.from_destination.sub_destination.domain) {
                case UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY:
                    handle_vcsec_message(message);
                    break;
                case UniversalMessage_Domain_DOMAIN_INFOTAINMENT:
                    handle_carserver_message(message);
                    break;
                default:
                    ESP_LOGD(MESSAGE_HANDLER_TAG, "Message from unknown domain: %s", 
                             domain_to_string(message.from_destination.sub_destination.domain));
                    break;
            }
            break;
            
        case UniversalMessage_Destination_routing_address_tag:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Received message from routing address");
            break;
            
        default:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Message from unknown destination type: %d", 
                     message.from_destination.which_sub_destination);
            break;
    }
}

void MessageHandler::handle_vcsec_message(const UniversalMessage_RoutableMessage& message) {
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing VCSEC message");
    
    auto* session_manager = parent_->get_session_manager();
    if (!session_manager) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Session manager not available");
        return;
    }
    
    auto* client = session_manager->get_client();
    if (!client) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Tesla client not available");
        return;
    }
    
    VCSEC_FromVCSECMessage vcsec_message = VCSEC_FromVCSECMessage_init_default;
    int result = client->parseFromVCSECMessage(
        const_cast<UniversalMessage_RoutableMessage_protobuf_message_as_bytes_t*>(&message.payload.protobuf_message_as_bytes), &vcsec_message);
    
    if (result != 0) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Failed to parse VCSEC message: %d", result);
        return;
    }
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Parsed VCSEC message successfully");

    switch (vcsec_message.which_sub_message) {
        case VCSEC_FromVCSECMessage_vehicleStatus_tag:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Received vehicle status");
            handle_vehicle_status(vcsec_message.sub_message.vehicleStatus);
            break;
            
        case VCSEC_FromVCSECMessage_commandStatus_tag:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Received VCSEC command status");
            log_vcsec_command_status(MESSAGE_HANDLER_TAG, &vcsec_message.sub_message.commandStatus);
            update_command_state_on_response(message);
            break;
            
        case VCSEC_FromVCSECMessage_whitelistInfo_tag:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Received whitelist info");
            // Could update pairing status here
            break;
            
        case VCSEC_FromVCSECMessage_whitelistEntryInfo_tag:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Received whitelist entry info");
            break;
            
        case VCSEC_FromVCSECMessage_nominalError_tag:
            ESP_LOGE(MESSAGE_HANDLER_TAG, "Received nominal error: %s", 
                     generic_error_to_string(vcsec_message.sub_message.nominalError.genericError));
            break;
            
        default:
            // Probably information request with public key
            VCSEC_InformationRequest info_message = VCSEC_InformationRequest_init_default;
            result = client->parseVCSECInformationRequest(
                const_cast<UniversalMessage_RoutableMessage_protobuf_message_as_bytes_t*>(&message.payload.protobuf_message_as_bytes), &info_message);
            
            if (result == 0) {
                ESP_LOGD(MESSAGE_HANDLER_TAG, "Parsed VCSEC InformationRequest message");
                ESP_LOGD(MESSAGE_HANDLER_TAG, "InformationRequest public key: %s", 
                         format_hex(info_message.key.publicKey.bytes, info_message.key.publicKey.size).c_str());
            } else {
                ESP_LOGW(MESSAGE_HANDLER_TAG, "Unknown VCSEC message type");
            }
            break;
    }
}

void MessageHandler::handle_carserver_message(const UniversalMessage_RoutableMessage& message) {
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing CarServer message");
    
    auto* session_manager = parent_->get_session_manager();
    if (!session_manager) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Session manager not available");
        return;
    }
    
    auto* client = session_manager->get_client();
    if (!client) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Tesla client not available");
        return;
    }
    
    CarServer_Response carserver_response = CarServer_Response_init_default;
    
    // Extract signature data and fault information from the message
    const Signatures_SignatureData* sig_data = nullptr;
    UniversalMessage_MessageFault_E fault = UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_NONE;
    
    if (message.which_sub_sigData == UniversalMessage_RoutableMessage_signature_data_tag) {
        sig_data = &message.sub_sigData.signature_data;
    }
    
    if (message.has_signedMessageStatus) {
        fault = message.signedMessageStatus.signed_message_fault;
    }
    
    // Log if there's a message fault
    if (fault != UniversalMessage_MessageFault_E_MESSAGEFAULT_ERROR_NONE) {
        ESP_LOGW(MESSAGE_HANDLER_TAG, "Message fault detected: %s", message_fault_to_string(fault));
    }
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Starting parsePayloadCarServerResponse...");
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Payload size: %d bytes", message.payload.protobuf_message_as_bytes.size);
    
    int result = session_manager->get_client()->parsePayloadCarServerResponse(
        const_cast<UniversalMessage_RoutableMessage_protobuf_message_as_bytes_t*>(&message.payload.protobuf_message_as_bytes), const_cast<Signatures_SignatureData*>(sig_data), message.which_sub_sigData, fault, &carserver_response);
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "parsePayloadCarServerResponse completed with return_code: %d", result);
    
    if (result != 0) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Failed to parse CarServer response: %d", result);
        update_command_state_on_response(message);
        return;
    }
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Parsed CarServer.Response successfully");
    log_carserver_response(MESSAGE_HANDLER_TAG, &carserver_response);
    
    // Handle the response
    handle_carserver_response(carserver_response);
    
    // Check for action status and update command state
    if (carserver_response.has_actionStatus) {
        auto* command_manager = parent_->get_command_manager();
        if (command_manager && command_manager->has_pending_commands()) {
            auto* current_command = command_manager->get_current_command();
            if (current_command && current_command->domain == UniversalMessage_Domain_DOMAIN_INFOTAINMENT) {
                switch (carserver_response.actionStatus.result) {
                    case CarServer_OperationStatus_E_OPERATIONSTATUS_OK:
                        {
                            uint32_t duration = millis() - current_command->started_at;
                            ESP_LOGV(MESSAGE_HANDLER_TAG, "[%s] Command handled successfully in %u ms", 
                                     current_command->execute_name.c_str(), duration);
                        }
                        command_manager->mark_command_completed();
                        break;
                        
                    case CarServer_OperationStatus_E_OPERATIONSTATUS_ERROR:
                        ESP_LOGE(MESSAGE_HANDLER_TAG, "[%s] Command failed with error", 
                                 current_command->execute_name.c_str());
                        command_manager->mark_command_failed("CarServer error");
                        break;
                        
                    default:
                        ESP_LOGD(MESSAGE_HANDLER_TAG, "[%s] Command status: %d", 
                                 current_command->execute_name.c_str(), carserver_response.actionStatus.result);
                        break;
                }
            }
        }
    } else {
        // No action status - could be a data request response or missing status
        // Only mark as completed if we have a pending infotainment command
        auto* command_manager = parent_->get_command_manager();
        if (command_manager && command_manager->has_pending_commands()) {
            auto* current_command = command_manager->get_current_command();
            if (current_command && current_command->domain == UniversalMessage_Domain_DOMAIN_INFOTAINMENT) {
                ESP_LOGD(MESSAGE_HANDLER_TAG, "[%s] No action status received, assuming data request success", 
                         current_command->execute_name.c_str());
                command_manager->mark_command_completed();
            } else {
                // Not our command, just update state normally
                update_command_state_on_response(message);
            }
        } else {
            // No pending commands, just update state normally
            update_command_state_on_response(message);
        }
    }
}

void MessageHandler::handle_session_info(const UniversalMessage_RoutableMessage& message, UniversalMessage_Domain domain) {
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Handling session info for %s", domain_to_string(domain));
    
    auto* session_manager = parent_->get_session_manager();
    if (!session_manager) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Session manager not available");
        return;
    }
    
    // Parse session info
    Signatures_SessionInfo session_info = Signatures_SessionInfo_init_default;
    int result = session_manager->get_client()->parsePayloadSessionInfo(const_cast<UniversalMessage_RoutableMessage_session_info_t*>(&message.payload.session_info), &session_info);
    
    if (result != 0) {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Failed to parse session info for %s: %d", domain_to_string(domain), result);
        
        // Notify command manager of auth failure
        auto* command_manager = parent_->get_command_manager();
        if (command_manager) {
            command_manager->handle_authentication_response(domain, false);
        }
        return;
    }
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Parsed session info successfully");
    
    // Check session status
    switch (session_info.status) {
        case Signatures_Session_Info_Status_SESSION_INFO_STATUS_OK:
            ESP_LOGD(MESSAGE_HANDLER_TAG, "Session is valid: key paired with vehicle");
            break;
        case Signatures_Session_Info_Status_SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST:
            ESP_LOGE(MESSAGE_HANDLER_TAG, "Session is invalid: Key not on whitelist");
            
            // Notify command manager of auth failure
            auto* command_manager = parent_->get_command_manager();
            if (command_manager) {
                command_manager->handle_authentication_response(domain, false);
            }
            return;
    }
    
    // Update session
    int update_result = session_manager->update_session(session_info, domain);
    if (update_result == 0) {
        ESP_LOGI(MESSAGE_HANDLER_TAG, "Updated session info for %s", domain_to_string(domain));
        
        // Notify command manager of successful auth
        auto* command_manager = parent_->get_command_manager();
        if (command_manager) {
            command_manager->handle_authentication_response(domain, true);
        }
    } else {
        ESP_LOGE(MESSAGE_HANDLER_TAG, "Failed to update session info for %s: %d", domain_to_string(domain), update_result);
        
        // Notify command manager of auth failure
        auto* command_manager = parent_->get_command_manager();
        if (command_manager) {
            command_manager->handle_authentication_response(domain, false);
        }
    }
}

void MessageHandler::handle_vehicle_status(const VCSEC_VehicleStatus& status) {
    log_vehicle_status(MESSAGE_HANDLER_TAG, &status);
    
    auto* state_manager = parent_->get_state_manager();
    if (state_manager) {
        state_manager->update_vehicle_status(status);
    }
    
    update_command_state_on_response_with_status(status);
}

void MessageHandler::handle_carserver_response(const CarServer_Response& response) {
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Handling CarServer response (type: %d)", response.which_response_msg);
    
    auto* state_manager = parent_->get_state_manager();
    if (!state_manager) {
        ESP_LOGW(MESSAGE_HANDLER_TAG, "State manager not available");
        return;
    }
    
    // Check if we have vehicle data response
    if (response.which_response_msg == CarServer_Response_vehicleData_tag) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing vehicle data response");
        process_vehicle_data(response.response_msg.vehicleData);
    } else {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Non-vehicle-data response received");
    }
}

void MessageHandler::process_vehicle_data(const CarServer_VehicleData& vehicle_data) {
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing vehicle data...");
    
    auto* state_manager = parent_->get_state_manager();
    if (!state_manager) {
        return;
    }
    
    // Process charge state data
    if (vehicle_data.has_charge_state) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing charge state data");
        state_manager->update_charge_state(vehicle_data.charge_state);
    }
    
    // Process climate state data if present
    if (vehicle_data.has_climate_state) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing climate state data");
        state_manager->update_climate_state(vehicle_data.climate_state);
    }
    
    // Process drive state data if present
    if (vehicle_data.has_drive_state) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing drive state data");
        state_manager->update_drive_state(vehicle_data.drive_state);
    }
    
    // Process location state data if present
    if (vehicle_data.has_location_state) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing location state data");
        // Future implementation
    }
    
    // Process closures state data if present
    if (vehicle_data.has_closures_state) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Processing closures state data");
        // Future implementation
    }
    
    ESP_LOGD(MESSAGE_HANDLER_TAG, "Vehicle data processing completed");
}

bool MessageHandler::validate_message(const UniversalMessage_RoutableMessage& message) {
    if (!message.has_from_destination) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "Dropping message with missing source");
        return false;
    }
    
    if (message.request_uuid.size != 0 && message.request_uuid.size != 16) {
        ESP_LOGW(MESSAGE_HANDLER_TAG, "Dropping message with invalid request UUID length");
        return false;
    }
    
    if (!message.has_to_destination) {
        ESP_LOGV(MESSAGE_HANDLER_TAG, "Dropping message with missing destination");
        return false;
    }
    
    switch (message.to_destination.which_sub_destination) {
        case UniversalMessage_Destination_domain_tag:
            // This is normal for domain messages
            break;
        case UniversalMessage_Destination_routing_address_tag:
            if (message.to_destination.sub_destination.routing_address.size != 16) {
                ESP_LOGW(MESSAGE_HANDLER_TAG, "Dropping message with invalid address length");
                return false;
            }
            break;
        default:
            ESP_LOGW(MESSAGE_HANDLER_TAG, "Dropping message with unrecognized destination type: %d", 
                     message.to_destination.which_sub_destination);
            return false;
    }
    
    return true;
}

void MessageHandler::log_message_details(const UniversalMessage_RoutableMessage& message) {
    std::string request_uuid_hex = format_hex(message.request_uuid.bytes, message.request_uuid.size);
    ESP_LOGV(MESSAGE_HANDLER_TAG, "Processing message [%s]", request_uuid_hex.c_str());
    
    if (message.has_from_destination && message.from_destination.which_sub_destination == UniversalMessage_Destination_domain_tag) {
        ESP_LOGV(MESSAGE_HANDLER_TAG, "  From domain: %s", 
                 domain_to_string(message.from_destination.sub_destination.domain));
    }
}

void MessageHandler::update_command_state_on_response(const UniversalMessage_RoutableMessage& message) {
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager || !command_manager->has_pending_commands()) {
        return;
    }
    
    auto* current_command = command_manager->get_current_command();
    if (!current_command) {
        return;
    }
    
    // Only mark command as completed if it's waiting for a response
    if (current_command->state == BLECommandState::WAITING_FOR_RESPONSE) {
        ESP_LOGD(MESSAGE_HANDLER_TAG, "[%s] Command response received", 
                 current_command->execute_name.c_str());
        command_manager->mark_command_completed();
    } else {
        ESP_LOGV(MESSAGE_HANDLER_TAG, "[%s] Received response but command is in state %d", 
                 current_command->execute_name.c_str(), static_cast<int>(current_command->state));
    }
}

void MessageHandler::update_command_state_on_response_with_status(const VCSEC_VehicleStatus& status) {
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager || !command_manager->has_pending_commands()) {
        return;
    }
    
    auto* current_command = command_manager->get_current_command();
    if (!current_command) {
        return;
    }
    
    // Handle wake-related commands
    if (current_command->state == BLECommandState::WAITING_FOR_WAKE_RESPONSE || 
        current_command->execute_name.find("wake") != std::string::npos) {
        
        // Check if vehicle is awake using multiple indicators
        bool is_awake = false;
        
        // Method 1: Check vehicleSleepStatus directly
        if (status.vehicleSleepStatus == VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_AWAKE) {
            is_awake = true;
        }
        
        // Method 2: Check state manager
        auto* state_manager = parent_->get_state_manager();
        if (state_manager && !state_manager->is_asleep()) {
            is_awake = true;
        }
        
        // Method 3: If we're getting detailed closure status, vehicle is awake
        if (status.has_closureStatuses) {
            ESP_LOGD(MESSAGE_HANDLER_TAG, "[%s] Received detailed vehicle status, assuming awake", 
                     current_command->execute_name.c_str());
            is_awake = true;
        }
        
        if (is_awake) {
            uint32_t duration = millis() - current_command->started_at;
            ESP_LOGI(MESSAGE_HANDLER_TAG, "[%s] Vehicle is now awake (command completed in %u ms)", 
                     current_command->execute_name.c_str(), duration);
            command_manager->mark_command_completed();
            return;
        }
    }
    
    // For other VCSEC commands in WAITING_FOR_RESPONSE state
    if (current_command->state == BLECommandState::WAITING_FOR_RESPONSE && 
        current_command->domain == UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY) {
        uint32_t duration = millis() - current_command->started_at;
        ESP_LOGV(MESSAGE_HANDLER_TAG, "[%s] VCSEC command handled successfully in %u ms", 
                 current_command->execute_name.c_str(), duration);
        command_manager->mark_command_completed();
    }
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/message_handler.h
================================================
#pragma once

#include <functional>
#include <queue>
#include <memory>
#include <esphome/core/log.h>
#include <universal_message.pb.h>
#include <vcsec.pb.h>
#include <car_server.pb.h>

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const MESSAGE_HANDLER_TAG = "tesla_message_handler";

// Forward declarations
class TeslaBLEVehicle;

/**
 * @brief Message handler for processing Tesla BLE messages
 * 
 * This class handles parsing and processing of various message types from the vehicle,
 * including VCSEC and CarServer responses.
 */
class MessageHandler {
public:
    explicit MessageHandler(TeslaBLEVehicle* parent);
    
    // Main message processing
    void process_response_queue();
    void handle_universal_message(const UniversalMessage_RoutableMessage& message);
    
    // Specific message handlers
    void handle_vcsec_message(const UniversalMessage_RoutableMessage& message);
    void handle_carserver_message(const UniversalMessage_RoutableMessage& message);
    void handle_session_info(const UniversalMessage_RoutableMessage& message, UniversalMessage_Domain domain);
    
    // Vehicle status processing
    void handle_vehicle_status(const VCSEC_VehicleStatus& status);
    void handle_carserver_response(const CarServer_Response& response);
    void process_vehicle_data(const CarServer_VehicleData& vehicle_data);
    void update_command_state_on_response_with_status(const VCSEC_VehicleStatus& status);
    
    // Queue management
    void add_response(const UniversalMessage_RoutableMessage& message);
    size_t get_queue_size() const { return response_queue_.size(); }
    
private:
    TeslaBLEVehicle* parent_;
    std::queue<UniversalMessage_RoutableMessage> response_queue_;
    
    // Helper methods
    bool validate_message(const UniversalMessage_RoutableMessage& message);
    void log_message_details(const UniversalMessage_RoutableMessage& message);
    void update_command_state_on_response(const UniversalMessage_RoutableMessage& message);
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/polling_manager.cpp
================================================
#include "polling_manager.h"
#include "tesla_ble_vehicle.h"
#include "common.h"
#include <client.h>
#include "log.h"
#include <vector>

namespace esphome {
namespace tesla_ble_vehicle {

PollingManager::PollingManager(TeslaBLEVehicle* parent)
    : parent_(parent), last_vcsec_poll_(0), last_infotainment_poll_(0),
      connection_time_(0), just_connected_(false), was_awake_(false),
      was_charging_(false), was_unlocked_(false), was_user_present_(false) {}

void PollingManager::update() {
    if (!parent_->is_connected()) {
        ESP_LOGV(POLLING_MANAGER_TAG, "Not connected, skipping polling");
        return;
    }

    ESP_LOGD(POLLING_MANAGER_TAG, "Polling manager update called (just_connected=%s)", just_connected_ ? "true" : "false");
    
    uint32_t now = millis();
    
    // Handle initial connection - start with VCSEC only, defer infotainment poll
    if (just_connected_) {
        ESP_LOGI(POLLING_MANAGER_TAG, "Just connected - performing initial VCSEC poll, deferring infotainment poll");
        request_vcsec_poll();
        last_vcsec_poll_ = now;
        pending_initial_infotainment_poll_ = true;
        just_connected_ = false;
        return;
    }

    // Always poll VCSEC since ESPHome update_interval matches vcsec_poll_interval
    log_polling_decision("VCSEC status poll", "Regular interval (ESPHome update)");
    request_vcsec_poll();
    last_vcsec_poll_ = now;

    // Check if we should poll infotainment based on smart polling logic
    bool should_poll_infotainment_now = should_poll_infotainment();

    ESP_LOGV(POLLING_MANAGER_TAG, "Infotainment polling check: %s", 
             should_poll_infotainment_now ? "yes" : "no");

    if (should_poll_infotainment_now) {
        std::string reason = get_fast_poll_reason();
        log_polling_decision("Infotainment data poll", reason);
        request_infotainment_poll();
        last_infotainment_poll_ = now;
    }
}

void PollingManager::handle_connection_established() {
    ESP_LOGI(POLLING_MANAGER_TAG, "BLE connection established - setting just_connected flag");
    
    uint32_t now = millis();
    connection_time_ = now;
    wake_time_ = now;  // Assume vehicle is waking up when we connect
    just_connected_ = true;
    
    reset_state_cache();
    reset_polling_timestamps();
    
    ESP_LOGD(POLLING_MANAGER_TAG, "Connection setup complete - ready for immediate poll");
}

void PollingManager::handle_connection_lost() {
    ESP_LOGI(POLLING_MANAGER_TAG, "BLE connection lost");
    
    just_connected_ = false;
    connection_time_ = 0;
    
    reset_state_cache();
    reset_polling_timestamps();
}

void PollingManager::update_vehicle_state(bool is_awake, bool is_charging, bool is_unlocked, bool is_user_present) {
    bool state_changed = (was_awake_ != is_awake) || 
                        (was_charging_ != is_charging) || 
                        (was_unlocked_ != is_unlocked) ||
                        (was_user_present_ != is_user_present);
    
    if (state_changed) {
        ESP_LOGD(POLLING_MANAGER_TAG, "Vehicle state changed: awake=%s, charging=%s, unlocked=%s, user_present=%s",
                 is_awake ? "true" : "false",
                 is_charging ? "true" : "false", 
                 is_unlocked ? "true" : "false",
                 is_user_present ? "true" : "false");
        
        // If vehicle just woke up, track wake time and poll infotainment immediately
        if (!was_awake_ && is_awake) {
            wake_time_ = millis();
            ESP_LOGI(POLLING_MANAGER_TAG, "Vehicle just woke up - tracking wake time and requesting immediate infotainment poll");
            request_infotainment_poll(true);  // true = bypass delay
            last_infotainment_poll_ = millis();
            // Cancel pending initial infotainment poll since we're doing it now due to wake
            pending_initial_infotainment_poll_ = false;
        }
    }
    
    was_awake_ = is_awake;
    was_charging_ = is_charging;
    was_unlocked_ = is_unlocked;
    was_user_present_ = is_user_present;
}

void PollingManager::force_immediate_poll() {
    ESP_LOGI(POLLING_MANAGER_TAG, "Force immediate poll requested");
    
    uint32_t now = millis();
    
    // Force VCSEC poll
    request_vcsec_poll();
    last_vcsec_poll_ = now;
    
    // Force infotainment poll if awake
    if (was_awake_) {
        request_infotainment_poll();
        last_infotainment_poll_ = now;
    }
}

bool PollingManager::should_poll_infotainment() {
    uint32_t now = millis();
    
    // Give a grace period after connection to let VCSEC establish vehicle state first
    uint32_t time_since_connection = time_since(connection_time_);
    if (connection_time_ > 0 && time_since_connection < CONNECTION_GRACE_PERIOD) {
        ESP_LOGV(POLLING_MANAGER_TAG, "Within connection grace period (%u ms), skipping infotainment poll", time_since_connection);
        return false;
    }
    
    // Don't poll infotainment if vehicle is asleep
    if (!was_awake_) {
        ESP_LOGV(POLLING_MANAGER_TAG, "Vehicle asleep, skipping infotainment poll");
        return false;
    }

    // If charging, always poll at active interval regardless of wake time
    if (was_charging_) {
        if (has_elapsed(last_infotainment_poll_, infotainment_poll_interval_active_)) {
            ESP_LOGV(POLLING_MANAGER_TAG, "Vehicle charging, polling at active interval");
            return true;
        }
        return false;
    }

    // If not charging, check if we're within the wake window
    uint32_t time_since_wake = time_since(wake_time_);
    if (time_since_wake >= infotainment_sleep_timeout_) {
        ESP_LOGV(POLLING_MANAGER_TAG, "Vehicle awake for %u ms (>%u ms), allowing sleep - skipping infotainment poll", 
                 time_since_wake, infotainment_sleep_timeout_);
        return false;
    }

    // We're within the wake window, poll at awake interval
    if (has_elapsed(last_infotainment_poll_, infotainment_poll_interval_awake_)) {
        ESP_LOGV(POLLING_MANAGER_TAG, "Vehicle awake for %u ms (<%u ms), polling at awake interval", 
                 time_since_wake, infotainment_sleep_timeout_);
        return true;
    }
    
    return false;
}

uint32_t PollingManager::get_infotainment_poll_interval() {
    if (should_use_fast_polling()) {
        return infotainment_poll_interval_active_;
    } else {
        return infotainment_poll_interval_awake_;
    }
}

bool PollingManager::should_use_fast_polling() {
    // Fast poll if charging, unlocked, or user is present (user might be actively using the vehicle)
    return was_charging_ || was_unlocked_ || was_user_present_;
}

std::string PollingManager::get_fast_poll_reason() {
    std::vector<std::string> reasons;
    if (was_charging_) reasons.push_back("charging");
    if (was_unlocked_) reasons.push_back("unlocked");
    if (was_user_present_) reasons.push_back("user present");
    
    if (reasons.empty()) {
        return "vehicle awake";
    } else if (reasons.size() == 1) {
        return reasons[0];
    } else {
        std::string result = reasons[0];
        for (size_t i = 1; i < reasons.size(); ++i) {
            if (i == reasons.size() - 1) {
                result += " and " + reasons[i];
            } else {
                result += ", " + reasons[i];
            }
        }
        return result;
    }
}

void PollingManager::request_vcsec_poll() {
    ESP_LOGD(POLLING_MANAGER_TAG, "Requesting VCSEC poll");
    
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager) {
        ESP_LOGE(POLLING_MANAGER_TAG, "Command manager not available");
        return;
    }
    
    command_manager->enqueue_vcsec_poll();
}

void PollingManager::request_infotainment_poll(bool bypass_delay) {
    ESP_LOGD(POLLING_MANAGER_TAG, "Requesting infotainment poll (bypass_delay=%s)", bypass_delay ? "true" : "false");
    
    // Check if we should delay this request due to recent commands
    if (!bypass_delay) {
        uint32_t now = millis();
        uint32_t time_since_last = Utils::time_since(now, last_infotainment_poll_);
        constexpr uint32_t MIN_COMMAND_INTERVAL = 2000; // 2 seconds minimum between commands
        if (time_since_last < MIN_COMMAND_INTERVAL) {
            ESP_LOGV(POLLING_MANAGER_TAG, "Skipping infotainment poll - too soon after last poll (%u ms ago)", time_since_last);
            return;
        }
    }
    
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager) {
        ESP_LOGE(POLLING_MANAGER_TAG, "Command manager not available");
        return;
    }
    
    command_manager->enqueue_infotainment_poll();
}

void PollingManager::request_wake_and_poll() {
    ESP_LOGI(POLLING_MANAGER_TAG, "Wake and poll requested");
    
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager) {
        ESP_LOGE(POLLING_MANAGER_TAG, "Command manager not available");
        return;
    }
    
    // Wake command
    command_manager->enqueue_wake_vehicle();
    
    // Then request VCSEC poll to get updated status
    command_manager->enqueue_vcsec_poll();
}

void PollingManager::force_infotainment_poll() {
    ESP_LOGI(POLLING_MANAGER_TAG, "Force infotainment poll requested (bypassing delay)");
    auto* command_manager = parent_->get_command_manager();
    if (command_manager) {
        command_manager->enqueue_infotainment_poll();
    }
}

void PollingManager::force_full_update() {
    ESP_LOGI(POLLING_MANAGER_TAG, "Force full update requested (no wake command)");
    
    auto* command_manager = parent_->get_command_manager();
    if (!command_manager) {
        return;
    }
    
    // Request fresh VCSEC data first (to get current sleep/awake status)
    command_manager->enqueue_vcsec_poll();
    
    // Then request infotainment data (bypassing any delays)
    command_manager->enqueue_infotainment_poll();
}

uint32_t PollingManager::time_since_last_vcsec_poll() const {
    if (last_vcsec_poll_ == 0) {
        return UINT32_MAX;
    }
    return time_since(last_vcsec_poll_);
}

uint32_t PollingManager::time_since_last_infotainment_poll() const {
    if (last_infotainment_poll_ == 0) {
        return UINT32_MAX;
    }
    return time_since(last_infotainment_poll_);
}

// Rollover-safe time calculations
uint32_t PollingManager::time_since(uint32_t timestamp) const {
    return Utils::time_since(millis(), timestamp);
}

bool PollingManager::has_elapsed(uint32_t timestamp, uint32_t interval) const {
    return time_since(timestamp) >= interval;
}

void PollingManager::log_polling_decision(const std::string& action, const std::string& reason) {
    ESP_LOGD(POLLING_MANAGER_TAG, "Polling decision: %s (reason: %s)", action.c_str(), reason.c_str());
}

void PollingManager::reset_state_cache() {
    was_awake_ = false;
    was_charging_ = false;
    was_unlocked_ = false;
    was_user_present_ = false;
}

void PollingManager::reset_polling_timestamps() {
    last_vcsec_poll_ = 0;
    last_infotainment_poll_ = 0;
}

void PollingManager::handle_initial_vcsec_poll_complete() {
    if (pending_initial_infotainment_poll_) {
        ESP_LOGI(POLLING_MANAGER_TAG, "Initial VCSEC poll complete - requesting initial infotainment poll");
        auto* command_manager = parent_->get_command_manager();
        if (command_manager) {
            command_manager->enqueue_infotainment_poll();
        }
        last_infotainment_poll_ = millis();
        pending_initial_infotainment_poll_ = false;
    }
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/polling_manager.h
================================================
#pragma once

#include <esphome/core/log.h>
#include <functional>
#include "common.h"

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const POLLING_MANAGER_TAG = "tesla_polling_manager";

// Forward declarations
class TeslaBLEVehicle;

/**
 * @brief Smart polling manager for Tesla BLE
 * 
 * This class implements intelligent polling strategies to minimize battery drain
 * while ensuring timely updates based on vehicle state.
 */
class PollingManager {
public:
    // Default polling intervals (in milliseconds) - can be overridden
    static constexpr uint32_t DEFAULT_VCSEC_POLL_INTERVAL = 10000;                // 10s - safe for asleep vehicle
    static constexpr uint32_t DEFAULT_INFOTAINMENT_POLL_INTERVAL_AWAKE = 30000;   // 30s - when awake but not active
    static constexpr uint32_t DEFAULT_INFOTAINMENT_POLL_INTERVAL_ACTIVE = 10000;  // 10s - when charging or unlocked
    static constexpr uint32_t INITIAL_CONNECTION_DELAY = 10000;                   // 10s - delay after connection
    static constexpr uint32_t CONNECTION_GRACE_PERIOD = 5000;                     // 5s - grace period for VCSEC establishment
    
    explicit PollingManager(TeslaBLEVehicle* parent);
    
    // Configuration setters
    void set_vcsec_poll_interval(uint32_t interval_ms) { vcsec_poll_interval_ = interval_ms; }
    void set_infotainment_poll_interval_awake(uint32_t interval_ms) { infotainment_poll_interval_awake_ = interval_ms; }
    void set_infotainment_poll_interval_active(uint32_t interval_ms) { infotainment_poll_interval_active_ = interval_ms; }
    void set_infotainment_sleep_timeout(uint32_t interval_ms) { infotainment_sleep_timeout_ = interval_ms; }
    
    // Configuration getters
    uint32_t get_vcsec_poll_interval() const { return vcsec_poll_interval_; }
    uint32_t get_infotainment_poll_interval_awake() const { return infotainment_poll_interval_awake_; }
    uint32_t get_infotainment_poll_interval_active() const { return infotainment_poll_interval_active_; }
    uint32_t get_infotainment_sleep_timeout() const { return infotainment_sleep_timeout_; }
    
    // Main polling logic
    void update();
    void handle_connection_established();
    void handle_connection_lost();
    
    // State tracking
    void update_vehicle_state(bool is_awake, bool is_charging, bool is_unlocked, bool is_user_present);
    void force_immediate_poll();
    
    // Polling decisions
    bool should_poll_infotainment();
    
    // Manual polling triggers
    void request_vcsec_poll();
    void request_infotainment_poll(bool bypass_delay = false);
    void request_wake_and_poll();
    void force_infotainment_poll(); // Always bypasses delay for user-requested updates
    void force_full_update(); // Requests fresh data without sending wake command
    
    // State queries
    bool just_connected() const { return just_connected_; }
    uint32_t time_since_last_vcsec_poll() const;
    uint32_t time_since_last_infotainment_poll() const;
    
private:
    TeslaBLEVehicle* parent_;
    
    // Configurable polling intervals (in milliseconds)
    uint32_t vcsec_poll_interval_{DEFAULT_VCSEC_POLL_INTERVAL};
    uint32_t infotainment_poll_interval_awake_{DEFAULT_INFOTAINMENT_POLL_INTERVAL_AWAKE};
    uint32_t infotainment_poll_interval_active_{DEFAULT_INFOTAINMENT_POLL_INTERVAL_ACTIVE};
    uint32_t infotainment_sleep_timeout_{660000}; // 11 minutes default
    
    // Timing state
    uint32_t last_vcsec_poll_{0};
    uint32_t last_infotainment_poll_{0};
    uint32_t connection_time_{0};
    uint32_t wake_time_{0};  // When vehicle last woke up
    bool just_connected_{false};
    
    // Vehicle state cache
    bool was_awake_{false};
    bool was_charging_{false};
    bool was_unlocked_{false};
    bool was_user_present_{false};
    
    // Helper methods
    uint32_t get_infotainment_poll_interval();
    bool should_use_fast_polling();
    std::string get_fast_poll_reason();
    void log_polling_decision(const std::string& action, const std::string& reason);

    // Rollover-safe time calculations
    uint32_t time_since(uint32_t timestamp) const;
    bool has_elapsed(uint32_t timestamp, uint32_t interval) const;

    // State management helpers
    void reset_state_cache();
    void reset_polling_timestamps();

    // Defer infotainment poll until after initial VCSEC poll completes
    bool pending_initial_infotainment_poll_{false};

public:
    // Called by CommandManager when VCSEC poll completes after initial connection
    void handle_initial_vcsec_poll_complete();
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/session_manager.cpp
================================================
#include "session_manager.h"
#include "tesla_ble_vehicle.h"
#include <client.h>
#include "log.h"
#include <keys.pb.h>
#include <pb_encode.h>
#include <pb_decode.h>
#include <esphome/core/helpers.h>

namespace esphome {
namespace tesla_ble_vehicle {

// Static constants
const char* SessionManager::NVS_KEY_INFOTAINMENT = "tk_infotainment";
const char* SessionManager::NVS_KEY_VCSEC = "tk_vcsec";
const char* SessionManager::NVS_KEY_PRIVATE_KEY = "private_key";

SessionManager::SessionManager(TeslaBLEVehicle* parent)
    : parent_(parent), tesla_client_(std::make_unique<TeslaBLE::Client>()), 
      storage_handle_(0), initialized_(false) {}

SessionManager::~SessionManager() {
    cleanup();
}

bool SessionManager::initialize() {
    ESP_LOGD(SESSION_MANAGER_TAG, "Initializing session manager");
    
    if (!initialize_nvs()) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to initialize NVS");
        return false;
    }
    
    if (!load_private_key()) {
        ESP_LOGW(SESSION_MANAGER_TAG, "Failed to load private key, creating new one");
        if (!create_private_key()) {
            ESP_LOGE(SESSION_MANAGER_TAG, "Failed to create private key");
            return false;
        }
    }
    
    // Load existing session info for both domains
    load_session_info(UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY);
    load_session_info(UniversalMessage_Domain_DOMAIN_INFOTAINMENT);
    
    initialized_ = true;
    ESP_LOGI(SESSION_MANAGER_TAG, "Session manager initialized successfully");
    return true;
}

void SessionManager::cleanup() {
    if (storage_handle_ != 0) {
        nvs_close(storage_handle_);
        storage_handle_ = 0;
    }
    initialized_ = false;
}

bool SessionManager::initialize_nvs() {
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_LOGW(SESSION_MANAGER_TAG, "NVS partition needs to be erased");
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    
    if (err != ESP_OK) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to initialize NVS flash: %s", esp_err_to_name(err));
        return false;
    }
    
    err = nvs_open("storage", NVS_READWRITE, &storage_handle_);
    if (err != ESP_OK) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to open NVS handle: %s", esp_err_to_name(err));
        return false;
    }
    
    return true;
}

bool SessionManager::create_private_key() {
    ESP_LOGI(SESSION_MANAGER_TAG, "Creating new private key");
    
    int result = tesla_client_->createPrivateKey();
    if (result != 0) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to create private key: %d", result);
        return false;
    }
    
    // Get the private key and save it
    unsigned char private_key_buffer[PRIVATE_KEY_SIZE];
    size_t private_key_length = 0;
    
    tesla_client_->getPrivateKey(private_key_buffer, sizeof(private_key_buffer), &private_key_length);
    
    if (!save_to_nvs(NVS_KEY_PRIVATE_KEY, private_key_buffer, private_key_length)) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to save private key to NVS");
        return false;
    }
    
    ESP_LOGI(SESSION_MANAGER_TAG, "Private key created and saved successfully");
    return true;
}

bool SessionManager::load_private_key() {
    ESP_LOGD(SESSION_MANAGER_TAG, "Loading private key from NVS");
    
    std::vector<uint8_t> private_key_data;
    if (!load_from_nvs(NVS_KEY_PRIVATE_KEY, private_key_data)) {
        ESP_LOGD(SESSION_MANAGER_TAG, "No existing private key found");
        return false;
    }
    
    if (private_key_data.size() != PRIVATE_KEY_SIZE) {
        ESP_LOGW(SESSION_MANAGER_TAG, "Invalid private key size: %zu (expected %zu)", 
                 private_key_data.size(), PRIVATE_KEY_SIZE);
        return false;
    }
    
    int result = tesla_client_->loadPrivateKey(private_key_data.data(), private_key_data.size());
    if (result != 0) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to load private key: %d", result);
        return false;
    }
    
    ESP_LOGI(SESSION_MANAGER_TAG, "Private key loaded successfully");
    return true;
}

bool SessionManager::regenerate_key() {
    ESP_LOGI(SESSION_MANAGER_TAG, "Regenerating private key");
    
    // Invalidate existing sessions
    invalidate_session(UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY);
    invalidate_session(UniversalMessage_Domain_DOMAIN_INFOTAINMENT);
    
    // Create new private key
    if (!create_private_key()) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to regenerate private key");
        return false;
    }
    
    ESP_LOGI(SESSION_MANAGER_TAG, "Private key regenerated successfully");
    return true;
}

bool SessionManager::get_public_key(unsigned char* buffer, size_t* length) {
    if (!tesla_client_ || !buffer || !length) {
        return false;
    }
    
    int result = tesla_client_->getPublicKey(buffer, length);
    return result == 0;
}

bool SessionManager::load_session_info(UniversalMessage_Domain domain) {
    ESP_LOGD(SESSION_MANAGER_TAG, "Loading session info for %s", domain_to_string(domain));
    
    const char* nvs_key = get_nvs_key_for_domain(domain);
    if (!nvs_key) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Invalid domain for session loading");
        return false;
    }
    
    std::vector<uint8_t> session_data;
    if (!load_from_nvs(nvs_key, session_data)) {
        ESP_LOGD(SESSION_MANAGER_TAG, "No existing session info found for %s", domain_to_string(domain));
        return false;
    }
    
    Signatures_SessionInfo session_info = Signatures_SessionInfo_init_default;
    if (!decode_session_info(session_data, session_info)) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to decode session info for %s", domain_to_string(domain));
        return false;
    }
    
    log_session_info(session_info);
    
    // Update the Tesla client with the session info
    auto peer = tesla_client_->getPeer(domain);
    if (peer) {
        peer->updateSession(&session_info);
        ESP_LOGI(SESSION_MANAGER_TAG, "Session info loaded for %s", domain_to_string(domain));
        return true;
    }
    
    ESP_LOGE(SESSION_MANAGER_TAG, "Failed to get peer for domain %s", domain_to_string(domain));
    return false;
}

bool SessionManager::save_session_info(const Signatures_SessionInfo& session_info, UniversalMessage_Domain domain) {
    ESP_LOGD(SESSION_MANAGER_TAG, "Saving session info for %s", domain_to_string(domain));
    
    const char* nvs_key = get_nvs_key_for_domain(domain);
    if (!nvs_key) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Invalid domain for session saving");
        return false;
    }
    
    std::vector<uint8_t> encoded_data;
    if (!encode_session_info(session_info, encoded_data)) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to encode session info for %s", domain_to_string(domain));
        return false;
    }
    
    if (!save_to_nvs(nvs_key, encoded_data.data(), encoded_data.size())) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to save session info to NVS for %s", domain_to_string(domain));
        return false;
    }
    
    ESP_LOGI(SESSION_MANAGER_TAG, "Session info saved for %s", domain_to_string(domain));
    return true;
}

int SessionManager::update_session(const Signatures_SessionInfo& session_info, UniversalMessage_Domain domain) {
    ESP_LOGD(SESSION_MANAGER_TAG, "Updating session for %s", domain_to_string(domain));
    
    // Get the peer to check current state
    auto peer = tesla_client_->getPeer(domain);
    if (!peer) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to get peer for domain %s", domain_to_string(domain));
        return -1;
    }
    
    // Log the counter comparison for debugging
    ESP_LOGD(SESSION_MANAGER_TAG, "Session info counter comparison for %s: current=%u, received=%u", 
             domain_to_string(domain), peer->getCounter(), session_info.counter);
    
    // Always try to update with the vehicle's session info first
    int result = peer->updateSession(const_cast<Signatures_SessionInfo*>(&session_info));
    
    if (result == 0) {
        // Successful update - save the session info
        ESP_LOGI(SESSION_MANAGER_TAG, "Successfully updated session for %s with counter %u", 
                 domain_to_string(domain), session_info.counter);
        if (!save_session_info(session_info, domain)) {
            ESP_LOGW(SESSION_MANAGER_TAG, "Failed to save updated session info for %s", domain_to_string(domain));
        }
        return 0;
    } else if (result == TeslaBLE::TeslaBLE_Status_E_ERROR_INVALID_SESSION || result == TeslaBLE::TeslaBLE_Status_E_ERROR_COUNTER_REPLAY) {
        // Counter anti-replay or rollback - the vehicle's session info is the authoritative truth
        // We need to force our session to match the vehicle's state
        ESP_LOGW(SESSION_MANAGER_TAG, "Counter anti-replay detected for %s, forcing session to match vehicle's authoritative state (vehicle counter: %u, our counter: %u)", 
                 domain_to_string(domain), session_info.counter, peer->getCounter());
        
        // Invalidate and erase stored session first
        invalidate_session(domain);
        
        // Force update peer state directly with vehicle's authoritative values
        peer->setCounter(session_info.counter);
        peer->setEpoch(session_info.epoch);
        peer->setTimeZero(std::time(nullptr) - session_info.clock_time);
        peer->setIsValid(true);
        
        // Load Tesla key if provided
        if (session_info.publicKey.size > 0) {
            peer->loadTeslaKey(session_info.publicKey.bytes, session_info.publicKey.size);
        }
        
        // Save the authoritative session info from the vehicle
        if (!save_session_info(session_info, domain)) {
            ESP_LOGW(SESSION_MANAGER_TAG, "Failed to save authoritative session info for %s", domain_to_string(domain));
            return -1;
        }
        
        ESP_LOGI(SESSION_MANAGER_TAG, "Forced session update for %s with vehicle's authoritative counter %u", 
                 domain_to_string(domain), session_info.counter);
        return 0;
    } else {
        // Other errors
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to update session for %s: %d", domain_to_string(domain), result);
        return result;
    }
}

void SessionManager::invalidate_session(UniversalMessage_Domain domain) {
    ESP_LOGI(SESSION_MANAGER_TAG, "Invalidating session for %s", domain_to_string(domain));
    
    auto peer = tesla_client_->getPeer(domain);
    if (peer) {
        peer->setIsValid(false);
    }
    
    // Optionally remove from NVS
    const char* nvs_key = get_nvs_key_for_domain(domain);
    if (nvs_key) {
        nvs_erase_key(storage_handle_, nvs_key);
        nvs_commit(storage_handle_);
    }
}

bool SessionManager::is_domain_authenticated(UniversalMessage_Domain domain) {
    auto peer = tesla_client_->getPeer(domain);
    return peer ? peer->isInitialized() : false;
}

bool SessionManager::request_session_info(UniversalMessage_Domain domain) {
    ESP_LOGD(SESSION_MANAGER_TAG, "Requesting session info for %s", domain_to_string(domain));
    
    if (!tesla_client_) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Tesla client not available");
        return false;
    }
    
    unsigned char message_buffer[MAX_BLE_MESSAGE_SIZE];
    size_t message_length = 0;
    
    int result = tesla_client_->buildSessionInfoRequestMessage(domain, message_buffer, &message_length);
    if (result != 0) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to build session info request: %d", result);
        return false;
    }
    
    // Send via BLE manager
    auto* ble_manager = parent_->get_ble_manager();
    if (!ble_manager) {
        ESP_LOGE(SESSION_MANAGER_TAG, "BLE manager not available");
        return false;
    }
    
    return ble_manager->write_message(message_buffer, message_length) == 0;
}

bool SessionManager::start_pairing(const std::string& role) {
    ESP_LOGI(SESSION_MANAGER_TAG, "Starting pairing with role: %s", role.c_str());
    
    if (!tesla_client_) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Tesla client not available");
        return false;
    }
    
    // Convert role string to enum
    Keys_Role role_enum = Keys_Role_ROLE_DRIVER;
    if (role == "ROLE_CHARGING_MANAGER") {
        role_enum = Keys_Role_ROLE_CHARGING_MANAGER;
    } else if (role == "ROLE_DRIVER") {
        role_enum = Keys_Role_ROLE_DRIVER;
    }
    
    unsigned char whitelist_message_buffer[MAX_BLE_MESSAGE_SIZE];
    size_t whitelist_message_length = 0;
    
    int result = tesla_client_->buildWhiteListMessage(
        role_enum, 
        VCSEC_KeyFormFactor_KEY_FORM_FACTOR_CLOUD_KEY,
        whitelist_message_buffer, 
        &whitelist_message_length);
    
    if (result != 0) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to build whitelist message: %d", result);
        return false;
    }
    
    // Send via BLE manager
    auto* ble_manager = parent_->get_ble_manager();
    if (!ble_manager) {
        ESP_LOGE(SESSION_MANAGER_TAG, "BLE manager not available");
        return false;
    }
    
    if (ble_manager->write_message(whitelist_message_buffer, whitelist_message_length) == 0) {
        ESP_LOGI(SESSION_MANAGER_TAG, "Pairing request sent. Please tap your card on the reader now.");
        return true;
    }
    
    return false;
}

// Private helper methods
bool SessionManager::load_from_nvs(const char* key, std::vector<uint8_t>& data) {
    size_t required_size = 0;
    esp_err_t err = nvs_get_blob(storage_handle_, key, nullptr, &required_size);
    if (err != ESP_OK) {
        return false;
    }
    
    data.resize(required_size);
    err = nvs_get_blob(storage_handle_, key, data.data(), &required_size);
    return err == ESP_OK;
}

bool SessionManager::save_to_nvs(const char* key, const void* data, size_t size) {
    esp_err_t err = nvs_set_blob(storage_handle_, key, data, size);
    if (err != ESP_OK) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to set NVS key %s: %s", key, esp_err_to_name(err));
        return false;
    }
    
    err = nvs_commit(storage_handle_);
    if (err != ESP_OK) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to commit NVS: %s", esp_err_to_name(err));
        return false;
    }
    
    return true;
}

const char* SessionManager::get_nvs_key_for_domain(UniversalMessage_Domain domain) {
    switch (domain) {
        case UniversalMessage_Domain_DOMAIN_INFOTAINMENT:
            return NVS_KEY_INFOTAINMENT;
        case UniversalMessage_Domain_DOMAIN_VEHICLE_SECURITY:
            return NVS_KEY_VCSEC;
        default:
            return nullptr;
    }
}

void SessionManager::log_session_info(const Signatures_SessionInfo& session_info) {
    ESP_LOGD(SESSION_MANAGER_TAG, "Session Info:");
    ESP_LOGD(SESSION_MANAGER_TAG, "  Status: %d", session_info.status);
    ESP_LOGD(SESSION_MANAGER_TAG, "  Counter: %u", session_info.counter);
    ESP_LOGD(SESSION_MANAGER_TAG, "  Clock time: %u", session_info.clock_time);
}

bool SessionManager::encode_session_info(const Signatures_SessionInfo& session_info, std::vector<uint8_t>& encoded) {
    size_t buffer_size = Signatures_SessionInfo_size + 10; // Add padding
    encoded.resize(buffer_size);
    
    pb_ostream_t stream = pb_ostream_from_buffer(encoded.data(), buffer_size);
    
    if (!pb_encode(&stream, Signatures_SessionInfo_fields, &session_info)) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to encode session info: %s", PB_GET_ERROR(&stream));
        return false;
    }
    
    encoded.resize(stream.bytes_written);
    return true;
}

bool SessionManager::decode_session_info(const std::vector<uint8_t>& encoded, Signatures_SessionInfo& session_info) {
    pb_istream_t stream = pb_istream_from_buffer(encoded.data(), encoded.size());
    
    if (!pb_decode(&stream, Signatures_SessionInfo_fields, &session_info)) {
        ESP_LOGE(SESSION_MANAGER_TAG, "Failed to decode session info: %s", PB_GET_ERROR(&stream));
        return false;
    }
    
    return true;
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/session_manager.h
================================================
#pragma once

#include <memory>
#include <vector>
#include <nvs_flash.h>
#include <esphome/core/log.h>
#include <universal_message.pb.h>
#include <signatures.pb.h>
#include "common.h"

namespace TeslaBLE {
    class Client;
}

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const SESSION_MANAGER_TAG = "tesla_session_manager";

// Forward declarations
class TeslaBLEVehicle;

/**
 * @brief Session and authentication manager for Tesla BLE
 * 
 * This class handles session management, private key storage, and authentication
 * with the Tesla vehicle across different domains (VCSEC and Infotainment).
 */
class SessionManager {
public:
    static constexpr size_t PRIVATE_KEY_SIZE = 228;
    static constexpr size_t PUBLIC_KEY_SIZE = 65;
    static const char* NVS_KEY_INFOTAINMENT;
    static const char* NVS_KEY_VCSEC;
    static const char* NVS_KEY_PRIVATE_KEY;
    
    explicit SessionManager(TeslaBLEVehicle* parent);
    ~SessionManager();
    
    // Initialization
    bool initialize();
    void cleanup();
    
    // Key management
    bool create_private_key();
    bool load_private_key();
    bool regenerate_key();
    bool get_public_key(unsigned char* buffer, size_t* length);
    
    // Session management
    bool load_session_info(UniversalMessage_Domain domain);
    bool save_session_info(const Signatures_SessionInfo& session_info, UniversalMessage_Domain domain);
    int update_session(const Signatures_SessionInfo& session_info, UniversalMessage_Domain domain);
    void invalidate_session(UniversalMessage_Domain domain);
    
    // Authentication state
    bool is_domain_authenticated(UniversalMessage_Domain domain);
    bool request_session_info(UniversalMessage_Domain domain);
    
    // Vehicle pairing
    bool start_pairing(const std::string& role);
    
    // Getters
    TeslaBLE::Client* get_client() const { return tesla_client_.get(); }
    
private:
    TeslaBLEVehicle* parent_;
    std::unique_ptr<TeslaBLE::Client> tesla_client_;
    nvs_handle_t storage_handle_;
    bool initialized_;
    
    // NVS operations
    bool initialize_nvs();
    bool load_from_nvs(const char* key, std::vector<uint8_t>& data);
    bool save_to_nvs(const char* key, const void* data, size_t size);
    
    // Helper methods
    const char* get_nvs_key_for_domain(UniversalMessage_Domain domain);
    void log_session_info(const Signatures_SessionInfo& session_info);
    bool encode_session_info(const Signatures_SessionInfo& session_info, std::vector<uint8_t>& encoded);
    bool decode_session_info(const std::vector<uint8_t>& encoded, Signatures_SessionInfo& session_info);
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/tesla_ble_vehicle.cpp
================================================
#include "tesla_ble_vehicle.h"
#include "common.h"
#include "log.h"
#include <esphome/core/helpers.h>
#include <client.h>

namespace esphome {
namespace tesla_ble_vehicle {

TeslaBLEVehicle::TeslaBLEVehicle() : vin_(""), role_("DRIVER") {
    ESP_LOGCONFIG(TAG, "Constructing Tesla BLE Vehicle component");
}

void TeslaBLEVehicle::setup() {
    ESP_LOGCONFIG(TAG, "Setting up TeslaBLEVehicle");
    
    // Initialize BLE UUIDs
    initialize_ble_uuids();
    
    // Initialize all managers
    initialize_managers();
    
    // Configure any sensors that were set before managers were initialized
    configure_pending_sensors();
    
    // Initialize session manager (handles NVS, keys, etc.)
    if (!session_manager_->initialize()) {
        ESP_LOGE(TAG, "Failed to initialize session manager");
        return;
    }
    
    // Set VIN if provided
    if (!vin_.empty()) {
        session_manager_->get_client()->setVIN(vin_.c_str());
    }
    
    // Setup button callbacks
    setup_button_callbacks();
}

void TeslaBLEVehicle::initialize_managers() {
    // Create managers in dependency order
    session_manager_ = std::make_unique<SessionManager>(this);
    ble_manager_ = std::make_unique<BLEManager>(this);
    command_manager_ = std::make_unique<CommandManager>(this);
    message_handler_ = std::make_unique<MessageHandler>(this);
    state_manager_ = std::make_unique<VehicleStateManager>(this);
    polling_manager_ = std::make_unique<PollingManager>(this);
    
    // Configure polling intervals
    polling_manager_->set_vcsec_poll_interval(vcsec_poll_interval_);
    polling_manager_->set_infotainment_poll_interval_awake(infotainment_poll_interval_awake_);
    polling_manager_->set_infotainment_poll_interval_active(infotainment_poll_interval_active_);
    polling_manager_->set_infotainment_sleep_timeout(infotainment_sleep_timeout_);
    
    ESP_LOGD(TAG, "All managers initialized");
}

void TeslaBLEVehicle::initialize_ble_uuids() {
    service_uuid_ = espbt::ESPBTUUID::from_raw(SERVICE_UUID);
    read_uuid_ = espbt::ESPBTUUID::from_raw(READ_UUID);
    write_uuid_ = espbt::ESPBTUUID::from_raw(WRITE_UUID);
}

void TeslaBLEVehicle::setup_button_callbacks() {
    // Note: Button callbacks are handled by the custom button classes
    // This is just for any additional setup if needed
    ESP_LOGD(TAG, "Button callbacks configured");
}

void TeslaBLEVehicle::configure_pending_sensors() {
    ESP_LOGD(TAG, "Configuring pending sensors with state manager");
    
    if (state_manager_) {
        // Configure binary sensors
        if (pending_asleep_sensor_) {
            ESP_LOGD(TAG, "Configuring asleep sensor");
            state_manager_->set_asleep_sensor(pending_asleep_sensor_);
        }
        if (pending_unlocked_sensor_) {
            ESP_LOGD(TAG, "Configuring unlocked sensor");
            state_manager_->set_unlocked_sensor(pending_unlocked_sensor_);
        }
        if (pending_user_present_sensor_) {
            ESP_LOGD(TAG, "Configuring user present sensor");
            state_manager_->set_user_present_sensor(pending_user_present_sensor_);
        }
        if (pending_charge_flap_sensor_) {
            ESP_LOGD(TAG, "Configuring charge flap sensor");
            state_manager_->set_charge_flap_sensor(pending_charge_flap_sensor_);
        }
        if (pending_charger_sensor_) {
            ESP_LOGD(TAG, "Configuring charger sensor");
            state_manager_->set_charger_sensor(pending_charger_sensor_);
        }
        
        // Configure regular sensors
        if (pending_battery_level_sensor_) {
            ESP_LOGD(TAG, "Configuring battery level sensor");
            state_manager_->set_battery_level_sensor(pending_battery_level_sensor_);
        }
        if (pending_charger_power_sensor_) {
            ESP_LOGD(TAG, "Configuring charger power sensor");
            state_manager_->set_charger_power_sensor(pending_charger_power_sensor_);
        }
        if (pending_charger_voltage_sensor_) {
            ESP_LOGD(TAG, "Configuring charger voltage sensor");
            state_manager_->set_charger_voltage_sensor(pending_charger_voltage_sensor_);
        }
        if (pending_charger_current_sensor_) {
            ESP_LOGD(TAG, "Configuring charger current sensor");
            state_manager_->set_charger_current_sensor(pending_charger_current_sensor_);
        }
        if (pending_charging_rate_sensor_) {
            ESP_LOGD(TAG, "Configuring charging rate sensor");
            state_manager_->set_charging_rate_sensor(pending_charging_rate_sensor_);
        }
        
        // Configure text sensors
        if (pending_charging_state_sensor_) {
            ESP_LOGD(TAG, "Configuring charging state sensor");
            state_manager_->set_charging_state_sensor(pending_charging_state_sensor_);
        }
        if (pending_iec61851_state_sensor_) {
            ESP_LOGD(TAG, "Configuring IEC 61851 state sensor");
            state_manager_->set_iec61851_state_sensor(pending_iec61851_state_sensor_);
        }
        
        // Configure controls
        if (pending_charging_switch_) {
            ESP_LOGD(TAG, "Configuring charging switch");
            state_manager_->set_charging_switch(pending_charging_switch_);
        }
        if (pending_charging_amps_number_) {
            ESP_LOGD(TAG, "Configuring charging amps number");
            state_manager_->set_charging_amps_number(pending_charging_amps_number_);
        }
        if (pending_charging_limit_number_) {
            ESP_LOGD(TAG, "Configuring charging limit number");
            state_manager_->set_charging_limit_number(pending_charging_limit_number_);
        }
        
        ESP_LOGD(TAG, "All pending sensors configured");
    } else {
        ESP_LOGE(TAG, "State manager not available for sensor configuration");
    }
}

void TeslaBLEVehicle::loop() {
    if (!is_connected()) {
        // Clear queues and reset state when disconnected
        if (command_manager_->has_pending_commands()) {
            command_manager_->clear_queue();
        }
        return;
    }

    // Process in dependency order
    ble_manager_->process_read_queue();
    message_handler_->process_response_queue();
    command_manager_->process_command_queue();
    ble_manager_->process_write_queue();
}

void TeslaBLEVehicle::update() {
    if (!is_connected()) {
        ESP_LOGV(TAG, "BLE not connected, skipping update");
        return;
    }
    
    ESP_LOGD(TAG, "Update called - delegating to polling manager");

    // Delegate to polling manager
    polling_manager_->update();
}

void TeslaBLEVehicle::dump_config() {
    ESP_LOGCONFIG(TAG, "Tesla BLE Vehicle:");
    ESP_LOGCONFIG(TAG, "  VIN: %s", vin_.empty() ? "Not set" : vin_.c_str());
    ESP_LOGCONFIG(TAG, "  Role: %s", role_.c_str());
    ESP_LOGCONFIG(TAG, "  Max Charging Amps: %d", state_manager_ ? state_manager_->get_charging_amps_max() : 32);
    
    // Show polling intervals
    ESP_LOGCONFIG(TAG, "  Polling Intervals:");
    ESP_LOGCONFIG(TAG, "    VCSEC: %u ms", vcsec_poll_interval_);
    ESP_LOGCONFIG(TAG, "    Infotainment (awake): %u ms", infotainment_poll_interval_awake_);
    ESP_LOGCONFIG(TAG, "    Infotainment (active): %u ms", infotainment_poll_interval_active_);
    
    // Let state manager dump sensor config
    ESP_LOGCONFIG(TAG, "  Sensors configured:");
    // This would be implemented in state_manager_->dump_config()
}

// Configuration setters
void TeslaBLEVehicle::set_vin(const char *vin) {
    if (vin == nullptr) {
        ESP_LOGW(TAG, "Attempted to set null VIN - ignoring");
        return;
    }
    
    vin_ = std::string(vin);
    ESP_LOGD(TAG, "VIN set to: %s", vin_.c_str());
    
    // Only set in client if session manager is initialized
    if (session_manager_ && session_manager_->get_client()) {
        session_manager_->get_client()->setVIN(vin);
        ESP_LOGD(TAG, "VIN configured in Tesla client");
    } else {
        ESP_LOGD(TAG, "VIN stored for later configuration (session manager not ready)");
    }
}

void TeslaBLEVehicle::set_role(const std::string &role) {
    ESP_LOGD(TAG, "Setting role: %s", role.c_str());
    role_ = role;
}

void TeslaBLEVehicle::set_charging_amps_max(int amps_max) {
    ESP_LOGD(TAG, "Setting charging amps max: %d", amps_max);
    
    // Guard against invalid values - don't update if invalid
    if (amps_max <= 0) {
        ESP_LOGW(TAG, "Invalid charging amps max value: %d - ignoring update", amps_max);
        return;
    }
    
    if (state_manager_) {
        state_manager_->set_charging_amps_max(amps_max);
    }
}

// Polling interval setters
void TeslaBLEVehicle::set_vcsec_poll_interval(uint32_t interval_ms) {
    ESP_LOGD(TAG, "Setting VCSEC poll interval: %u ms", interval_ms);
    vcsec_poll_interval_ = interval_ms;
    if (polling_manager_) {
        polling_manager_->set_vcsec_poll_interval(interval_ms);
    }
}

void TeslaBLEVehicle::set_infotainment_poll_interval_awake(uint32_t interval_ms) {
    ESP_LOGD(TAG, "Setting infotainment poll interval awake: %u ms", interval_ms);
    infotainment_poll_interval_awake_ = interval_ms;
    if (polling_manager_) {
        polling_manager_->set_infotainment_poll_interval_awake(interval_ms);
    }
}

void TeslaBLEVehicle::set_infotainment_poll_interval_active(uint32_t interval_ms) {
    ESP_LOGD(TAG, "Setting infotainment poll interval active: %u ms", interval_ms);
    infotainment_poll_interval_active_ = interval_ms;
    if (polling_manager_) {
        polling_manager_->set_infotainment_poll_interval_active(interval_ms);
    }
}

void TeslaBLEVehicle::set_infotainment_sleep_timeout(uint32_t interval_ms) {
    ESP_LOGD(TAG, "Setting infotainment sleep timeout: %u ms", interval_ms);
    infotainment_sleep_timeout_ = interval_ms;
    if (polling_manager_) {
        polling_manager_->set_infotainment_sleep_timeout(interval_ms);
    }
}

// Sensor setters (delegate to state manager)
void TeslaBLEVehicle::set_binary_sensor_is_asleep(binary_sensor::BinarySensor *s) {
    pending_asleep_sensor_ = s;
    if (state_manager_) state_manager_->set_asleep_sensor(s);
}

void TeslaBLEVehicle::set_binary_sensor_is_unlocked(binary_sensor::BinarySensor *s) {
    pending_unlocked_sensor_ = s;
    if (state_manager_) state_manager_->set_unlocked_sensor(s);
}

void TeslaBLEVehicle::set_binary_sensor_is_user_present(binary_sensor::BinarySensor *s) {
    pending_user_present_sensor_ = s;
    if (state_manager_) state_manager_->set_user_present_sensor(s);
}

void TeslaBLEVehicle::set_binary_sensor_is_charge_flap_open(binary_sensor::BinarySensor *s) {
    pending_charge_flap_sensor_ = s;
    if (state_manager_) state_manager_->set_charge_flap_sensor(s);
}

void TeslaBLEVehicle::set_binary_sensor_is_charger_connected(binary_sensor::BinarySensor *s) {
    pending_charger_sensor_ = s;
    if (state_manager_) state_manager_->set_charger_sensor(s);
}

void TeslaBLEVehicle::set_battery_level_sensor(sensor::Sensor *sensor) {
    pending_battery_level_sensor_ = sensor;
    if (state_manager_) state_manager_->set_battery_level_sensor(sensor);
}

void TeslaBLEVehicle::set_charger_power_sensor(sensor::Sensor *sensor) {
    pending_charger_power_sensor_ = sensor;
    if (state_manager_) state_manager_->set_charger_power_sensor(sensor);
}

void TeslaBLEVehicle::set_charger_voltage_sensor(sensor::Sensor *sensor) {
    pending_charger_voltage_sensor_ = sensor;
    if (state_manager_) state_manager_->set_charger_voltage_sensor(sensor);
}

void TeslaBLEVehicle::set_charger_current_sensor(sensor::Sensor *sensor) {
    pending_charger_current_sensor_ = sensor;
    if (state_manager_) state_manager_->set_charger_current_sensor(sensor);
}

void TeslaBLEVehicle::set_charging_rate_sensor(sensor::Sensor *sensor) {
    pending_charging_rate_sensor_ = sensor;
    if (state_manager_) state_manager_->set_charging_rate_sensor(sensor);
}

void TeslaBLEVehicle::set_charging_state_sensor(text_sensor::TextSensor *sensor) {
    pending_charging_state_sensor_ = sensor;
    if (state_manager_) state_manager_->set_charging_state_sensor(sensor);
}

void TeslaBLEVehicle::set_iec61851_state_sensor(text_sensor::TextSensor *sensor) {
    pending_iec61851_state_sensor_ = sensor;
    if (state_manager_) state_manager_->set_iec61851_state_sensor(sensor);
}

// Control setters (delegate to state manager)
void TeslaBLEVehicle::set_charging_switch(switch_::Switch *sw) {
    pending_charging_switch_ = sw;
    if (state_manager_) state_manager_->set_charging_switch(sw);
}

void TeslaBLEVehicle::set_charging_amps_number(number::Number *number) {
    pending_charging_amps_number_ = number;
    if (state_manager_) state_manager_->set_charging_amps_number(number);
}

void TeslaBLEVehicle::set_charging_limit_number(number::Number *number) {
    pending_charging_limit_number_ = number;
    if (state_manager_) state_manager_->set_charging_limit_number(number);
}

// Button setters
void TeslaBLEVehicle::set_wake_button(button::Button *button) {
    ESP_LOGD(TAG, "Setting wake button with parent pointer");
    // Cast to our custom button type and set parent
    TeslaWakeButton* wake_button = static_cast<TeslaWakeButton*>(button);
    if (wake_button) {
        wake_button->set_parent(this);
    }
}

void TeslaBLEVehicle::set_pair_button(button::Button *button) {
    ESP_LOGD(TAG, "Setting pair button with parent pointer");
    TeslaPairButton* pair_button = static_cast<TeslaPairButton*>(button);
    if (pair_button) {
        pair_button->set_parent(this);
    }
}

void TeslaBLEVehicle::set_regenerate_key_button(button::Button *button) {
    ESP_LOGD(TAG, "Setting regenerate key button with parent pointer");
    TeslaRegenerateKeyButton* regen_button = static_cast<TeslaRegenerateKeyButton*>(button);
    if (regen_button) {
        regen_button->set_parent(this);
    }
}

void TeslaBLEVehicle::set_force_update_button(button::Button *button) {
    ESP_LOGD(TAG, "Setting force update button with parent pointer");
    TeslaForceUpdateButton* update_button = static_cast<TeslaForceUpdateButton*>(button);
    if (update_button) {
        update_button->set_parent(this);
    }
}

// Public vehicle actions
int TeslaBLEVehicle::wake_vehicle() {
    ESP_LOGD(TAG, "Sending wake command");
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return -1;
    }
    
    command_manager_->enqueue_wake_vehicle();
    return 0;
}

int TeslaBLEVehicle::start_pairing() {
    ESP_LOGI(TAG, "Pairing requested");
    
    if (!session_manager_) {
        ESP_LOGE(TAG, "Session manager not available");
        return -1;
    }
    
    return session_manager_->start_pairing(role_) ? 0 : -1;
}

int TeslaBLEVehicle::regenerate_key() {
    ESP_LOGI(TAG, "Key regeneration requested");
    
    if (!session_manager_) {
        ESP_LOGE(TAG, "Session manager not available");
        return -1;
    }
    
    return session_manager_->regenerate_key() ? 0 : -1;
}

void TeslaBLEVehicle::force_update() {
    ESP_LOGI(TAG, "Force update requested");
    
    if (!polling_manager_) {
        ESP_LOGW(TAG, "Polling manager not available");
        return;
    }
    
    // Check if vehicle is asleep and needs waking
    if (state_manager_ && state_manager_->is_asleep()) {
        ESP_LOGI(TAG, "Vehicle is asleep, sending wake command first");
        polling_manager_->request_wake_and_poll();
        // After wake, also get fresh infotainment data
        polling_manager_->force_infotainment_poll();
    } else {
        ESP_LOGD(TAG, "Vehicle appears to be awake, requesting fresh data without wake");
        // Vehicle is awake (or status unknown), just get fresh data
        polling_manager_->force_full_update();
    }
}

// Vehicle control actions
int TeslaBLEVehicle::set_charging_state(bool charging) {
    ESP_LOGI(TAG, "Set charging state: %s", charging ? "ON" : "OFF");
    
    // Track command to delay INFOTAINMENT requests
    if (state_manager_) {
        state_manager_->track_command_issued();
    }
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return -1;
    }
    
    command_manager_->enqueue_set_charging_state(charging);
    return 0;
}

int TeslaBLEVehicle::set_charging_amps(int amps) {
    ESP_LOGI(TAG, "Set charging amps: %d", amps);
    
    // Basic validation
    if (amps < 0) {
        ESP_LOGW(TAG, "Invalid charging amps: %d (cannot be negative)", amps);
        return -1;
    }
    
    // Validate against max amps
    int max_amps = state_manager_->get_charging_amps_max();
    if (amps > max_amps) {
        ESP_LOGW(TAG, "Requested amps (%d) exceeds maximum (%d), clamping", amps, max_amps);
        amps = max_amps;
    }
    
    // Track this user change to prevent immediate overwrites from stale vehicle data
    if (state_manager_) {
        state_manager_->track_command_issued();
    }
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return -1;
    }
    
    command_manager_->enqueue_set_charging_amps(amps);
    return 0;
}

int TeslaBLEVehicle::set_charging_limit(int limit) {
    ESP_LOGI(TAG, "Set charging limit: %d%%", limit);
    
    // Validate limit range
    if (limit < MIN_CHARGING_LIMIT || limit > MAX_CHARGING_LIMIT) {
        ESP_LOGW(TAG, "Invalid charging limit: %d%%, must be %d-%d%%", 
                 limit, MIN_CHARGING_LIMIT, MAX_CHARGING_LIMIT);
        return -1;
    }
    
    // Track this user change to prevent immediate overwrites from stale vehicle data
    if (state_manager_) {
        state_manager_->track_command_issued();
    }
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return -1;
    }
    
    command_manager_->enqueue_set_charging_limit(limit);
    return 0;
}

// Data request actions
void TeslaBLEVehicle::request_vehicle_data() {
    ESP_LOGD(TAG, "Vehicle data requested");
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return;
    }
    
    command_manager_->enqueue_infotainment_poll();
}

void TeslaBLEVehicle::request_charging_data() {
    ESP_LOGD(TAG, "Requesting charging data from infotainment");
    
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return;
    }
    
    command_manager_->enqueue_infotainment_poll();
}

void TeslaBLEVehicle::unlock_charge_port() {
    ESP_LOGI(TAG, "Unlock/Open charge port requested");
    if (state_manager_) {
        state_manager_->track_command_issued();
    }
    if (!command_manager_) {
        ESP_LOGE(TAG, "Command manager not available");
        return;
    }
    command_manager_->enqueue_unlock_charge_port();
}
void TeslaBLEVehicle::update_charging_amps_max_value(int32_t new_max) {
    // This method is called by VehicleStateManager when it needs to update max amps
    // but doesn't have access to the Tesla-specific types
    
    // Find the charging amps number component - we know it's our Tesla type
    if (pending_charging_amps_number_) {
        // Cast to our known type - this is safe since we control the creation
        auto* tesla_amps = static_cast<TeslaChargingAmpsNumber*>(pending_charging_amps_number_);
        tesla_amps->update_max_value(new_max);
        ESP_LOGD(TAG, "Updated charging amps max value to %d A", new_max);
    } else {
        ESP_LOGW(TAG, "Charging amps number component not available for max value update");
    }
}

// BLE event handling
void TeslaBLEVehicle::gattc_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if,
                                         esp_ble_gattc_cb_param_t *param) {
    ESP_LOGV(TAG, "GATTC event %d", event);
    
    switch (event) {
        case ESP_GATTC_OPEN_EVT:
            if (param->open.status == ESP_GATT_OK) {
                ESP_LOGI(TAG, "BLE connection established");
                // Small delay to ensure state is fully set before triggering polling
                this->set_timeout(100, [this]() {
                    handle_connection_established();
                });
            }
            break;
            
        case ESP_GATTC_CLOSE_EVT:
            ESP_LOGW(TAG, "BLE connection closed");
            handle_connection_lost();
            break;
            
        case ESP_GATTC_DISCONNECT_EVT:
            ESP_LOGW(TAG, "BLE disconnected");
            this->handle_ = 0;
            this->read_handle_ = 0;
            this->write_handle_ = 0;
            this->node_state = espbt::ClientState::DISCONNECTING;
            break;
            
        case ESP_GATTC_SEARCH_CMPL_EVT: {
            // Setup read characteristic
            auto *readChar = this->parent()->get_characteristic(this->service_uuid_, this->read_uuid_);
            if (readChar == nullptr) {
                ESP_LOGE(TAG, "Read characteristic not found");
                break;
            }
            this->read_handle_ = readChar->handle;
            
            // Register for notifications
            auto reg_status = esp_ble_gattc_register_for_notify(
                this->parent()->get_gattc_if(), 
                this->parent()->get_remote_bda(), 
                readChar->handle);
            if (reg_status) {
                ESP_LOGE(TAG, "Failed to register for notifications: %d", reg_status);
            }
            
            // Setup write characteristic
            auto *writeChar = this->parent()->get_characteristic(this->service_uuid_, this->write_uuid_);
            if (writeChar == nullptr) {
                ESP_LOGE(TAG, "Write characteristic not found");
                break;
            }
            this->write_handle_ = writeChar->handle;
            
            ESP_LOGD(TAG, "BLE characteristics configured");
            break;
        }
            
        case ESP_GATTC_REG_FOR_NOTIFY_EVT:
            if (param->reg_for_notify.status != ESP_GATT_OK) {
                ESP_LOGE(TAG, "Failed to register for notifications");
                break;
            }
            
            this->node_state = espbt::ClientState::ESTABLISHED;
            ESP_LOGI(TAG, "BLE connection fully established");
            break;
            
        case ESP_GATTC_NOTIFY_EVT: {
            // Handle incoming data
            if (param->notify.conn_id != this->parent()->get_conn_id()) {
                break;
            }
            
            std::vector<unsigned char> data(
                param->notify.value, 
                param->notify.value + param->notify.value_len);
            
            if (ble_manager_) {
                ble_manager_->add_received_data(data);
            }
            break;
        }
            
        case ESP_GATTC_WRITE_CHAR_EVT:
            if (param->write.status != ESP_GATT_OK) {
                ESP_LOGW(TAG, "BLE write failed: %d", param->write.status);
            }
            break;
            
        default:
            ESP_LOGV(TAG, "Unhandled GATTC event: %d", event);
            break;
    }
}

void TeslaBLEVehicle::handle_connection_established() {
    ESP_LOGI(TAG, "Connection established - setting up polling");
    
    if (polling_manager_) {
        polling_manager_->handle_connection_established();
        // Note: Don't call this->update() here - polling manager handles initial polls
        ESP_LOGI(TAG, "Initial polling will be handled by polling manager on next update cycle");
    } else {
        ESP_LOGW(TAG, "Polling manager not available during connection establishment");
    }
    
    if (state_manager_) {
        state_manager_->set_sensors_available(true);
    }
    
    this->status_clear_warning();
}

void TeslaBLEVehicle::handle_connection_lost() {
    if (polling_manager_) {
        polling_manager_->handle_connection_lost();
    }
    
    if (state_manager_) {
        state_manager_->set_sensors_available(false);
        state_manager_->reset_all_states();
    }
    
    if (command_manager_) {
        command_manager_->clear_queue();
    }
    
    if (ble_manager_) {
        ble_manager_->clear_queues();
    }
    
    this->status_set_warning("BLE connection lost");
}

// Button implementations (simplified)
void TeslaWakeButton::press_action() {
    if (parent_) parent_->wake_vehicle();
}

void TeslaPairButton::press_action() {
    if (parent_) parent_->start_pairing();
}

void TeslaRegenerateKeyButton::press_action() {
    if (parent_) parent_->regenerate_key();
}

void TeslaForceUpdateButton::press_action() {
    if (parent_) parent_->force_update();
}

void TeslaUnlockChargePortButton::press_action() {
    if (parent_) parent_->unlock_charge_port();
}
void TeslaChargingSwitch::write_state(bool state) {
    if (parent_) {
        parent_->set_charging_state(state);
        publish_state(state);
    }
}

void TeslaChargingAmpsNumber::control(float value) {
    if (!parent_) {
        ESP_LOGW(TAG, "TeslaChargingAmpsNumber: parent not set");
        return;
    }
    
    // Additional bounds checking beyond what ESPHome provides
    float min_val = this->traits.get_min_value();
    float max_val = this->traits.get_max_value();
    
    if (value < min_val || value > max_val) {
        ESP_LOGW(TAG, "Charging amps value %.1f out of bounds [%.1f, %.1f]", value, min_val, max_val);
        return;
    }
    
    ESP_LOGD(TAG, "Setting charging amps to %.0f A", value);
    parent_->set_charging_amps(static_cast<int>(value));
    publish_state(value);
}

void TeslaChargingAmpsNumber::update_max_value(int32_t new_max) {
    // Skip update if new_max is 0 or invalid - likely not ready or invalid value
    if (new_max <= 0) {
        ESP_LOGV(TAG, "Skipping charging amps max update - invalid value: %d A", new_max);
        return;
    }
    
    auto old_max = this->traits.get_max_value();
    
    if (std::abs(old_max - new_max) > 0.1f) {
        ESP_LOGD(TAG, "Updating charging amps max from %.0f to %.0f A", old_max, new_max);
        
        // Update the traits
        this->traits.set_max_value(new_max);
        
        // Clamp current value if it exceeds new max
        if (this->has_state() && this->state > new_max) {
            ESP_LOGD(TAG, "Clamping current value from %.0f to %.0f A", this->state, new_max);
            this->publish_state(new_max);
        }
        
        ESP_LOGW(TAG, "Max charging amps updated to %.0f A - you may need to restart the ESPHome device or reload the ESPHome integration in Home Assistant to see the updated UI limit", new_max);
        
        // Republish current state to ensure it's visible
        if (this->has_state()) {
            this->publish_state(this->state);
        }
    }
}

void TeslaChargingLimitNumber::control(float value) {
    if (!parent_) {
        ESP_LOGW(TAG, "TeslaChargingLimitNumber: parent not set");
        return;
    }
    
    // Additional bounds checking beyond what ESPHome provides
    float min_val = this->traits.get_min_value();
    float max_val = this->traits.get_max_value();
    
    if (value < min_val || value > max_val) {
        ESP_LOGW(TAG, "Charging limit value %.1f out of bounds [%.1f, %.1f]", value, min_val, max_val);
        return;
    }
    
    ESP_LOGD(TAG, "Setting charging limit to %.0f%%", value);
    parent_->set_charging_limit(static_cast<int>(value));
    publish_state(value);
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/tesla_ble_vehicle.h
================================================
#pragma once

#include <memory>
#include <esphome/components/ble_client/ble_client.h>
#include <esphome/components/esp32_ble_tracker/esp32_ble_tracker.h>
#include <esphome/components/binary_sensor/binary_sensor.h>
#include <esphome/components/sensor/sensor.h>
#include <esphome/components/text_sensor/text_sensor.h>
#include <esphome/components/button/button.h>
#include <esphome/components/switch/switch.h>
#include <esphome/components/number/number.h>
#include <esphome/core/component.h>
#include <esphome/core/automation.h>

#include "common.h"
#include "message_handler.h"
#include "command_manager.h"
#include "ble_manager.h"
#include "session_manager.h"
#include "vehicle_state_manager.h"
#include "polling_manager.h"

namespace esphome {
namespace tesla_ble_vehicle {

namespace espbt = esphome::esp32_ble_tracker;

static const char *const TAG = "tesla_ble_vehicle";

// Tesla BLE service UUIDs
static const char *const SERVICE_UUID = "00000211-b2d1-43f0-9b88-960cebf8b91e";
static const char *const READ_UUID = "00000213-b2d1-43f0-9b88-960cebf8b91e";
static const char *const WRITE_UUID = "00000212-b2d1-43f0-9b88-960cebf8b91e";

/**
 * @brief Main Tesla BLE Vehicle component
 * 
 * This is the main component that coordinates all Tesla BLE operations.
 * It uses specialized managers for different aspects of the communication.
 */
class TeslaBLEVehicle : public PollingComponent, public ble_client::BLEClientNode {
public:
    TeslaBLEVehicle();
    ~TeslaBLEVehicle() = default;

    // ESPHome component lifecycle
    void setup() override;
    void loop() override;
    void update() override;
    void dump_config() override;

    // BLE event handling
    void gattc_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if,
                           esp_ble_gattc_cb_param_t *param) override;

    // Configuration setters
    void set_vin(const char *vin);
    void set_role(const std::string &role);
    void set_charging_amps_max(int amps_max);
    
    // Polling interval setters
    void set_vcsec_poll_interval(uint32_t interval_ms);
    void set_infotainment_poll_interval_awake(uint32_t interval_ms);
    void set_infotainment_poll_interval_active(uint32_t interval_ms);
    void set_infotainment_sleep_timeout(uint32_t interval_ms);

    // Sensor setters (delegate to state manager)
    void set_binary_sensor_is_asleep(binary_sensor::BinarySensor *s);
    void set_binary_sensor_is_unlocked(binary_sensor::BinarySensor *s);
    void set_binary_sensor_is_user_present(binary_sensor::BinarySensor *s);
    void set_binary_sensor_is_charge_flap_open(binary_sensor::BinarySensor *s);
    void set_binary_sensor_is_charger_connected(binary_sensor::BinarySensor *s);
    void set_battery_level_sensor(sensor::Sensor *sensor);
    void set_charger_power_sensor(sensor::Sensor *sensor);
    void set_charger_voltage_sensor(sensor::Sensor *sensor);
    void set_charger_current_sensor(sensor::Sensor *sensor);
    void set_charging_rate_sensor(sensor::Sensor *sensor);
    void set_charging_state_sensor(text_sensor::TextSensor *sensor);
    void set_iec61851_state_sensor(text_sensor::TextSensor *sensor);

    // Control setters (delegate to state manager)
    void set_charging_switch(switch_::Switch *sw);
    void set_charging_amps_number(number::Number *number);
    void set_charging_limit_number(number::Number *number);
    void unlock_charge_port();

    // Button setters
    void set_wake_button(button::Button *button);
    void set_pair_button(button::Button *button);
    void set_regenerate_key_button(button::Button *button);
    void set_force_update_button(button::Button *button);

    // Public vehicle actions
    int wake_vehicle();
    int start_pairing();
    int regenerate_key();
    void force_update();

    // Vehicle control actions
    int set_charging_state(bool charging);
    int set_charging_amps(int amps);
    int set_charging_limit(int limit);

    // Data request actions
    void request_vehicle_data();
    void request_charging_data();
    
    // Internal helper methods for state manager
    void update_charging_amps_max_value(int32_t new_max);

    // Manager accessors (for internal use by managers)
    MessageHandler* get_message_handler() const { return message_handler_.get(); }
    CommandManager* get_command_manager() const { return command_manager_.get(); }
    BLEManager* get_ble_manager() const { return ble_manager_.get(); }
    SessionManager* get_session_manager() const { return session_manager_.get(); }
    VehicleStateManager* get_state_manager() const { return state_manager_.get(); }
    PollingManager* get_polling_manager() const { return polling_manager_.get(); }

    // BLE connection state
    bool is_connected() const { return node_state == espbt::ClientState::ESTABLISHED; }
    uint16_t get_read_handle() const { return read_handle_; }
    uint16_t get_write_handle() const { return write_handle_; }

private:
    // Specialized managers
    std::unique_ptr<MessageHandler> message_handler_;
    std::unique_ptr<CommandManager> command_manager_;
    std::unique_ptr<BLEManager> ble_manager_;
    std::unique_ptr<SessionManager> session_manager_;
    std::unique_ptr<VehicleStateManager> state_manager_;
    std::unique_ptr<PollingManager> polling_manager_;

    // BLE connection details
    uint16_t handle_{0};
    uint16_t read_handle_{0};
    uint16_t write_handle_{0};
    espbt::ESPBTUUID service_uuid_;
    espbt::ESPBTUUID read_uuid_;
    espbt::ESPBTUUID write_uuid_;

    // Configuration
    std::string vin_;
    std::string role_{"DRIVER"};
    
    // Polling intervals (in milliseconds) - stored for late initialization
    uint32_t vcsec_poll_interval_{10000};                     // 10s default
    uint32_t infotainment_poll_interval_awake_{30000};        // 30s default 
    uint32_t infotainment_poll_interval_active_{10000};       // 10s default
    uint32_t infotainment_sleep_timeout_{660000};             // 11 minutes (660s) default

    // Temporary storage for sensors before state_manager_ is initialized
    binary_sensor::BinarySensor* pending_asleep_sensor_{nullptr};
    binary_sensor::BinarySensor* pending_unlocked_sensor_{nullptr};
    binary_sensor::BinarySensor* pending_user_present_sensor_{nullptr};
    binary_sensor::BinarySensor* pending_charge_flap_sensor_{nullptr};
    binary_sensor::BinarySensor* pending_charger_sensor_{nullptr};
    sensor::Sensor* pending_battery_level_sensor_{nullptr};
    sensor::Sensor* pending_charger_power_sensor_{nullptr};
    sensor::Sensor* pending_charger_voltage_sensor_{nullptr};
    sensor::Sensor* pending_charger_current_sensor_{nullptr};
    sensor::Sensor* pending_charging_rate_sensor_{nullptr};
    text_sensor::TextSensor* pending_charging_state_sensor_{nullptr};
    text_sensor::TextSensor* pending_iec61851_state_sensor_{nullptr};
    switch_::Switch* pending_charging_switch_{nullptr};
    number::Number* pending_charging_amps_number_{nullptr};
    number::Number* pending_charging_limit_number_{nullptr};

    // Initialization methods
    void initialize_managers();
    void setup_button_callbacks();
    void initialize_ble_uuids();
    void configure_pending_sensors();

    // Connection event handlers
    void handle_connection_established();
    void handle_connection_lost();

    friend class MessageHandler;
    friend class CommandManager;
    friend class BLEManager;
    friend class SessionManager;
    friend class VehicleStateManager;
    friend class PollingManager;
};

// Custom button classes (simplified)
class TeslaWakeButton : public button::Button {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void press_action() override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaPairButton : public button::Button {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void press_action() override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaRegenerateKeyButton : public button::Button {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void press_action() override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaForceUpdateButton : public button::Button {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void press_action() override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaUnlockChargePortButton : public button::Button {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void press_action() override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaChargingSwitch : public switch_::Switch {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void write_state(bool state) override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaChargingAmpsNumber : public number::Number {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
    void update_max_value(int32_t new_max);
protected:
    void control(float value) override;
    TeslaBLEVehicle *parent_{nullptr};
};

class TeslaChargingLimitNumber : public number::Number {
public:
    void set_parent(TeslaBLEVehicle *parent) { parent_ = parent; }
protected:
    void control(float value) override;
    TeslaBLEVehicle *parent_{nullptr};
};

// Action classes for automation (unchanged for compatibility)
template<typename... Ts> class WakeAction : public Action<Ts...> {
public:
    WakeAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void play(Ts... x) override { parent_->wake_vehicle(); }
protected:
    TeslaBLEVehicle *parent_;
};

template<typename... Ts> class PairAction : public Action<Ts...> {
public:
    PairAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void play(Ts... x) override { parent_->start_pairing(); }
protected:
    TeslaBLEVehicle *parent_;
};

template<typename... Ts> class RegenerateKeyAction : public Action<Ts...> {
public:
    RegenerateKeyAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void play(Ts... x) override { parent_->regenerate_key(); }
protected:
    TeslaBLEVehicle *parent_;
};

template<typename... Ts> class ForceUpdateAction : public Action<Ts...> {
public:
    ForceUpdateAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void play(Ts... x) override { parent_->force_update(); }
protected:
    TeslaBLEVehicle *parent_;
};

template<typename... Ts> class SetChargingAction : public Action<Ts...> {
public:
    SetChargingAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void set_state(esphome::TemplatableValue<bool, Ts...> state) { state_ = state; }
    void play(Ts... x) override {
        bool state = state_.value(x...);
        parent_->set_charging_state(state);
    }
protected:
    TeslaBLEVehicle *parent_;
    esphome::TemplatableValue<bool, Ts...> state_;
};

template<typename... Ts> class SetChargingAmpsAction : public Action<Ts...> {
public:
    SetChargingAmpsAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void set_amps(esphome::TemplatableValue<int, Ts...> amps) { amps_ = amps; }
    void play(Ts... x) override {
        int amps = amps_.value(x...);
        parent_->set_charging_amps(amps);
    }
protected:
    TeslaBLEVehicle *parent_;
    esphome::TemplatableValue<int, Ts...> amps_;
};

template<typename... Ts> class SetChargingLimitAction : public Action<Ts...> {
public:
    SetChargingLimitAction(TeslaBLEVehicle *parent) : parent_(parent) {}
    void set_limit(esphome::TemplatableValue<int, Ts...> limit) { limit_ = limit; }
    void play(Ts... x) override {
        int limit = limit_.value(x...);
        parent_->set_charging_limit(limit);
    }
protected:
    TeslaBLEVehicle *parent_;
    esphome::TemplatableValue<int, Ts...> limit_;
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/vehicle_state_manager.cpp
================================================
#include "vehicle_state_manager.h"
#include "tesla_ble_vehicle.h"
#include <esphome/core/helpers.h>
#include <cmath>
#include <algorithm>

namespace esphome {
namespace tesla_ble_vehicle {

VehicleStateManager::VehicleStateManager(TeslaBLEVehicle* parent)
    : parent_(parent), is_charging_(false), charging_amps_max_(32) {}

void VehicleStateManager::update_vehicle_status(const VCSEC_VehicleStatus& status) {
    ESP_LOGD(STATE_MANAGER_TAG, "Updating vehicle status");
    
    update_sleep_status(status.vehicleSleepStatus);
    update_lock_status(status.vehicleLockState);
    update_user_presence(status.userPresence);
    
    // Update charge flap if present (from closure statuses)
    if (status.has_closureStatuses && charge_flap_sensor_) {
        bool flap_open = (status.closureStatuses.chargePort == VCSEC_ClosureState_E_CLOSURESTATE_OPEN);
        update_charge_flap_open(flap_open);
    }
}

void VehicleStateManager::update_sleep_status(VCSEC_VehicleSleepStatus_E status) {
    auto asleep = convert_sleep_status(status);
    if (asleep.has_value()) {
        update_asleep(asleep.value());
    } else {
        set_sensor_available(asleep_sensor_, false);
    }
}

void VehicleStateManager::update_lock_status(VCSEC_VehicleLockState_E status) {
    auto unlocked = convert_lock_status(status);
    if (unlocked.has_value()) {
        update_unlocked(unlocked.value());
    } else {
        set_sensor_available(unlocked_sensor_, false);
    }
}

void VehicleStateManager::update_user_presence(VCSEC_UserPresence_E presence) {
    auto present = convert_user_presence(presence);
    if (present.has_value()) {
        update_user_present(present.value());
    } else {
        set_sensor_available(user_present_sensor_, false);
    }
}

void VehicleStateManager::update_charge_state(const CarServer_ChargeState& charge_state) {
    ESP_LOGD(STATE_MANAGER_TAG, "Updating charge state");
    
    // Update charging status and charging state text
    if (charge_state.has_charging_state) {
        bool was_charging = is_charging_;
        
        // Determine if vehicle is actively charging based on state type
        // Starting state is considered charging since it's transitioning to charge
        bool new_charging_state = (
            charge_state.charging_state.which_type == CarServer_ChargeState_ChargingState_Charging_tag ||
            charge_state.charging_state.which_type == CarServer_ChargeState_ChargingState_Starting_tag
        );
        
        ESP_LOGD(STATE_MANAGER_TAG, "Charging state check: was=%s, new=%s, state_type=%d", 
                 was_charging ? "ON" : "OFF", 
                 new_charging_state ? "ON" : "OFF",
                 charge_state.charging_state.which_type);
        
        is_charging_ = new_charging_state;
        
        // Always sync charging switch with vehicle state, but respect command delay
        // This prevents race conditions where user commands are overwritten by stale vehicle data
        if (charging_switch_ && (!charging_switch_->has_state() || charging_switch_->state != is_charging_)) {
            if (should_delay_infotainment_request()) {
                ESP_LOGD(STATE_MANAGER_TAG, "Delaying charging switch sync due to recent command (vehicle: %s, switch: %s)", 
                         is_charging_ ? "ON" : "OFF", 
                         charging_switch_->state ? "ON" : "OFF");
            } else {
                ESP_LOGD(STATE_MANAGER_TAG, "Syncing charging switch to vehicle state: %s", is_charging_ ? "ON" : "OFF");
                publish_sensor_state(charging_switch_, is_charging_);
            }
        }
        
        if (was_charging != is_charging_) {
            ESP_LOGD(STATE_MANAGER_TAG, "Charging state changed: %s", is_charging_ ? "ON" : "OFF");
        } else {
            ESP_LOGV(STATE_MANAGER_TAG, "Charging state unchanged: %s", is_charging_ ? "ON" : "OFF");
        }
        
        // Update charging state text sensor
        if (charging_state_sensor_) {
            std::string state_text = get_charging_state_text(charge_state.charging_state);
            publish_sensor_state(charging_state_sensor_, state_text);
        }

        // Update IEC 61851 state text sensor (A/B/C/D/E)
        if (iec61851_state_sensor_) {
            std::string iec_text = get_iec61851_state_text(charge_state.charging_state);
            publish_sensor_state(iec61851_state_sensor_, iec_text);
        }
        
        // Update charger connected binary sensor based on charging state
        if (charger_sensor_) {
            bool charger_connected = is_charger_connected_from_state(charge_state.charging_state);
            publish_sensor_state(charger_sensor_, charger_connected);
        }
    }
    
    // Update battery level with validation
    if (charge_state.which_optional_battery_level && battery_level_sensor_) {
        float battery_level = static_cast<float>(charge_state.optional_battery_level.battery_level);
        
        // Validate battery level is within reasonable bounds [0-100] and is a valid number
        if (battery_level >= 0.0f && battery_level <= 100.0f && std::isfinite(battery_level)) {
            ESP_LOGD(STATE_MANAGER_TAG, "Updating battery level to %.1f%%", battery_level);
            publish_sensor_state(battery_level_sensor_, battery_level);
        } else {
            ESP_LOGW(STATE_MANAGER_TAG, "Invalid battery level received: %.1f%% (expected 0-100, finite)", battery_level);
        }
    }
    
    // Calculate charger power using voltage × current for more precision, or fall back to direct power reading
    if (charger_power_sensor_) {
        float calculated_power_w = 0.0f;
        bool has_calculated_power = false;
        
        // Try to calculate power from voltage × current for better precision
        if (charge_state.which_optional_charger_voltage && charge_state.which_optional_charger_actual_current) {
            float voltage = static_cast<float>(charge_state.optional_charger_voltage.charger_voltage);
            float current = static_cast<float>(charge_state.optional_charger_actual_current.charger_actual_current);

            // Calculate power in watts (voltage * current)
            calculated_power_w = (voltage * current);
            has_calculated_power = true;

            ESP_LOGD(STATE_MANAGER_TAG, "Calculated charger power: %.1fV × %.1fA = %.0fW", voltage, current, calculated_power_w);
        }
        // Fall back to direct power reading if calculation not available
        else if (charge_state.which_optional_charger_power) {
            calculated_power_w = static_cast<float>(charge_state.optional_charger_power.charger_power) / 1000.0f;
            has_calculated_power = true;

            ESP_LOGD(STATE_MANAGER_TAG, "Using direct charger power reading: %.0fW", calculated_power_w);
        }
        
        // Update power sensor with validation
        if (has_calculated_power) {
            // Validate power is non-negative, finite, and within Tesla limits (~250kW at Superchargers)
            if (calculated_power_w >= 0.0f && calculated_power_w <= 300000.0f && std::isfinite(calculated_power_w)) {
                ESP_LOGD(STATE_MANAGER_TAG, "Updating charger power to %.3fW", calculated_power_w);
                publish_sensor_state(charger_power_sensor_, calculated_power_w);
            } else {
                ESP_LOGW(STATE_MANAGER_TAG, "Invalid charger power calculated/received: %.3fW (expected 0-300000, finite)", calculated_power_w);
            }
        }
    }
    
    // Update charger voltage with validation
    if (charge_state.which_optional_charger_voltage && charger_voltage_sensor_) {
        float voltage = static_cast<float>(charge_state.optional_charger_voltage.charger_voltage);
        
        // Validate voltage (typical range 100-500V for Tesla chargers) and is finite
        if (voltage >= 0.0f && voltage <= 600.0f && std::isfinite(voltage)) {
            ESP_LOGD(STATE_MANAGER_TAG, "Updating charger voltage to %.1fV", voltage);
            publish_sensor_state(charger_voltage_sensor_, voltage);
        } else {
            ESP_LOGW(STATE_MANAGER_TAG, "Invalid charger voltage received: %.1fV (expected 0-600, finite)", voltage);
        }
    }
    
    // Update charger current with validation
    if (charge_state.which_optional_charger_actual_current && charger_current_sensor_) {
        float current = static_cast<float>(charge_state.optional_charger_actual_current.charger_actual_current);
        
        // Validate current (typical range 0-80A for Tesla chargers) and is finite
        if (current >= 0.0f && current <= 100.0f && std::isfinite(current)) {
            ESP_LOGD(STATE_MANAGER_TAG, "Updating charger current to %.1fA", current);
            publish_sensor_state(charger_current_sensor_, current);
        } else {
            ESP_LOGW(STATE_MANAGER_TAG, "Invalid charger current received: %.1fA (expected 0-100, finite)", current);
        }
    }
    
    // Update charging rate
    if (charge_state.which_optional_charge_rate_mph && charging_rate_sensor_) {
        float rate_mph = static_cast<float>(charge_state.optional_charge_rate_mph.charge_rate_mph);
        publish_sensor_state(charging_rate_sensor_, rate_mph);
    }

    // Update charging amps (from charger actual current)
    if (charge_state.which_optional_charger_actual_current && charging_amps_number_) {
        float amps = static_cast<float>(charge_state.optional_charger_actual_current.charger_actual_current);
        update_charging_amps(amps);
    }
    
    // Update charge limit - update both sensor (read-only) and number (user-controllable)
    if (charge_state.which_optional_charge_limit_soc) {
        float limit = static_cast<float>(charge_state.optional_charge_limit_soc.charge_limit_soc);
        
        // Update the user-controllable number component (with command delay protection)
        if (charging_limit_number_) {
            // Check if we should delay this update due to recent user command
            if (should_delay_infotainment_request()) {
                ESP_LOGD(STATE_MANAGER_TAG, "Delaying charging limit update (%.0f%%) due to recent command", limit);
            } else {
                ESP_LOGD(STATE_MANAGER_TAG, "Updating charging limit number to %.0f%%", limit);
                publish_sensor_state(charging_limit_number_, limit);
            }
        }
    }
    
    // Update max charging amps if available
    if (charge_state.which_optional_charge_current_request_max) {
        int32_t new_max = charge_state.optional_charge_current_request_max.charge_current_request_max;
        ESP_LOGD(STATE_MANAGER_TAG, "Received max charging amps from vehicle: %d A (current stored: %d A)", new_max, charging_amps_max_);
        
        // Skip update if new_max is 0 or invalid - likely not ready or invalid value from vehicle
        if (new_max <= 0) {
            ESP_LOGV(STATE_MANAGER_TAG, "Skipping max charging amps update - invalid value from vehicle: %d A", new_max);
        } else if (new_max != charging_amps_max_) {
            update_charging_amps_max(new_max);
        } else {
            ESP_LOGV(STATE_MANAGER_TAG, "Max charging amps unchanged: %d A", new_max);
        }
    } else {
        ESP_LOGV(STATE_MANAGER_TAG, "No max charging amps data in charge state");
    }
    
    // Update charge flap status if available
    if (charge_state.which_optional_charge_port_door_open) {
        update_charge_flap_open(charge_state.optional_charge_port_door_open.charge_port_door_open);
    }
}

void VehicleStateManager::update_climate_state(const CarServer_ClimateState& climate_state) {
    ESP_LOGD(STATE_MANAGER_TAG, "Updating climate state");
    // Future implementation for climate sensors
}

void VehicleStateManager::update_drive_state(const CarServer_DriveState& drive_state) {
    ESP_LOGD(STATE_MANAGER_TAG, "Updating drive state");
    // Future implementation for drive sensors
}

// Direct state update methods
void VehicleStateManager::update_asleep(bool asleep) {
    ESP_LOGD(STATE_MANAGER_TAG, "Vehicle sleep state: %s", asleep ? "ASLEEP" : "AWAKE");
    publish_sensor_state(asleep_sensor_, asleep);
    
    // Notify polling manager of state change
    if (parent_->get_polling_manager()) {
        parent_->get_polling_manager()->update_vehicle_state(!asleep, is_charging_, is_unlocked(), is_user_present_);
    }
}

void VehicleStateManager::update_unlocked(bool unlocked) {
    ESP_LOGD(STATE_MANAGER_TAG, "Vehicle lock state: %s", unlocked ? "UNLOCKED" : "LOCKED");
    publish_sensor_state(unlocked_sensor_, unlocked);
    
    // Notify polling manager of state change
    if (parent_->get_polling_manager()) {
        parent_->get_polling_manager()->update_vehicle_state(!is_asleep(), is_charging_, unlocked, is_user_present_);
    }
}

void VehicleStateManager::update_user_present(bool present) {
    ESP_LOGD(STATE_MANAGER_TAG, "User presence: %s", present ? "PRESENT" : "NOT_PRESENT");
    publish_sensor_state(user_present_sensor_, present);
    
    is_user_present_ = present;
    
    // Notify polling manager of state change
    if (parent_->get_polling_manager()) {
        parent_->get_polling_manager()->update_vehicle_state(!is_asleep(), is_charging_, is_unlocked(), is_user_present_);
    }
}

void VehicleStateManager::update_charge_flap_open(bool open) {
    ESP_LOGV(STATE_MANAGER_TAG, "Charge flap: %s", open ? "OPEN" : "CLOSED");
    publish_sensor_state(charge_flap_sensor_, open);
}

void VehicleStateManager::update_charging_amps(float amps) {
    ESP_LOGV(STATE_MANAGER_TAG, "Charging amps from vehicle: %.1f A", amps);
    
    // Always update the number component (since we're using delay-based approach)
    publish_sensor_state(charging_amps_number_, amps);
}

// Connection state management
void VehicleStateManager::set_sensors_available(bool available) {
    ESP_LOGD(STATE_MANAGER_TAG, "Setting sensors available: %s", available ? "true" : "false");
    
    set_sensor_available(asleep_sensor_, available);
    set_sensor_available(unlocked_sensor_, available);
    set_sensor_available(user_present_sensor_, available);
    set_sensor_available(charge_flap_sensor_, available);
    
    // For controls, set availability but don't change state
    if (charging_switch_) {
        // Switch availability is managed differently
    }
    if (charging_amps_number_) {
        // Number availability is managed differently  
    }
    if (charging_limit_number_) {
        // Number availability is managed differently
    }
}

void VehicleStateManager::reset_all_states() {
    ESP_LOGD(STATE_MANAGER_TAG, "Resetting all vehicle states");
    
    is_charging_ = false;
    
    // Reset all sensors to unavailable
    set_sensors_available(false);
}

// State queries
bool VehicleStateManager::is_asleep() const {
    return asleep_sensor_ ? asleep_sensor_->state : true; // Default to asleep if unknown
}

bool VehicleStateManager::is_unlocked() const {
    return unlocked_sensor_ ? unlocked_sensor_->state : false; // Default to locked if unknown
}

bool VehicleStateManager::is_user_present() const {
    return user_present_sensor_ ? user_present_sensor_->state : false;
}

bool VehicleStateManager::is_charge_flap_open() const {
    return charge_flap_sensor_ ? charge_flap_sensor_->state : false;
}

float VehicleStateManager::get_charging_amps() const {
    return charging_amps_number_ ? charging_amps_number_->state : 0.0f;
}

// Dynamic limits
void VehicleStateManager::update_charging_amps_max(int32_t new_max) {
    // Additional safety check - should not happen since callers validate, but be defensive
    if (new_max <= 0) {
        ESP_LOGW(STATE_MANAGER_TAG, "Invalid max charging amps value: %d A - ignoring update", new_max);
        return;
    }
    
    int32_t old_max = charging_amps_max_;
    
    // Update stored value
    charging_amps_max_ = new_max;
    
    // Update the number component's maximum value via the parent (which knows about Tesla types)
    if (charging_amps_number_ && old_max != new_max) {
        auto old_trait_max = charging_amps_number_->traits.get_max_value();
        
        // Ask the parent to update the max value since it knows about Tesla-specific types
        if (parent_) {
            parent_->update_charging_amps_max_value(new_max);
            ESP_LOGD(STATE_MANAGER_TAG, "Updated max charging amps from %.0f to %d A via parent", old_trait_max, new_max);
        } else {
            ESP_LOGW(STATE_MANAGER_TAG, "Parent not available to update max charging amps");
        }
    } else {
        ESP_LOGD(STATE_MANAGER_TAG, "Max charging amps set to %d A (no component to update)", new_max);
    }
}

// Private helper methods
void VehicleStateManager::publish_sensor_state(binary_sensor::BinarySensor* sensor, bool state) {
    if (sensor != nullptr && (!sensor->has_state() || sensor->state != state)) {
        sensor->publish_state(state);
    }
}

void VehicleStateManager::publish_sensor_state(sensor::Sensor* sensor, float state) {
    if (sensor != nullptr && (!sensor->has_state() || std::abs(sensor->state - state) > 0.001f)) {
        sensor->publish_state(state);
    }
}

void VehicleStateManager::publish_sensor_state(switch_::Switch* switch_comp, bool state) {
    if (switch_comp != nullptr && (!switch_comp->has_state() || switch_comp->state != state)) {
        switch_comp->publish_state(state);
    }
}

void VehicleStateManager::publish_sensor_state(number::Number* number_comp, float state) {
    if (number_comp != nullptr && (!number_comp->has_state() || std::abs(number_comp->state - state) > 0.001f)) {
        number_comp->publish_state(state);
    }
}

void VehicleStateManager::set_sensor_available(binary_sensor::BinarySensor* sensor, bool available) {
    if (sensor != nullptr) {
        sensor->set_has_state(available);
    }
}

void VehicleStateManager::set_sensor_available(sensor::Sensor* sensor, bool available) {
    if (sensor != nullptr) {
        sensor->set_has_state(available);
    }
}

// State conversion helpers
std::optional<bool> VehicleStateManager::convert_sleep_status(VCSEC_VehicleSleepStatus_E status) {
    switch (status) {
        case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_AWAKE:
            return false; // Not asleep
        case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_ASLEEP:
            return true;  // Asleep
        case VCSEC_VehicleSleepStatus_E_VEHICLE_SLEEP_STATUS_UNKNOWN:
        default:
            return std::nullopt;   // Unknown state
    }
}

std::optional<bool> VehicleStateManager::convert_lock_status(VCSEC_VehicleLockState_E status) {
    switch (status) {
        case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_UNLOCKED:
        case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_SELECTIVE_UNLOCKED:
            return true;  // Unlocked
        case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_LOCKED:
        case VCSEC_VehicleLockState_E_VEHICLELOCKSTATE_INTERNAL_LOCKED:
            return false; // Locked
        default:
            return std::nullopt;   // Unknown state
    }
}

std::optional<bool> VehicleStateManager::convert_user_presence(VCSEC_UserPresence_E presence) {
    switch (presence) {
        case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_PRESENT:
            return true;  // Present
        case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_NOT_PRESENT:
            return false; // Not present
        case VCSEC_UserPresence_E_VEHICLE_USER_PRESENCE_UNKNOWN:
        default:
            return std::nullopt;   // Unknown state
    }
}

void VehicleStateManager::publish_sensor_state(text_sensor::TextSensor* sensor, const std::string& state) {
    if (sensor != nullptr && (!sensor->has_state() || sensor->state != state)) {
        sensor->publish_state(state);
    }
}

std::string VehicleStateManager::get_charging_state_text(const CarServer_ChargeState_ChargingState& state) {
    switch (state.which_type) {
        case CarServer_ChargeState_ChargingState_Unknown_tag:
            return "Unknown";
        case CarServer_ChargeState_ChargingState_Disconnected_tag:
            return "Disconnected";
        case CarServer_ChargeState_ChargingState_NoPower_tag:
            return "No Power";
        case CarServer_ChargeState_ChargingState_Starting_tag:
            return "Starting";
        case CarServer_ChargeState_ChargingState_Charging_tag:
            return "Charging";
        case CarServer_ChargeState_ChargingState_Complete_tag:
            return "Complete";
        case CarServer_ChargeState_ChargingState_Stopped_tag:
            return "Stopped";
        case CarServer_ChargeState_ChargingState_Calibrating_tag:
            return "Calibrating";
        default:
            return "Unknown";
    }
}

bool VehicleStateManager::is_charger_connected_from_state(const CarServer_ChargeState_ChargingState& state) {
    // Charger is considered connected for all states except Disconnected and Unknown
    switch (state.which_type) {
        case CarServer_ChargeState_ChargingState_Disconnected_tag:
        case CarServer_ChargeState_ChargingState_Unknown_tag:
            return false;
        case CarServer_ChargeState_ChargingState_NoPower_tag:
        case CarServer_ChargeState_ChargingState_Starting_tag:
        case CarServer_ChargeState_ChargingState_Charging_tag:
        case CarServer_ChargeState_ChargingState_Complete_tag:
        case CarServer_ChargeState_ChargingState_Stopped_tag:
        case CarServer_ChargeState_ChargingState_Calibrating_tag:
            return true;
        default:
            return false;
    }
}

void VehicleStateManager::update_charger_connected(bool connected) {
    publish_sensor_state(charger_sensor_, connected);
}

std::string VehicleStateManager::get_iec61851_state_text(const CarServer_ChargeState_ChargingState& state) {
    // Map Tesla infotainment charge states to IEC 61851:
    // A = Standby (EVSE ready, vehicle not connected)
    // B = Vehicle detected (connected, not charging)
    // C = Charging (energy flowing / charging sequence)
    // D = Ventilation required (not available via infotainment; map to C when charging)
    // E = No power (connected but no power available)
    // F = Error / Unknown (fallback)
    switch (state.which_type) {
        case CarServer_ChargeState_ChargingState_Disconnected_tag:
            return "A";
        case CarServer_ChargeState_ChargingState_NoPower_tag:
            return "E";
        case CarServer_ChargeState_ChargingState_Starting_tag:
            return "C";
        case CarServer_ChargeState_ChargingState_Charging_tag:
            return "C";
        case CarServer_ChargeState_ChargingState_Complete_tag:
            return "B";
        case CarServer_ChargeState_ChargingState_Stopped_tag:
            return "B";
        case CarServer_ChargeState_ChargingState_Calibrating_tag:
            return "C";
        case CarServer_ChargeState_ChargingState_Unknown_tag:
        default:
            return "F";
    }
}

// Command tracking for INFOTAINMENT request delay
void VehicleStateManager::track_command_issued() {
    last_command_time_ = millis();
    ESP_LOGD(STATE_MANAGER_TAG, "Command issued - will delay INFOTAINMENT requests for %dms", COMMAND_DELAY_TIME);
}

bool VehicleStateManager::should_delay_infotainment_request() const {
    uint32_t now = millis();
    // Rollover-safe time calculation
    uint32_t time_since_command = Utils::time_since(now, last_command_time_);
    
    bool should_delay = time_since_command < COMMAND_DELAY_TIME;
    if (should_delay) {
        ESP_LOGV(STATE_MANAGER_TAG, "Delaying INFOTAINMENT request (%dms since last command)", time_since_command);
    }
    return should_delay;
}

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: components/tesla_ble_vehicle/vehicle_state_manager.h
================================================
#pragma once

#include <esphome/core/log.h>
#include <esphome/components/binary_sensor/binary_sensor.h>
#include <esphome/components/sensor/sensor.h>
#include <esphome/components/text_sensor/text_sensor.h>
#include <esphome/components/switch/switch.h>
#include <esphome/components/number/number.h>
#include <optional>
#include <car_server.pb.h>
#include <vcsec.pb.h>

namespace esphome {
namespace tesla_ble_vehicle {

static const char *const STATE_MANAGER_TAG = "tesla_state_manager";

// Forward declarations
class TeslaBLEVehicle;

/**
 * @brief Vehicle state manager
 * 
 * This class manages the vehicle's state including sensors, switches, and numbers.
 * It handles updates from vehicle data and provides a centralized interface for
 * state management.
 */
class VehicleStateManager {
public:
    explicit VehicleStateManager(TeslaBLEVehicle* parent);
    
    // Sensor setters
    void set_asleep_sensor(binary_sensor::BinarySensor* sensor) { asleep_sensor_ = sensor; }
    void set_unlocked_sensor(binary_sensor::BinarySensor* sensor) { unlocked_sensor_ = sensor; }
    void set_user_present_sensor(binary_sensor::BinarySensor* sensor) { user_present_sensor_ = sensor; }
    void set_charge_flap_sensor(binary_sensor::BinarySensor* sensor) { charge_flap_sensor_ = sensor; }
    void set_charger_sensor(binary_sensor::BinarySensor* sensor) { charger_sensor_ = sensor; }
    void set_battery_level_sensor(sensor::Sensor* sensor) { battery_level_sensor_ = sensor; }
    void set_charger_power_sensor(sensor::Sensor* sensor) { charger_power_sensor_ = sensor; }
    void set_charger_voltage_sensor(sensor::Sensor* sensor) { charger_voltage_sensor_ = sensor; }
    void set_charger_current_sensor(sensor::Sensor* sensor) { charger_current_sensor_ = sensor; }
    void set_charging_rate_sensor(sensor::Sensor* sensor) { charging_rate_sensor_ = sensor; }
    void set_charging_state_sensor(text_sensor::TextSensor* sensor) { charging_state_sensor_ = sensor; }
    
    // Control setters
    void set_charging_switch(switch_::Switch* sw) { charging_switch_ = sw; }
    void set_charging_amps_number(number::Number* number) { charging_amps_number_ = number; }
    void set_charging_limit_number(number::Number* number) { charging_limit_number_ = number; }
    
    // State updates from VCSEC
    void update_vehicle_status(const VCSEC_VehicleStatus& status);
    void update_sleep_status(VCSEC_VehicleSleepStatus_E status);
    void update_lock_status(VCSEC_VehicleLockState_E status);
    void update_user_presence(VCSEC_UserPresence_E presence);
    
    // State updates from CarServer
    void update_charge_state(const CarServer_ChargeState& charge_state);
    void update_climate_state(const CarServer_ClimateState& climate_state);
    void update_drive_state(const CarServer_DriveState& drive_state);
    
    // Direct state updates
    void update_asleep(bool asleep);
    void update_unlocked(bool unlocked);
    void update_user_present(bool present);
    void update_charge_flap_open(bool open);
    void update_charging_amps(float amps);
    void update_charger_connected(bool connected);
    
    // Connection state management
    void set_sensors_available(bool available);
    void reset_all_states();
    
    // State queries
    bool is_asleep() const;
    bool is_unlocked() const;
    bool is_user_present() const;
    bool is_charge_flap_open() const;
    bool is_charging() const { return is_charging_; }
    float get_charging_amps() const;
    
    // Dynamic limits
    void update_charging_amps_max(int32_t new_max);
    int get_charging_amps_max() const { return charging_amps_max_; }
    void set_charging_amps_max(int max) { charging_amps_max_ = max; }
    
    // Command tracking for INFOTAINMENT request delay
    void track_command_issued();
    bool should_delay_infotainment_request() const;
    
private:
    TeslaBLEVehicle* parent_;
    
    // Binary sensors
    binary_sensor::BinarySensor* asleep_sensor_{nullptr};
    binary_sensor::BinarySensor* unlocked_sensor_{nullptr};
    binary_sensor::BinarySensor* user_present_sensor_{nullptr};
    binary_sensor::BinarySensor* charge_flap_sensor_{nullptr};
    binary_sensor::BinarySensor* charger_sensor_{nullptr};
    
    // Sensors
    sensor::Sensor* battery_level_sensor_{nullptr};
    sensor::Sensor* charger_power_sensor_{nullptr};
    sensor::Sensor* charger_voltage_sensor_{nullptr};
    sensor::Sensor* charger_current_sensor_{nullptr};
    sensor::Sensor* charging_rate_sensor_{nullptr};
    
    // Text sensors
    text_sensor::TextSensor* charging_state_sensor_{nullptr};
    text_sensor::TextSensor* iec61851_state_sensor_{nullptr};
    
    // Controls
    switch_::Switch* charging_switch_{nullptr};
    number::Number* charging_amps_number_{nullptr};
    number::Number* charging_limit_number_{nullptr};
    
    // Internal state tracking
    bool is_charging_{false};
    bool is_user_present_{false};
    int charging_amps_max_{32};
    
    // Command delay tracking - prevents stale data from overwriting fresh user commands
    // by delaying INFOTAINMENT requests (polling, force updates, etc.) after commands
    uint32_t last_command_time_{0};
    static const uint32_t COMMAND_DELAY_TIME = 3000; // 3 seconds delay after command
    
    // Helper methods
    void publish_sensor_state(binary_sensor::BinarySensor* sensor, bool state);
    void publish_sensor_state(sensor::Sensor* sensor, float state);
    void publish_sensor_state(switch_::Switch* switch_comp, bool state);
    void publish_sensor_state(number::Number* number_comp, float state);
    void publish_sensor_state(text_sensor::TextSensor* sensor, const std::string& state);
    void set_sensor_available(binary_sensor::BinarySensor* sensor, bool available);
    void set_sensor_available(sensor::Sensor* sensor, bool available);
    
    // State conversion helpers
    std::optional<bool> convert_sleep_status(VCSEC_VehicleSleepStatus_E status);
    std::optional<bool> convert_lock_status(VCSEC_VehicleLockState_E status);
    std::optional<bool> convert_user_presence(VCSEC_UserPresence_E presence);
    std::string get_charging_state_text(const CarServer_ChargeState_ChargingState& state);
    bool is_charger_connected_from_state(const CarServer_ChargeState_ChargingState& state);
    std::string get_iec61851_state_text(const CarServer_ChargeState_ChargingState& state);

public:
    void set_iec61851_state_sensor(text_sensor::TextSensor* sensor) { iec61851_state_sensor_ = sensor; }
};

} // namespace tesla_ble_vehicle
} // namespace esphome



================================================
FILE: packages/base.yml
================================================
substitutions:
  friendly_name: Tesla BLE
  device_name: tesla-ble
  device_description: Interact with Tesla vehicles over BLE using ESPHome and Home Assistant

packages:
  board: !include board.yml
  common: !include common.yml
  project: !include project.yml
  # listener: !include listener.yml # Uncomment this to scan find your VIN BLE MAC address

esphome:
  name: ${device_name}
  name_add_mac_suffix: true
  friendly_name: ${friendly_name}
  comment: ${device_description}
  project:
    name: yoziru.esphome-tesla-ble
    version: "2025.8.17"

logger:
  level: INFO

api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    password: !secret wifi_hotspot_password

captive_portal:



================================================
FILE: packages/board.yml
================================================
esp32:
  board: $board
  variant: $variant
  flash_size: $flash_size
  framework:
    type: esp-idf
    components:
      - name: tesla-ble
        source: https://github.com/yoziru/tesla-ble.git
        ref: v3.3.2


================================================
FILE: packages/client.yml
================================================
substitutions:
  ble_mac_address: !secret ble_mac_address
  tesla_vin: !secret tesla_vin
  charging_amps_max: "32"
  # Polling interval defaults (can be overridden in main config)
  vcsec_poll_interval: "10"
  infotainment_poll_interval_awake: "30" 
  infotainment_poll_interval_active: "10"
  infotainment_sleep_timeout: "660"  # 11 minutes

ble_client:
  - mac_address: $ble_mac_address
    id: ble_tesla_id

# Tesla BLE Vehicle - automatically creates all entities based on role
tesla_ble_vehicle:
  ble_client_id: ble_tesla_id
  id: tesla_ble_vehicle_id
  vin: $tesla_vin
  # update_interval is automatically set to match vcsec_poll_interval
  charging_amps_max: $charging_amps_max
  role: DRIVER  # Options: DRIVER (all controls) or CHARGING_MANAGER (charging + basic controls only)
  
  # Polling intervals (in seconds) - adjust based on your battery life vs responsiveness needs
  vcsec_poll_interval: $vcsec_poll_interval        # Vehicle status polling (also sets ESPHome update_interval)
  infotainment_poll_interval_awake: $infotainment_poll_interval_awake    # Data polling when awake but not active
  infotainment_poll_interval_active: $infotainment_poll_interval_active # Data polling when charging/unlocked/user present (more responsive)
  infotainment_sleep_timeout: $infotainment_sleep_timeout  # How long to poll before allowing sleep

# BLE sensors from the standard ble_client platform
sensor:
  - platform: ble_client
    type: rssi
    ble_client_id: ble_tesla_id
    name: "BLE Signal"
    icon: mdi:bluetooth
    update_interval: 60s
    entity_category: diagnostic

switch:
  - platform: ble_client
    ble_client_id: ble_tesla_id
    name: "BLE Connection"
    entity_category: diagnostic


================================================
FILE: packages/common.yml
================================================
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
    icon: mdi:wifi

  - platform: uptime
    name: "Uptime"
    update_interval: 60s
    icon: mdi:clock-outline

binary_sensor:
  - platform: status
    name: "Status"

text_sensor:
  - platform: version
    name: "Version"
    icon: mdi:cube-outline
  - platform: wifi_info
    ip_address:
      name: "IP Address"

time:
  - platform: homeassistant
    id: homeassistant_time

button:
  - platform: restart
    name: Restart
    icon: mdi:restart
    entity_category: diagnostic



================================================
FILE: packages/external_components.dashboard.yml
================================================
- components: [tesla_ble_vehicle, tesla_ble_listener]
  source: github://yoziru/esphome-tesla-ble/components@main



================================================
FILE: packages/external_components.yml
================================================
- components: [tesla_ble_vehicle, tesla_ble_listener]
  source: components



================================================
FILE: packages/listener.yml
================================================
substitutions:
  tesla_vin: !secret tesla_vin

# Enable this to scan for BLE devices
tesla_ble_listener:
  vin: $tesla_vin



================================================
FILE: packages/project.yml
================================================
esp32_ble_tracker:
  scan_parameters:
    # Depending on the model and state, BLE advertisements come every 20ms or every 150ms.
    interval: 150ms
    # Activate scan only after wifi connect, see https://github.com/esphome/issues/issues/2941#issuecomment-1842369092
    continuous: false

wifi:
  # Activate scan only after wifi connect, see https://github.com/esphome/issues/issues/2941#issuecomment-1842369092
  on_connect:
    - esp32_ble_tracker.start_scan:
        continuous: true
  on_disconnect:
    - esp32_ble_tracker.stop_scan:



================================================
FILE: static/_config.yml
================================================
title: ESPHome Tesla BLE
description: ESPHome Tesla BLE
theme: jekyll-theme-hacker



================================================
FILE: static/index.md
================================================
# About

ESPHome Tesla BLE

# Installation

You can use the button below to install the pre-built firmware directly to your device via USB from the browser.

<esp-web-install-button manifest="./manifest.json"></esp-web-install-button>

<script type="module" src="https://unpkg.com/esp-web-tools@9/dist/web/install-button.js?module"></script>



================================================
FILE: .github/dependabot.yml
================================================
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates

version: 2
updates:
  - package-ecosystem: "pip" # See documentation for possible values
    directory: "/" # Location of package manifests
    schedule:
      interval: "monthly"



================================================
FILE: .github/FUNDING.yml
================================================
github: yoziru



================================================
FILE: .github/workflows/ci.yml
================================================
name: CI

on:
  pull_request:

jobs:
  ci:
    name: Building ${{ matrix.file }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        file:
          - tesla-ble-esp32-generic.yml
          - tesla-ble-m5stack-atoms3.yml
          - tesla-ble-m5stack-nanoc6.yml
    steps:
      - uses: actions/checkout@v4.3.0
      - name: Mock secrets.yaml from example
        run: cp secrets.yaml.example secrets.yaml
      - name: Get ESPHome version
        id: get_esphome_version
        # read esphome version from requirements.txt
        run: |
          esphome_version=$(grep esphome requirements.txt | cut -d'=' -f3)
          echo "esphome_version=$esphome_version" >> "$GITHUB_OUTPUT"
      - name: Build ESPHome firmware to verify configuration
        uses: esphome/build-action@v7.0.0
        with:
          yaml-file: ${{ matrix.file }}
          version: ${{ steps.get_esphome_version.outputs.esphome_version }}


