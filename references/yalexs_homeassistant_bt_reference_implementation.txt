Directory structure:
└── yalexs_ble/
    ├── __init__.py
    ├── binary_sensor.py
    ├── config_cache.py
    ├── config_flow.py
    ├── const.py
    ├── entity.py
    ├── icons.json
    ├── lock.py
    ├── manifest.json
    ├── models.py
    ├── sensor.py
    ├── strings.json
    └── util.py

================================================
FILE: homeassistant/components/yalexs_ble/__init__.py
================================================
"""The Yale Access Bluetooth integration."""

from __future__ import annotations

from yalexs_ble import (
    AuthError,
    ConnectionInfo,
    LockInfo,
    LockState,
    PushLock,
    YaleXSBLEError,
    close_stale_connections_by_address,
    local_name_is_unique,
)

from homeassistant.components import bluetooth
from homeassistant.config_entries import ConfigEntry
from homeassistant.const import CONF_ADDRESS, EVENT_HOMEASSISTANT_STOP, Platform
from homeassistant.core import CALLBACK_TYPE, CoreState, Event, HomeAssistant, callback
from homeassistant.exceptions import ConfigEntryAuthFailed, ConfigEntryNotReady

from .config_cache import async_get_validated_config
from .const import (
    CONF_ALWAYS_CONNECTED,
    CONF_KEY,
    CONF_LOCAL_NAME,
    CONF_SLOT,
    DEVICE_TIMEOUT,
)
from .models import YaleXSBLEData
from .util import async_find_existing_service_info, bluetooth_callback_matcher

type YALEXSBLEConfigEntry = ConfigEntry[YaleXSBLEData]


PLATFORMS: list[Platform] = [
    Platform.BINARY_SENSOR,
    Platform.LOCK,
    Platform.SENSOR,
]


async def async_setup_entry(hass: HomeAssistant, entry: YALEXSBLEConfigEntry) -> bool:
    """Set up Yale Access Bluetooth from a config entry."""
    local_name = entry.data[CONF_LOCAL_NAME]
    address = entry.data[CONF_ADDRESS]
    key = entry.data[CONF_KEY]
    slot = entry.data[CONF_SLOT]
    has_unique_local_name = local_name_is_unique(local_name)
    always_connected = entry.options.get(CONF_ALWAYS_CONNECTED, False)
    push_lock = PushLock(
        local_name, address, None, key, slot, always_connected=always_connected
    )
    id_ = local_name if has_unique_local_name else address
    push_lock.set_name(f"{entry.title} ({id_})")

    # Ensure any lingering connections are closed since the device may not be
    # advertising when its connected to another client which will prevent us
    # from setting the device and setup will fail.
    await close_stale_connections_by_address(address)

    @callback
    def _async_update_ble(
        service_info: bluetooth.BluetoothServiceInfoBleak,
        change: bluetooth.BluetoothChange,
    ) -> None:
        """Update from a ble callback."""
        push_lock.update_advertisement(service_info.device, service_info.advertisement)

    shutdown_callback: CALLBACK_TYPE | None = await push_lock.start()

    @callback
    def _async_shutdown(event: Event | None = None) -> None:
        nonlocal shutdown_callback
        if shutdown_callback:
            shutdown_callback()
            shutdown_callback = None

    entry.async_on_unload(_async_shutdown)

    # We may already have the advertisement, so check for it.
    if service_info := async_find_existing_service_info(hass, local_name, address):
        push_lock.update_advertisement(service_info.device, service_info.advertisement)
    elif hass.state is CoreState.starting:
        # If we are starting and the advertisement is not found, do not delay
        # the setup. We will wait for the advertisement to be found and then
        # discovery will trigger setup retry.
        raise ConfigEntryNotReady("{local_name} ({address}) not advertising yet")

    entry.async_on_unload(
        bluetooth.async_register_callback(
            hass,
            _async_update_ble,
            bluetooth_callback_matcher(local_name, push_lock.address),
            bluetooth.BluetoothScanningMode.PASSIVE,
        )
    )

    try:
        await _async_wait_for_first_update(push_lock, local_name)
    except ConfigEntryAuthFailed:
        # If key has rotated, try to fetch it from the cache
        # and update
        if (validated_config := async_get_validated_config(hass, address)) and (
            validated_config.key != entry.data[CONF_KEY]
            or validated_config.slot != entry.data[CONF_SLOT]
        ):
            assert shutdown_callback is not None
            shutdown_callback()
            push_lock.set_lock_key(validated_config.key, validated_config.slot)
            shutdown_callback = await push_lock.start()
            await _async_wait_for_first_update(push_lock, local_name)
            # If we can use the cached key and slot, update the entry.
            hass.config_entries.async_update_entry(
                entry,
                data={
                    **entry.data,
                    CONF_KEY: validated_config.key,
                    CONF_SLOT: validated_config.slot,
                },
            )
        else:
            raise

    entry.runtime_data = YaleXSBLEData(entry.title, push_lock, always_connected)

    @callback
    def _async_device_unavailable(
        _service_info: bluetooth.BluetoothServiceInfoBleak,
    ) -> None:
        """Handle device not longer being seen by the bluetooth stack."""
        push_lock.reset_advertisement_state()

    entry.async_on_unload(
        bluetooth.async_track_unavailable(
            hass, _async_device_unavailable, push_lock.address
        )
    )

    @callback
    def _async_state_changed(
        new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Handle state changed."""
        if new_state.auth and not new_state.auth.successful:
            entry.async_start_reauth(hass)

    entry.async_on_unload(push_lock.register_callback(_async_state_changed))
    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)
    entry.async_on_unload(
        hass.bus.async_listen_once(EVENT_HOMEASSISTANT_STOP, _async_shutdown)
    )
    return True


async def _async_wait_for_first_update(push_lock: PushLock, local_name: str) -> None:
    """Wait for the first update from the push lock."""
    try:
        await push_lock.wait_for_first_update(DEVICE_TIMEOUT)
    except AuthError as ex:
        raise ConfigEntryAuthFailed(str(ex)) from ex
    except (YaleXSBLEError, TimeoutError) as ex:
        raise ConfigEntryNotReady(
            f"{ex}; Try moving the Bluetooth adapter closer to {local_name}"
        ) from ex


async def async_unload_entry(hass: HomeAssistant, entry: YALEXSBLEConfigEntry) -> bool:
    """Unload a config entry."""
    return await hass.config_entries.async_unload_platforms(entry, PLATFORMS)



================================================
FILE: homeassistant/components/yalexs_ble/binary_sensor.py
================================================
"""Support for yalexs ble binary sensors."""

from __future__ import annotations

from yalexs_ble import ConnectionInfo, DoorStatus, LockInfo, LockState

from homeassistant.components.binary_sensor import (
    BinarySensorDeviceClass,
    BinarySensorEntity,
)
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback

from . import YALEXSBLEConfigEntry
from .entity import YALEXSBLEEntity


async def async_setup_entry(
    hass: HomeAssistant,
    entry: YALEXSBLEConfigEntry,
    async_add_entities: AddConfigEntryEntitiesCallback,
) -> None:
    """Set up YALE XS binary sensors."""
    data = entry.runtime_data
    lock = data.lock
    if lock.lock_info and lock.lock_info.door_sense:
        async_add_entities([YaleXSBLEDoorSensor(data)])


class YaleXSBLEDoorSensor(YALEXSBLEEntity, BinarySensorEntity):
    """Yale XS BLE binary sensor."""

    _attr_device_class = BinarySensorDeviceClass.DOOR

    @callback
    def _async_update_state(
        self, new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Update the state."""
        self._attr_is_on = new_state.door == DoorStatus.OPENED
        super()._async_update_state(new_state, lock_info, connection_info)



================================================
FILE: homeassistant/components/yalexs_ble/config_cache.py
================================================
"""The Yale Access Bluetooth integration."""

from __future__ import annotations

from yalexs_ble import ValidatedLockConfig

from homeassistant.core import HomeAssistant, callback
from homeassistant.util.hass_dict import HassKey

CONFIG_CACHE: HassKey[dict[str, ValidatedLockConfig]] = HassKey(
    "yalexs_ble_config_cache"
)


@callback
def async_add_validated_config(
    hass: HomeAssistant,
    address: str,
    config: ValidatedLockConfig,
) -> None:
    """Add a validated config."""
    hass.data.setdefault(CONFIG_CACHE, {})[address] = config


@callback
def async_get_validated_config(
    hass: HomeAssistant,
    address: str,
) -> ValidatedLockConfig | None:
    """Get the config for a specific address."""
    return hass.data.get(CONFIG_CACHE, {}).get(address)



================================================
FILE: homeassistant/components/yalexs_ble/config_flow.py
================================================
"""Config flow for Yale Access Bluetooth integration."""

from __future__ import annotations

from collections.abc import Mapping
import logging
from typing import Any, Self

from bleak_retry_connector import BleakError, BLEDevice
import voluptuous as vol
from yalexs_ble import (
    AuthError,
    DisconnectedError,
    PushLock,
    ValidatedLockConfig,
    local_name_is_unique,
)
from yalexs_ble.const import YALE_MFR_ID

from homeassistant.components.bluetooth import (
    BluetoothServiceInfoBleak,
    async_ble_device_from_address,
    async_discovered_service_info,
)
from homeassistant.config_entries import (
    ConfigEntry,
    ConfigFlow,
    ConfigFlowResult,
    OptionsFlowWithReload,
)
from homeassistant.const import CONF_ADDRESS
from homeassistant.core import callback
from homeassistant.data_entry_flow import AbortFlow
from homeassistant.helpers.typing import DiscoveryInfoType

from .config_cache import async_add_validated_config, async_get_validated_config
from .const import CONF_ALWAYS_CONNECTED, CONF_KEY, CONF_LOCAL_NAME, CONF_SLOT, DOMAIN
from .util import async_find_existing_service_info, human_readable_name

_LOGGER = logging.getLogger(__name__)


async def async_validate_lock_or_error(
    local_name: str, device: BLEDevice, key: str, slot: int
) -> dict[str, str]:
    """Validate the lock and return errors if any."""
    if len(key) != 32:
        return {CONF_KEY: "invalid_key_format"}
    try:
        bytes.fromhex(key)
    except ValueError:
        return {CONF_KEY: "invalid_key_format"}
    if not isinstance(slot, int) or not 0 <= slot <= 255:
        return {CONF_SLOT: "invalid_key_index"}
    try:
        await PushLock(local_name, device.address, device, key, slot).validate()
    except (DisconnectedError, AuthError, ValueError):
        return {CONF_KEY: "invalid_auth"}
    except BleakError:
        return {"base": "cannot_connect"}
    except Exception:
        _LOGGER.exception("Unexpected error")
        return {"base": "unknown"}
    return {}


class YalexsConfigFlow(ConfigFlow, domain=DOMAIN):
    """Handle a config flow for Yale Access Bluetooth."""

    VERSION = 1

    _address: str | None = None
    _local_name_is_unique = False
    active = False
    local_name: str | None = None

    def __init__(self) -> None:
        """Initialize the config flow."""
        self._discovery_info: BluetoothServiceInfoBleak | None = None
        self._discovered_devices: dict[str, BluetoothServiceInfoBleak] = {}
        self._lock_cfg: ValidatedLockConfig | None = None

    async def async_step_bluetooth(
        self, discovery_info: BluetoothServiceInfoBleak
    ) -> ConfigFlowResult:
        """Handle the bluetooth discovery step."""
        await self.async_set_unique_id(discovery_info.address)
        self._abort_if_unique_id_configured()
        self.local_name = discovery_info.name
        self._discovery_info = discovery_info
        self.context["title_placeholders"] = {
            "name": human_readable_name(
                None, discovery_info.name, discovery_info.address
            ),
        }
        if lock_cfg := async_get_validated_config(self.hass, discovery_info.address):
            self._lock_cfg = lock_cfg
            return await self.async_step_integration_discovery_confirm()
        return await self.async_step_key_slot()

    async def async_step_integration_discovery(
        self, discovery_info: DiscoveryInfoType
    ) -> ConfigFlowResult:
        """Handle a discovered integration."""
        lock_cfg = ValidatedLockConfig(
            discovery_info["name"],
            discovery_info["address"],
            discovery_info["serial"],
            discovery_info["key"],
            discovery_info["slot"],
        )
        async_add_validated_config(self.hass, lock_cfg.address, lock_cfg)

        address = lock_cfg.address
        self.local_name = lock_cfg.local_name
        self._local_name_is_unique = local_name_is_unique(self.local_name)

        # We do not want to raise on progress as integration_discovery takes
        # precedence over other discovery flows since we already have the keys.
        #
        # After we do discovery we will abort the flows that do not have the keys
        # below unless the user is already setting them up.
        await self.async_set_unique_id(address, raise_on_progress=False)
        new_data = {CONF_KEY: lock_cfg.key, CONF_SLOT: lock_cfg.slot}
        self._abort_if_unique_id_configured(updates=new_data)
        for entry in self._async_current_entries():
            if (
                self._local_name_is_unique
                and entry.data.get(CONF_LOCAL_NAME) == lock_cfg.local_name
            ):
                return self.async_update_reload_and_abort(
                    entry, data={**entry.data, **new_data}, reason="already_configured"
                )

        self._discovery_info = async_find_existing_service_info(
            self.hass, self.local_name, address
        )
        if not self._discovery_info:
            return self.async_abort(reason="no_devices_found")

        self._address = address
        if self.hass.config_entries.flow.async_has_matching_flow(self):
            raise AbortFlow("already_in_progress")

        self._lock_cfg = lock_cfg
        self.context["title_placeholders"] = {
            "name": human_readable_name(
                lock_cfg.name, lock_cfg.local_name, self._discovery_info.address
            )
        }
        return await self.async_step_integration_discovery_confirm()

    def is_matching(self, other_flow: Self) -> bool:
        """Return True if other_flow is matching this flow."""
        # Integration discovery should abort other flows unless they
        # are already in the process of being set up since this discovery
        # will already have all the keys and the user can simply confirm.
        if (
            self._local_name_is_unique and other_flow.local_name == self.local_name
        ) or other_flow.unique_id == self._address:
            if other_flow.active:
                # The user has already started interacting with this flow
                # and entered the keys. We abort the discovery flow since
                # we assume they do not want to use the discovered keys for
                # some reason.
                return True
            self.hass.config_entries.flow.async_abort(other_flow.flow_id)

        return False

    async def async_step_integration_discovery_confirm(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Handle a confirmation of discovered integration."""
        assert self._discovery_info is not None
        assert self._lock_cfg is not None
        if user_input is not None:
            return self.async_create_entry(
                title=self._lock_cfg.name,
                data={
                    CONF_LOCAL_NAME: self._discovery_info.name,
                    CONF_ADDRESS: self._discovery_info.address,
                    CONF_KEY: self._lock_cfg.key,
                    CONF_SLOT: self._lock_cfg.slot,
                },
            )

        self._set_confirm_only()
        return self.async_show_form(
            step_id="integration_discovery_confirm",
            description_placeholders={
                "name": self._lock_cfg.name,
                "address": self._discovery_info.address,
            },
        )

    async def async_step_reauth(
        self, entry_data: Mapping[str, Any]
    ) -> ConfigFlowResult:
        """Handle configuration by re-auth."""
        return await self.async_step_reauth_validate()

    async def async_step_reauth_validate(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Handle reauth and validation."""
        errors = {}
        reauth_entry = self._get_reauth_entry()
        if user_input is not None:
            if (
                device := async_ble_device_from_address(
                    self.hass, reauth_entry.data[CONF_ADDRESS], True
                )
            ) is None:
                errors = {"base": "no_longer_in_range"}
            elif not (
                errors := await async_validate_lock_or_error(
                    reauth_entry.data[CONF_LOCAL_NAME],
                    device,
                    user_input[CONF_KEY],
                    user_input[CONF_SLOT],
                )
            ):
                return self.async_update_reload_and_abort(
                    reauth_entry, data_updates=user_input
                )

        return self.async_show_form(
            step_id="reauth_validate",
            data_schema=vol.Schema(
                {vol.Required(CONF_KEY): str, vol.Required(CONF_SLOT): int}
            ),
            description_placeholders={
                "address": reauth_entry.data[CONF_ADDRESS],
                "title": reauth_entry.title,
            },
            errors=errors,
        )

    async def async_step_key_slot(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Handle the key and slot step."""
        errors: dict[str, str] = {}
        discovery_info = self._discovery_info
        assert discovery_info is not None
        address = discovery_info.address
        validated_config = async_get_validated_config(self.hass, address)

        if user_input is not None or validated_config:
            local_name = discovery_info.name
            if validated_config:
                key = validated_config.key
                slot = validated_config.slot
                title = validated_config.name
            else:
                assert user_input is not None
                key = user_input[CONF_KEY]
                slot = user_input[CONF_SLOT]
                title = human_readable_name(None, local_name, address)
            await self.async_set_unique_id(address, raise_on_progress=False)
            self._abort_if_unique_id_configured()
            if not (
                errors := await async_validate_lock_or_error(
                    local_name, discovery_info.device, key, slot
                )
            ):
                return self.async_create_entry(
                    title=title,
                    data={
                        CONF_LOCAL_NAME: discovery_info.name,
                        CONF_ADDRESS: discovery_info.address,
                        CONF_KEY: key,
                        CONF_SLOT: slot,
                    },
                )

        return self.async_show_form(
            step_id="key_slot",
            data_schema=vol.Schema(
                {
                    vol.Required(CONF_KEY): str,
                    vol.Required(CONF_SLOT): int,
                }
            ),
            errors=errors,
            description_placeholders={
                "address": address,
                "title": self._async_get_name_from_address(address),
            },
        )

    async def async_step_user(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Handle the user step to pick discovered device."""
        errors: dict[str, str] = {}

        if user_input is not None:
            self.active = True
            address = user_input[CONF_ADDRESS]
            self._discovery_info = self._discovered_devices[address]
            return await self.async_step_key_slot()

        current_addresses = self._async_current_ids(include_ignore=False)
        current_unique_names = {
            entry.data.get(CONF_LOCAL_NAME)
            for entry in self._async_current_entries()
            if local_name_is_unique(entry.data.get(CONF_LOCAL_NAME))
        }
        for discovery in async_discovered_service_info(self.hass):
            if (
                discovery.address in current_addresses
                or discovery.name in current_unique_names
                or discovery.address in self._discovered_devices
                or YALE_MFR_ID not in discovery.manufacturer_data
            ):
                continue
            self._discovered_devices[discovery.address] = discovery

        if not self._discovered_devices:
            return self.async_abort(reason="no_devices_found")

        data_schema = vol.Schema(
            {
                vol.Required(CONF_ADDRESS): vol.In(
                    {
                        service_info.address: self._async_get_name_from_address(
                            service_info.address
                        )
                        for service_info in self._discovered_devices.values()
                    }
                )
            }
        )
        return self.async_show_form(
            step_id="user",
            data_schema=data_schema,
            errors=errors,
        )

    @callback
    def _async_get_name_from_address(self, address: str) -> str:
        """Get the name of a device from its address."""
        if validated_config := async_get_validated_config(self.hass, address):
            return f"{validated_config.name} ({address})"
        if address in self._discovered_devices:
            service_info = self._discovered_devices[address]
            return f"{service_info.name} ({service_info.address})"
        assert self._discovery_info is not None
        assert self._discovery_info.address == address
        return f"{self._discovery_info.name} ({address})"

    @staticmethod
    @callback
    def async_get_options_flow(
        config_entry: ConfigEntry,
    ) -> YaleXSBLEOptionsFlowHandler:
        """Get the options flow for this handler."""
        return YaleXSBLEOptionsFlowHandler()


class YaleXSBLEOptionsFlowHandler(OptionsFlowWithReload):
    """Handle YaleXSBLE options."""

    async def async_step_init(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Manage the YaleXSBLE options."""
        return await self.async_step_device_options()

    async def async_step_device_options(
        self, user_input: dict[str, Any] | None = None
    ) -> ConfigFlowResult:
        """Manage the YaleXSBLE devices options."""
        if user_input is not None:
            return self.async_create_entry(
                data={CONF_ALWAYS_CONNECTED: user_input[CONF_ALWAYS_CONNECTED]},
            )

        return self.async_show_form(
            step_id="device_options",
            data_schema=vol.Schema(
                {
                    vol.Optional(
                        CONF_ALWAYS_CONNECTED,
                        default=self.config_entry.options.get(
                            CONF_ALWAYS_CONNECTED, False
                        ),
                    ): bool,
                }
            ),
        )



================================================
FILE: homeassistant/components/yalexs_ble/const.py
================================================
"""Constants for the Yale Access Bluetooth integration."""

DOMAIN = "yalexs_ble"

CONF_LOCAL_NAME = "local_name"
CONF_KEY = "key"
CONF_SLOT = "slot"
CONF_ALWAYS_CONNECTED = "always_connected"

DEVICE_TIMEOUT = 55



================================================
FILE: homeassistant/components/yalexs_ble/entity.py
================================================
"""The yalexs_ble integration entities."""

from __future__ import annotations

from yalexs_ble import ConnectionInfo, LockInfo, LockState

from homeassistant.components import bluetooth
from homeassistant.core import callback
from homeassistant.helpers import device_registry as dr
from homeassistant.helpers.device_registry import DeviceInfo
from homeassistant.helpers.entity import Entity

from .const import DOMAIN
from .models import YaleXSBLEData


class YALEXSBLEEntity(Entity):
    """Base class for yale xs ble entities."""

    _attr_has_entity_name = True
    _attr_should_poll = False

    def __init__(self, data: YaleXSBLEData) -> None:
        """Initialize the entity."""
        self._data = data
        self._device = device = data.lock
        self._attr_available = False
        lock_state = device.lock_state
        lock_info = device.lock_info
        connection_info = device.connection_info
        assert lock_state is not None
        assert connection_info is not None
        assert lock_info is not None
        self._attr_unique_id = device.address
        self._attr_device_info = DeviceInfo(
            name=data.title,
            manufacturer=lock_info.manufacturer,
            model=lock_info.model,
            connections={(dr.CONNECTION_BLUETOOTH, device.address)},
            identifiers={(DOMAIN, lock_info.serial)},
            sw_version=lock_info.firmware,
        )
        if device.lock_state:
            self._async_update_state(lock_state, lock_info, connection_info)

    @callback
    def _async_update_state(
        self, new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Update the state."""
        self._attr_available = bool(not new_state.auth or new_state.auth.successful)

    @callback
    def _async_state_changed(
        self, new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Handle state changed."""
        self._async_update_state(new_state, lock_info, connection_info)
        self.async_write_ha_state()

    @callback
    def _async_device_unavailable(
        self, _service_info: bluetooth.BluetoothServiceInfoBleak
    ) -> None:
        """Handle device not longer being seen by the bluetooth stack."""
        self._attr_available = False
        self.async_write_ha_state()

    async def async_added_to_hass(self) -> None:
        """Register callbacks."""
        self.async_on_remove(
            bluetooth.async_track_unavailable(
                self.hass, self._async_device_unavailable, self._device.address
            )
        )
        self.async_on_remove(self._device.register_callback(self._async_state_changed))
        return await super().async_added_to_hass()

    async def async_update(self) -> None:
        """Request a manual update."""
        await self._device.update()



================================================
FILE: homeassistant/components/yalexs_ble/icons.json
================================================
{
  "entity": {
    "lock": {
      "secure_mode": {
        "state": {
          "locked": "mdi:shield-lock"
        }
      }
    }
  }
}



================================================
FILE: homeassistant/components/yalexs_ble/lock.py
================================================
"""Support for Yale Access Bluetooth locks."""

from __future__ import annotations

from typing import Any

from yalexs_ble import ConnectionInfo, LockInfo, LockState, LockStatus

from homeassistant.components.lock import LockEntity
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback

from . import YALEXSBLEConfigEntry
from .entity import YALEXSBLEEntity
from .models import YaleXSBLEData


async def async_setup_entry(
    hass: HomeAssistant,
    entry: YALEXSBLEConfigEntry,
    async_add_entities: AddConfigEntryEntitiesCallback,
) -> None:
    """Set up locks."""
    async_add_entities(
        [YaleXSBLELock(entry.runtime_data), YaleXSBLESecureModeLock(entry.runtime_data)]
    )


class YaleXSBLEBaseLock(YALEXSBLEEntity, LockEntity):
    """A yale xs ble lock."""

    _secure_mode: bool = False

    @callback
    def _async_update_state(
        self, new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Update the state."""
        self._attr_is_locked = False
        self._attr_is_locking = False
        self._attr_is_unlocking = False
        self._attr_is_jammed = False
        lock_state = new_state.lock
        if lock_state is LockStatus.LOCKED:
            self._attr_is_locked = not self._secure_mode
        elif lock_state is LockStatus.LOCKING:
            self._attr_is_locking = True
        elif lock_state is LockStatus.UNLOCKING:
            self._attr_is_unlocking = True
        elif lock_state is LockStatus.SECUREMODE:
            self._attr_is_locked = True
        elif lock_state in (
            LockStatus.UNKNOWN_01,
            LockStatus.UNKNOWN_06,
            LockStatus.JAMMED,
        ):
            self._attr_is_jammed = True
        elif lock_state is LockStatus.UNKNOWN:
            self._attr_is_locked = None
        super()._async_update_state(new_state, lock_info, connection_info)

    async def async_unlock(self, **kwargs: Any) -> None:
        """Unlock the lock."""
        await self._device.unlock()


class YaleXSBLELock(YaleXSBLEBaseLock, LockEntity):
    """A yale xs ble lock not in secure mode."""

    _attr_name = None

    async def async_lock(self, **kwargs: Any) -> None:
        """Lock the lock."""
        await self._device.lock()


class YaleXSBLESecureModeLock(YaleXSBLEBaseLock):
    """A yale xs ble lock in secure mode."""

    _attr_entity_registry_enabled_default = False
    _attr_translation_key = "secure_mode"
    _secure_mode = True

    def __init__(self, data: YaleXSBLEData) -> None:
        """Initialize the entity."""
        super().__init__(data)
        self._attr_unique_id = f"{self._device.address}_secure_mode"

    async def async_lock(self, **kwargs: Any) -> None:
        """Lock the lock."""
        await self._device.securemode()



================================================
FILE: homeassistant/components/yalexs_ble/manifest.json
================================================
{
  "domain": "yalexs_ble",
  "name": "Yale Access Bluetooth",
  "bluetooth": [
    {
      "manufacturer_id": 465,
      "service_uuid": "0000fe24-0000-1000-8000-00805f9b34fb"
    }
  ],
  "codeowners": ["@bdraco"],
  "config_flow": true,
  "dependencies": ["bluetooth_adapters"],
  "documentation": "https://www.home-assistant.io/integrations/yalexs_ble",
  "iot_class": "local_push",
  "requirements": ["yalexs-ble==3.2.4"]
}



================================================
FILE: homeassistant/components/yalexs_ble/models.py
================================================
"""The yalexs_ble integration models."""

from __future__ import annotations

from dataclasses import dataclass

from yalexs_ble import PushLock


@dataclass
class YaleXSBLEData:
    """Data for the yale xs ble integration."""

    title: str
    lock: PushLock
    always_connected: bool



================================================
FILE: homeassistant/components/yalexs_ble/sensor.py
================================================
"""Support for yalexs ble sensors."""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass

from yalexs_ble import ConnectionInfo, LockInfo, LockState

from homeassistant.components.sensor import (
    SensorDeviceClass,
    SensorEntity,
    SensorEntityDescription,
    SensorStateClass,
)
from homeassistant.const import (
    PERCENTAGE,
    SIGNAL_STRENGTH_DECIBELS_MILLIWATT,
    EntityCategory,
    UnitOfElectricPotential,
)
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback

from . import YALEXSBLEConfigEntry
from .entity import YALEXSBLEEntity
from .models import YaleXSBLEData


@dataclass(frozen=True, kw_only=True)
class YaleXSBLESensorEntityDescription(SensorEntityDescription):
    """Describes Yale Access Bluetooth sensor entity."""

    value_fn: Callable[[LockState, LockInfo, ConnectionInfo], int | float | None]


SENSORS: tuple[YaleXSBLESensorEntityDescription, ...] = (
    YaleXSBLESensorEntityDescription(
        key="",  # No key for the original RSSI sensor unique id
        device_class=SensorDeviceClass.SIGNAL_STRENGTH,
        entity_category=EntityCategory.DIAGNOSTIC,
        state_class=SensorStateClass.MEASUREMENT,
        has_entity_name=True,
        native_unit_of_measurement=SIGNAL_STRENGTH_DECIBELS_MILLIWATT,
        entity_registry_enabled_default=False,
        value_fn=lambda state, info, connection: connection.rssi,
    ),
    YaleXSBLESensorEntityDescription(
        key="battery_level",
        device_class=SensorDeviceClass.BATTERY,
        entity_category=EntityCategory.DIAGNOSTIC,
        state_class=SensorStateClass.MEASUREMENT,
        has_entity_name=True,
        native_unit_of_measurement=PERCENTAGE,
        value_fn=lambda state, info, connection: state.battery.percentage
        if state.battery
        else None,
    ),
    YaleXSBLESensorEntityDescription(
        key="battery_voltage",
        translation_key="battery_voltage",
        device_class=SensorDeviceClass.VOLTAGE,
        entity_category=EntityCategory.DIAGNOSTIC,
        state_class=SensorStateClass.MEASUREMENT,
        has_entity_name=True,
        native_unit_of_measurement=UnitOfElectricPotential.VOLT,
        entity_registry_enabled_default=False,
        value_fn=lambda state, info, connection: state.battery.voltage
        if state.battery
        else None,
    ),
)


async def async_setup_entry(
    hass: HomeAssistant,
    entry: YALEXSBLEConfigEntry,
    async_add_entities: AddConfigEntryEntitiesCallback,
) -> None:
    """Set up YALE XS Bluetooth sensors."""
    data = entry.runtime_data
    async_add_entities(YaleXSBLESensor(description, data) for description in SENSORS)


class YaleXSBLESensor(YALEXSBLEEntity, SensorEntity):
    """Yale XS Bluetooth sensor."""

    entity_description: YaleXSBLESensorEntityDescription

    def __init__(
        self,
        description: YaleXSBLESensorEntityDescription,
        data: YaleXSBLEData,
    ) -> None:
        """Initialize the sensor."""
        self.entity_description = description
        super().__init__(data)
        self._attr_unique_id = f"{data.lock.address}{description.key}"

    @callback
    def _async_update_state(
        self, new_state: LockState, lock_info: LockInfo, connection_info: ConnectionInfo
    ) -> None:
        """Update the state."""
        self._attr_native_value = self.entity_description.value_fn(
            new_state, lock_info, connection_info
        )
        super()._async_update_state(new_state, lock_info, connection_info)



================================================
FILE: homeassistant/components/yalexs_ble/strings.json
================================================
{
  "config": {
    "abort": {
      "already_configured": "[%key:common::config_flow::abort::already_configured_device%]",
      "already_in_progress": "[%key:common::config_flow::abort::already_in_progress%]",
      "no_devices_found": "[%key:common::config_flow::abort::no_devices_found%]",
      "reauth_successful": "[%key:common::config_flow::abort::reauth_successful%]"
    },
    "error": {
      "cannot_connect": "[%key:common::config_flow::error::cannot_connect%]",
      "invalid_auth": "[%key:common::config_flow::error::invalid_auth%]",
      "invalid_key_format": "The offline key must be a 32-byte hex string.",
      "invalid_key_index": "The offline key slot must be an integer between 0 and 255.",
      "no_longer_in_range": "The lock is no longer in Bluetooth range. Move the lock or adapter and try again.",
      "unknown": "[%key:common::config_flow::error::unknown%]"
    },
    "flow_title": "{name}",
    "step": {
      "integration_discovery_confirm": {
        "description": "Do you want to set up {name} over Bluetooth with address {address}?"
      },
      "key_slot": {
        "data": {
          "key": "Offline Key (32-byte hex string)",
          "slot": "Offline Key Slot (Integer between 0 and 255)"
        },
        "description": "Enter the key for the {title} lock with address {address}. If you are using the August or Yale cloud integration to obtain the key, you may be able to avoid this manual setup by reloading the August or Yale cloud integration while the lock is in Bluetooth range."
      },
      "reauth_validate": {
        "data": {
          "key": "[%key:component::yalexs_ble::config::step::key_slot::data::key%]",
          "slot": "[%key:component::yalexs_ble::config::step::key_slot::data::slot%]"
        },
        "description": "Enter the updated key for the {title} lock with address {address}. If you are using the August or Yale cloud integration to obtain the key, you may be able to avoid manual re-authentication by reloading the August or Yale cloud integration while the lock is in Bluetooth range."
      },
      "user": {
        "data": {
          "address": "Bluetooth address"
        },
        "description": "Select the device you want to set up over Bluetooth."
      }
    }
  },
  "entity": {
    "lock": {
      "secure_mode": {
        "name": "Secure mode"
      }
    },
    "sensor": {
      "battery_voltage": {
        "name": "Battery voltage"
      }
    }
  },
  "options": {
    "step": {
      "device_options": {
        "data": {
          "always_connected": "Always connected"
        },
        "description": "If the lock does not support push updates via advertisements or you want lock operation to be more responsive, you can enable always connected mode. Always connected will cause the lock to stay connected to Home Assistant via Bluetooth, which will use more battery."
      }
    }
  }
}



================================================
FILE: homeassistant/components/yalexs_ble/util.py
================================================
"""The yalexs_ble integration models."""

from __future__ import annotations

import platform

from yalexs_ble import local_name_is_unique

from homeassistant.components.bluetooth import (
    BluetoothServiceInfoBleak,
    async_discovered_service_info,
)
from homeassistant.components.bluetooth.match import (
    ADDRESS,
    LOCAL_NAME,
    BluetoothCallbackMatcher,
)
from homeassistant.core import HomeAssistant, callback


def bluetooth_callback_matcher(
    local_name: str, address: str
) -> BluetoothCallbackMatcher:
    """Return a BluetoothCallbackMatcher for the given local_name and address."""
    # On MacOS, coreblueooth uses UUIDs for addresses so we must
    # have a unique local_name to match since the system
    # hides the address from us.
    if local_name_is_unique(local_name) and platform.system() == "Darwin":
        return BluetoothCallbackMatcher({LOCAL_NAME: local_name})
    # On every other platform we actually get the mac address
    # which is needed for the older August locks that use the
    # older version of the underlying protocol.
    return BluetoothCallbackMatcher({ADDRESS: address})


@callback
def async_find_existing_service_info(
    hass: HomeAssistant, local_name: str, address: str
) -> BluetoothServiceInfoBleak | None:
    """Return the service info for the given local_name and address."""
    has_unique_local_name = local_name_is_unique(local_name)
    for service_info in async_discovered_service_info(hass):
        device = service_info.device
        if (
            has_unique_local_name and device.name == local_name
        ) or device.address == address:
            return service_info
    return None


def short_address(address: str) -> str:
    """Convert a Bluetooth address to a short address."""
    split_address = address.replace("-", ":").split(":")
    return f"{split_address[-2].upper()}{split_address[-1].upper()}"[-4:]


def human_readable_name(name: str | None, local_name: str, address: str) -> str:
    """Return a human readable name for the given name, local_name, and address."""
    return f"{name or local_name} ({short_address(address)})"


